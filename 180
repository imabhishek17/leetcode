 Find the duplicate in an array of N integers. 
             OR
   Find the Duplicate Number
   
   Example 1:
Input: [1,3,4,2,2]
Output: 2
Example 2:

Input: [3,1,3,4,2]
Output: 3
--------------


 class Solution {
public:
    int findDuplicate(vector<int>& nums)
    {
      for(int i=0;i<nums.size();i++)
      {
         int idx=abs(nums[i]);
         if(nums[idx]<0) return idx;
            nums[idx]=-nums[idx];
      }
        return -1;
	}
};
//////////////////////////////////////////////////////////////// 
   
   
Find All Duplicates in an Array(LEETCODE)
Example:
Input:
[4,3,2,7,8,2,3,1]

Output:
[2,3]
-----------------

class Solution {
public:
    vector<int> findDuplicates(vector<int>& nums) 
    {
       vector<int>vec;
        for(int i=0;i<nums.size();i++)
        {
         int idx=abs(nums[i])-1;
         if(nums[idx]<0) vec.push_back(idx+1);
            nums[idx]=-nums[idx];
        }
        return vec;
    }
};
/////////////////////////////////////////////////////////////////////

  Multiply Strings   (LEETCODE)

  Example 1:

Input: num1 = "2", num2 = "3"
Output: "6"
Example 2:

Input: num1 = "123", num2 = "456"
Output: "56088"
----------------------------------------------------

class Solution {
public:
    string multiply(string a, string b) {
    if (a=="0" || b=="0")
        return "0";
    int m = a.size() - 1, n = b.size() - 1, carry = 0;
    string product;
    for (int i=0; i<=m+n || carry; ++i) {
        for (int j=max(0, i-n); j<=min(i, m); ++j)
            carry += (a[m-j] - '0') * (b[n-i+j] - '0');
        product += carry % 10 + '0';
        carry /= 10;
    }
    reverse(begin(product), end(product));
    return product;
    }
};

/////////////////////////////////////////////////////////////////////

   Add Binary

  Example 1:

Input: a = "11", b = "1"
Output: "100"
Example 2:

Input: a = "1010", b = "1011"
Output: "10101"
---------------------------------------------
class Solution {
public:
    string addBinary(string a, string b) {
       string s = "";
        
        int c = 0, i = a.size() - 1, j = b.size() - 1;
        while(i >= 0 || j >= 0 || c == 1)
        {
            c += i >= 0 ? a[i --] - '0' : 0;
            c += j >= 0 ? b[j --] - '0' : 0;
            s = char(c % 2 + '0') + s;
            c /= 2;
        }
        
        return s;
    }
};

////////////////////////////////////////////////////////////////////////

   Add to Array-Form of Integer

   Example 1:

Input: A = [1,2,0,0], K = 34
Output: [1,2,3,4]
Explanation: 1200 + 34 = 1234
Example 2:

Input: A = [2,7,4], K = 181
Output: [4,5,5]
Explanation: 274 + 181 = 455
Example 3:

Input: A = [2,1,5], K = 806
Output: [1,0,2,1]
Explanation: 215 + 806 = 1021
Example 4:

Input: A = [9,9,9,9,9,9,9,9,9,9], K = 1
Output: [1,0,0,0,0,0,0,0,0,0,0]
Explanation: 9999999999 + 1 = 10000000000
---------------------------------------------------------

class Solution {
public:
    vector<int> addToArrayForm(vector<int>& A, int K) {
      reverse(A.begin(), A.end());
    for (int i = 0; i < A.size(); i++) {
        A[i] += K;
        K = A[i] / 10;
        A[i] %= 10;
    }
    while (K) {
        A.push_back(K%10);
        K /= 10;
    }
    reverse(A.begin(), A.end());
    return A;
    }
};

Time Complexity: O(max(N,log K))
space: O(1)
/////////////////////////////////////////////////////////////////////////

  Plus One

  Example 1:

Input: [1,2,3]
Output: [1,2,4]
Explanation: The array represents the integer 123.
Example 2:

Input: [4,3,2,1]
Output: [4,3,2,2]
Explanation: The array represents the integer 4321.
-----------------------------------------------------------

class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
         for(int i = digits.size() - 1;i >= 0;i--){
            if(digits[i] != 9){
                digits[i]++;
                return digits;
            }
            else
                digits[i] = 0;
        }
        digits.insert(digits.begin(),1);
        return digits;
    }
};

////////////////////////////////////////////////////////////////////////

Sum of Two Integers

Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.
Example 1:
Input: a = 1, b = 2
Output: 3

Example 2:
Input: a = -2, b = 3
Output: 1
-------------------------------------------------------------------

class Solution {
public:
    int getSum(int a, int b) {
        if (b==0) return a;
	int sum = a^b; //find sum
	int carry = (unsigned int)(a & b)<<1; //find carry
	return getSum(sum, carry);
    }
};
/////////////////////////////////////////////////////////////////////////

 Sort an array of 0’s 1’s 2’s without using extra space or sorting algo 

   Input: [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
--------------------------------

class Solution {
public:
    void sortColors(vector<int>& nums) 
    { 
      int a=0,b=0,c=0;
        for(int i=0;i<nums.size();i++)
        {
            if(nums[i]==0)a++;
            if(nums[i]==1)b++;
            if(nums[i]==2)c++;
        }
        int x=0;
        while(a--)
        {
          nums[x++]=0;
        }
         while(b--)
        {
          nums[x++]=1;
        }
         while(c--)
        {
          nums[x++]=2;
        }
        
    }
    
};
//////////////////////////////////////////////////////////////////////////////////////////

   Missing Number

   Input: [3,0,1]
Output: 2

Input: [9,6,4,2,3,5,7,0,1]
Output: 8
-------------------------------------------

class Solution {
public:
    int missingNumber(vector<int>& nums) {
       int sum=0;
        for(int i=0;i<nums.size();i++)
        {
          sum^=nums[i]^(i+1);
        }

        return sum;
    }
};
///////////////////////////////////////////////////////////////////////////////////////////////

Repeat and Missing Number Array


Input:[3 1 2 5 3] 
Output:[3, 4] 

-------------------------------------------

class Solution {
public:
    vector<int> repeatedNumber(const vector<int> &V) {
       long long sum = 0;
       long long squareSum = 0;
       long long temp;
       for (int i = 0; i < V.size(); i++) {
           temp = V[i];
           sum += temp;
           sum -= (i + 1);
           squareSum += (temp * temp);
           squareSum -= ((long long)(i + 1) * (long long)(i + 1));
       }
       // sum = A - B
       // squareSum = A^2 - B^2 = (A - B)(A + B)
       // squareSum / sum = A + B
       squareSum /= sum;

       // Now we have A + B and A - B. Lets figure out A and B now. 
       int A = (int) ((sum + squareSum) / 2);
       int B = squareSum - A;

       vector<int> ret;
       ret.push_back(A);
       ret.push_back(B);
       return ret;
    }
};
///////////////////////////////////////////////////////////////////////////////////////////////////////

Numbers With Repeated Digits

Example 1:

Input: 20
Output: 1
Explanation: The only positive number (<= 20) with at least 1 repeated digit is 11.
Example 2:

Input: 100
Output: 10
Explanation: The positive numbers (<= 100) with atleast 1 repeated digit are 11, 22, 33, 44, 55, 66, 77, 88, 99, and 100.
-------------------------------------------------------------------

class Solution {
public:
    int numDupDigitsAtMostN(int N) {
         if(N < 10) return 0;
        int k = 0;
        for(int i = N; i > 0; i /= 10)
          k++;
        
      vector<int>digit(k,0);
      int i=0,j=N;
      while(i<k)
      {
        digit[k-1-i]=j%10;
        j/=10;
        i++;
      }
      
        int noDupBaseSum = 0;
        vector<int>noDupBase(k-1,0);
        for(int i = 0; i < k - 1; i++)
        {
            
           if(i==0)
           {
            noDupBase[i]=9; 
           }
          else
          {
            noDupBase[i]=noDupBase[i-1]*(10-i);
          }
          
            noDupBaseSum += noDupBase[i];
        }
        
        int count[10] = {0};
        vector<int>noDupRes(k,0);
        bool duplicate = false;
        for(int i = 0; i < k; i++)
        {
          
           if(i==0)
           {
            noDupRes[i]=9; 
           }
           else
           {
            noDupRes[i]=noDupRes[i-1]*(10-i);
           }
          
            if(!duplicate)
            {
                int diff = 0;
                for(int j = digit[i] + 1; j < 10; j++)
                  diff += count[j] == 0;
                
                noDupRes[i] -= diff;
                count[digit[i]]++;
                if(count[digit[i]] > 1) duplicate = true;
            }
        }
        return N - (noDupBaseSum + noDupRes[k - 1]);
    }
};
///////////////////////////////////////////////////////////////////////////////////////

 Missing Number


Example 1:

Input: [3,0,1]
Output: 2
Example 2:

Input: [9,6,4,2,3,5,7,0,1]
Output: 8
----------------------------------

class Solution {
public:
    int missingNumber(vector<int>& nums) {
       int sum=0;
        for(int i=0;i<nums.size();i++)
        {
          sum^=nums[i]^(i+1);
        }

        return sum;
    }
};
///////////////////////////////////////////////////////////////////////////////////////////

Find All Numbers Disappeared in an Array

Example:

Input:
[4,3,2,7,8,2,3,1]

Output:
[5,6]
-------------------------------------------------------

class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        int len = nums.size();
        for(int i=0; i<len; i++) {
            int m = abs(nums[i])-1; // index start from 0
            nums[m] = nums[m]>0 ? -nums[m] : nums[m];
        }
        vector<int> res;
        for(int i = 0; i<len; i++) {
            if(nums[i] > 0) res.push_back(i+1);
        }
        return res;
    }
};
////////////////////////////////////////////////////////////////////////////////////////////////////////
Merge Sorted Array

Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.
Note:
The number of elements initialized in nums1 and nums2 are m and n respectively.
You may assume that nums1 has enough space (size that is equal to m + n) to hold additional elements from nums2.

Example:
Input:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3
Output: [1,2,2,3,5,6]
--------------------------------------------------------

class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
       int i=0,j=0,k=0;
        i=m-1;
        j=n-1;
        k=(m+n-1);
        while(i>=0 && j>=0)
        {
            if(nums1[i]>nums2[j])
                nums1[k--]=nums1[i--];
            else
                nums1[k--]=nums2[j--];
        }
        while(j>=0)
        {
            nums1[k--]=nums2[j--];
        }
    }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
   Kadane’s Algorithm 
        OR
   Maximum Subarray(LEETCODE)
 

   Example:

Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
-----------------------------------------------------------------

class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int cs=0,ms=INT_MIN;
        for(int i=0;i<nums.size();i++)
        {
         cs=cs+nums[i];
            if(cs<nums[i])
                cs=nums[i];
            if(ms<cs)
                ms=cs;
        }
        return ms;
        
    }
};
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////


Merge Overlapping Subintervals 
   OR
Merge Intervals

Example 1:

Input: [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].
Example 2:

Input: [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
---------------------------------------------------------------------------

class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
      
      if(!intervals.size())return {};
        vector<vector<int>>ans;
      sort(begin(intervals),end(intervals));
        ans.push_back(intervals[0]);
      
        for(int i=1;i<intervals.size();i++)
        {
          int n=ans.size();
          if(intervals[i][0]<=ans[n-1][1])
            ans[n-1][1]=max(intervals[i][1],ans[n-1][1]);
          
          else
            ans.push_back(intervals[i]);
        }
      return ans;
        
    }
};
//////////////////////////////////////////////////////////////////////////////////////////////

Set Matrix Zeros 

Example 1:
Input: 
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
Output: 
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]

Example 2:
Input: 
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
Output: 
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]
---------------------------------------------

class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
      int n=matrix.size();
      int m=matrix[0].size();
      int r[n];
      int c[m];
      for(int i=0;i<n;i++)
      	r[i]=1;

      for(int i=0;i<m;i++)
      	c[i]=1;
      

      for(int i=0;i<n;i++)
      {
      	for(int j=0;j<m;j++)
        {
        	if(matrix[i][j]==0)
        	{
        		r[i]=0;
                c[j]=0;
            
        	}
        }
      }

      for(int i=0;i<n;i++)
      {
        for(int j=0;j<m;j++)
        {
        	if(r[i]==0||c[j]==0)
        	{
              matrix[i][j]=0;
        	}
        }
      }
      
      
    }
};

Time Complexity : O(M×N)
Space Complexity : O(M+N)


ALTERNATE SOLUTION:

class Solution {
public:
    void setZeroes(vector<vector<int>>& v) {
        int r=v.size(), c=v[0].size();
        bool x=0;
        
        for(int i=0;i<r;i++)
        {
            if(v[i][0]==0)
            {
                x=1;
            }
            for(int j=1;j<c;j++)
            {
                if(v[i][j]==0)
                {
                    v[0][j]=0;
                    v[i][0]=0;
                }
            }
        }
        
        for(int i=1;i<r;i++)
        {
          for(int j=1;j<c;j++)
          {
            if(v[i][0]==0 || v[0][j]==0)
            {
                v[i][j]=0;
            }
          }
        }
        
        if(v[0][0]==0)
        {
            for(int j=0;j<c;j++)
            {
                v[0][j]=0;
            }
        }
        
        if(x)
        {
          for(int i=0;i<r;i++)
          {
              v[i][0]=0;
          }
        }
        
    }
};


Time Complexity : O(M×N)
Space Complexity : O(1)

/////////////////////////////////////////////////////////////////////////////////////////////////

Pascal Triangle 

Input: 5
Output:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
------------------------------------

class Solution {
public:
    vector<vector<int>> generate(int numRows) {
      int n=numRows;
      vector<vector<int>>a(n);
      
      for(int i=0;i<n;i++)
      {
        a[i].resize(i+1);
        a[i][0]=a[i][i]=1;
        
        for(int j=1;j<i;j++)
        {
          a[i][j]=a[i-1][j-1]+a[i-1][j];
        }
      }
        
      return a;
    }
};

TIME : O(N^2)
SPACE: O(N^2)
/////////////////////////////////////////////////////////////////////////////////////////

Pascal's Triangle II

Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal's triangle.
Note that the row index starts from 0.
Could you optimize your algorithm to use only O(k) extra space?

Example:
Input: 3
Output: [1,3,3,1]
------------------------------
class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<int> A(rowIndex+1, 0);
        A[0] = 1;
        for(int i=1; i<rowIndex+1; i++)
            for(int j=i; j>=1; j--)
                A[j] += A[j-1];
        return A;
    }
};
SPACE:O(k)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Next Permutation 
-------------------------------


class Solution {
public:
    void nextPermutation(vector<int>& nums) {
    
      next_permutation(nums.begin(),nums.end());
      
    }
};

ALTERNATIVE  (FULL CODE):

void swap(vector<int>&nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

void reverse( vector<int>&nums, int start) {
        int i = start, j = nums.size() - 1;
        while (i < j) {
            swap(nums, i, j);
            i++;
            j--;
        }
    }

class Solution {
public:
    void nextPermutation(vector<int>& nums) {
            int i = nums.size() - 2;
        while (i >= 0 && nums[i + 1] <= nums[i]) {
            i--;
        }
        if (i >= 0) {
            int j = nums.size() - 1;
            while (j >= 0 && nums[j] <= nums[i]) {
                j--;
            }
            swap(nums, i, j);
        }
        reverse(nums, i + 1);
    
    }
};
////////////////////////////////////////////////////////////////////////////////////////////////////

  Rotate Image  
     OR
 Rotate Matrix  



Example 1:
Given input matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

rotate the input matrix in-place such that it becomes:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]


Example 2:
Given input matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

rotate the input matrix in-place such that it becomes:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
-----------------------------------------------------------------

class Solution {
public:
    void rotate(vector<vector<int>>& v) {
        int n=v.size(),m=v[0].size();
        vector<vector<int>>a(n,vector<int>(m,0));
        
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<m;j++)
            {
                a[j][m-1-i]=v[i][j];
            }
        }
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<m;j++)
            {
                v[i][j]=a[i][j];
            }
        }
        
    }
};

TIME: O(N^2)
SPACE: O(N^2)


ALTERNATIVE SOLUTION (optimised (in terms of space, time is same in both))


class Solution {
public:
    void rotate(vector<vector<int>>& v) {
        int n=v.size();
        
        for(int i=0;i<n;i++)      //transpose
        {
            for(int j=i;j<n;j++)
            {
              int temp=v[i][j];
              v[i][j]=v[j][i];
              v[j][i]=temp;
            }
        }
        
        for(int i=0;i<n;i++)            //swap elements of each row (automatically the coloumns will reverse)
        {
          for(int j=0;j<(n/2);j++)
          {
              int temp=v[i][j];
              v[i][j]=v[i][n-1-j];
              v[i][n-1-j]=temp;
          }
        }
    }
};


TIME: O(N^2)
SPACE: O(N^2)
////////////////////////////////////////////////////////////////////////////////////////////////////


  Lexicographically next permutation in C++ (GFG)
------------------------------------------------------

  // Find the next lexicographically 
// greater permutation of a word 

#include <algorithm> 
#include <iostream> 

using namespace std; 

int main() 
{ 
	string s = { "gfg" }; 
	bool val 
		= next_permutation(s.begin(), 
						s.end()); 
	if (val == false) 
		cout << "No Word Possible"
			<< endl; 
	else
		cout << s << endl; 
	return 0; 
} 

ALTERNATIVE SOLUTION:

#include <iostream> 

using namespace std; 

void swap(char* a, char* b) 
{ 
	if (*a == *b) 
		return; 
	*a ^= *b; 
	*b ^= *a; 
	*a ^= *b; 
} 
void rev(string& s, int l, int r) 
{ 
	while (l < r) 
		swap(&s[l++], &s[r--]); 
} 

int bsearch(string& s, int l, int r, int key) 
{ 
	int index = -1; 
	while (l <= r) { 
		int mid = l + (r - l) / 2; 
		if (s[mid] <= key) 
			r = mid - 1; 
		else { 
			l = mid + 1; 
			if (index == -1 || s[index] >= s[mid]) 
				index = mid; 
		} 
	} 
	return index; 
} 

bool nextpermutation(string& s) 
{ 
	int len = s.length(), i = len - 2; 
	while (i >= 0 && s[i] >= s[i + 1]) 
		--i; 
	if (i < 0) 
		return false; 
	else { 
		int index = bsearch(s, i + 1, len - 1, s[i]); 
		swap(&s[i], &s[index]); 
		rev(s, i + 1, len - 1); 
		return true; 
	} 
} 

int main() 
{ 
	string s = { "gfg" }; 
	bool val = nextpermutation(s); 
	if (val == false) 
		cout << "No Word Possible" << endl; 
	else
		cout << s << endl; 
	return 0; 
} 

   output: ggf

   TIME : O(logN) 
   SPACE: O(N)
/////////////////////////////////////////////////////////////////////////////////////////////////////////


Reverse a LinkedList   (RECURSIVE AND ITERATIVE APPROACH)

Input: 1->2->3->4->5->NULL
Output: 5->4->3->2->1->NULL
-------------------------------------------- 

 class Solution {
public:
    ListNode* reverseList(ListNode* head) 
    {
      
    if(!head || !head->next) return head;
    ListNode* p = reverseList(head->next);
    head->next->next = head;
    head->next = nullptr;
    return p;
    }
};

 TIME and SPACE : O(N) AND O(N)
...................
ALTERNATIVE SOLUTION

class Solution {
public:
    ListNode* reverseList(ListNode* head) 
    {
        ListNode * c,*p,*n;
 
  c=head;
  p=NULL;

  while(c!=NULL)
  {
  // save the next node
   n=c->next;
   //make the current node next to prev
   c->next=p;
    //just update prev and current
   p=c;
   c=n;
  }
  head=p;
        
        return head;
    }
};

TIME and SPACE : O(N) AND O(1)

/////////////////////////////////////////////////////////////////////////////////////////

  Middle of the Linked List

  Example 1:
Input: [1,2,3,4,5]
Output: Node 3 from this list (Serialization: [3,4,5])
The returned node has value 3.  (The judge's serialization of this node is [3,4,5]).
Note that we returned a ListNode object ans, such that:
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.

Example 2:
Input: [1,2,3,4,5,6]
Output: Node 4 from this list (Serialization: [4,5,6])
Since the list has two middle nodes with values 3 and 4, we return the second one.

-----------------------------------------
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        vector<ListNode*> A = {head};
        while (A.back()->next != NULL)
            A.push_back(A.back()->next);
        return A[A.size() / 2];
    }
};
  TIME AND SPACE: O(N) and O(1).

 ALTERNATIVE SOLUTION :

   class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode* sp=head, *fp=head;
      
        while(fp!=NULL &&fp->next!=NULL)
        {
          sp=sp->next;
          fp=fp->next->next;
        }
        
      return sp;
    }
};

TIME AND SPACE: O(N) and O(1).
//////////////////////////////////////////////////////////////////////////////////////////////////////////

 Merge Two Sorted Lists

 Input: 1->2->4, 1->3->4
Output: 1->1->2->3->4->4
-----------------------------

class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
         if(!l1) return l2;
         if(!l2) return l1;
      
        ListNode* c;
      
       if(l1->val>l2->val)
       {
         c=l2;
         c->next=mergeTwoLists(l1,l2->next);
       }
        else
       {
         c=l1;
         c->next=mergeTwoLists(l1->next,l2);
       }
      
      return c;
    }
};

TIME : O(N*M)
//////////////////////////////////////////////////////////////////////////////////////////////

  Remove Nth Node From End of List


Example:
Given linked list: 1->2->3->4->5, and n = 2.
After removing the second node from the end, the linked list becomes 1->2->3->5.


--------------------------------------------------------
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n)
    {
    if(!head || !head->next)  return NULL;
              
        auto s=head;
        auto f=head;
        
        int i=0;
        while(f->next!=NULL && i!=n){
                f=f->next;
                i++;
        }
        if(i!=n){
            head=head->next;
            return head;
        }
        while(f->next!=NULL){
            s=s->next;
            f=f->next;
        }
        s->next=s->next->next;
        return head;
    }
};

TIME AND SPACE: O(N) and O(1).
////////////////////////////////////////////////////////////////////////////////////////////////////

  Delete Node in a Linked List

  Input: head = [4,5,1,9], node = 5
Output: [4,1,9]
Explanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function

------------------------------------------------------------------------------------

class Solution {
public:
    void deleteNode(ListNode* node) {
      node->val=node->next->val;
      node->next=node->next->next;
    }
};

Time and space complexity are both O(1).


ALTERNATIVE SOLUTION: 

class Solution {
public:
    void deleteNode(ListNode* node)
    {
        ListNode* temp;
        temp=node->next;
        node->val=node->next->val;
        node->next=node->next->next;
  
    }
};
/////////////////////////////////////////////////////////////////////////////////////////////////

  Add Two Numbers

  Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 0 -> 8
Explanation: 342 + 465 = 807.
--------------------------------------------------

  
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        if (l1 == NULL and l2 == NULL) return NULL;
			else if (l1 == NULL) return l2; 
			else if (l2 == NULL) return l1; 

			int a = l1->val + l2->val;
			ListNode *p = new ListNode(a % 10);
			p->next = addTwoNumbers(l1->next,l2->next);
			if (a >= 10) p->next = addTwoNumbers(p->next, new ListNode(1));
			return p;
    }
};


ALTERNATIVE SOLUTION


class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
         ListNode* dummyHead = new ListNode(0);
    ListNode* p = l1; ListNode* q = l2; ListNode* curr = dummyHead;
    int carry = 0;
    while (p != nullptr || q != nullptr) {
        int x = (p != nullptr) ? p->val : 0;
        int y = (q != nullptr) ? q->val : 0;
        int sum = carry + x + y;
        carry = sum / 10;
        curr->next = new ListNode(sum % 10);
        curr = curr->next;
        if (p != nullptr) p = p->next;
        if (q != nullptr) q = q->next;
    }
    if (carry > 0) 
    {
        curr->next = new ListNode(carry);
    }
    return dummyHead->next;
    }
};

time and space : O(max(m,n)).
//////////////////////////////////////////////////////////////////////////////////////////////////////

Find intersection point of Y LinkedList 


Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
Output: Reference of the node with value = 8
Input Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.
-------------------------------------------------
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        
      ListNode* aptr,*bptr;
      aptr=headA, bptr=headB;
      
      while(bptr!=aptr)
      {
        if(aptr==NULL) aptr=headB;
        else aptr=aptr->next;
        
        if(bptr==NULL) bptr=headA;
        else bptr=bptr->next;
      }
      
      return bptr;
      
    }
};

Time complexity : O(m+n)
Space complexity : O(1).
/////////////////////////////////////////////////////////////////////////////////////////////////////

   Palindrome Linked List

Example 1:

Input: 1->2
Output: false
Example 2:

Input: 1->2->2->1
Output: true
------------------------------

class Solution {
public:
    bool isPalindrome(ListNode* head) {
      
      ListNode* sp=head,*fp=head,*mid=NULL;
       
      while(fp!=NULL && fp->next!=NULL)
      {
        sp=sp->next;
        fp=fp->next->next;
      }
      
     ListNode* p=NULL, *n;
      while(sp!=NULL)
      {
        n=sp->next;
        sp->next=p;
        p=sp;
        sp=n;
      }
      
      while(p!=NULL)
      {
        if(head->val!=p->val)
        return false;
        
        head=head->next;
        p=p->next;
      }

       return true;
    }
};
//////////////////////////////////////////////////////////////////////////////////////

Reverse a LinkedList in groups. 
            OR
Reverse Nodes in k-Group

Example:
Given this linked list: 1->2->3->4->5
For k = 2, you should return: 2->1->4->3->5
For k = 3, you should return: 3->2->1->4->5
------------------------------------------------------

class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
         ListNode* p=head, *c=head, *n;
      
      int count=0;
      while(p!=NULL && count!=k)
      {
        p=p->next;
        count++;
      }
      if(count==k)
      {
         p=reverseKGroup(p,k);
        while(count>0)
        { 
          // save the next node
          n=c->next;
          //make the current node next to prev
          c->next=p;
          //just update prev and current
          p=c;
          c=n;
           count--;
        }
        head=p;  
      }
      return head;
    }
};
/////////////////////////////////////////////////////////////////////////////////////////

    Rotate List

Example 1:
Input: 1->2->3->4->5->NULL, k = 2
Output: 4->5->1->2->3->NULL
Explanation:
rotate 1 steps to the right: 5->1->2->3->4->NULL
rotate 2 steps to the right: 4->5->1->2->3->NULL

Example 2:
Input: 0->1->2->NULL, k = 4
Output: 2->0->1->NULL
Explanation:
rotate 1 steps to the right: 2->0->1->NULL
rotate 2 steps to the right: 1->2->0->NULL
rotate 3 steps to the right: 0->1->2->NULL
rotate 4 steps to the right: 2->0->1->NULL
--------------------------------------------------------

class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        
      if(!head || !head->next || k==0) return head;
      
      int len=1;
      auto f=head;
      while(f->next)
      {
        f=f->next;
        len++;
      }
      
      k=k%len;
      f->next=head;
      
      for(int i=0;i<(len-k);i++)
      {
        f=f->next;
      }
      
      head=f->next;
      f->next=NULL;
      return head;
    }
};
////////////////////////////////////////////////////////////////////////////////////////////////////

Linked List Cycle

 Example 1:

Input: head = [3,2,0,-4], pos = 1
Output: true
Explanation: There is a cycle in the linked list, where tail connects to the second node.

Example 2:

Input: head = [1,2], pos = 0
Output: true
Explanation: There is a cycle in the linked list, where tail connects to the first node.

Example 3:

Input: head = [1], pos = -1
Output: false
Explanation: There is no cycle in the linked list.
-----------------------------------------------------------------

class Solution {
public:
    bool hasCycle(ListNode *head) {
      
      if(!head || !head->next) return 0;
      
      auto s=head, f=head;
      
  
        while(f && f->next)
      {    
        s=s->next;
        f=f->next->next;
         if(f==s)return 1;
      }
      return 0;
    }
};

O(N) AND O(1)
///////////////////////////////////////////////////////////////////////////////////////////////////////

  Linked List Cycle II
         OR
  Find the starting point of the loop. 


  Example 1:
Input: head = [3,2,0,-4], pos = 1
Output: tail connects to node index 1
Explanation: There is a cycle in the linked list, where tail connects to the second node.


Example 2:
Input: head = [1,2], pos = 0
Output: tail connects to node index 0
Explanation: There is a cycle in the linked list, where tail connects to the first node.


Example 3:
Input: head = [1], pos = -1
Output: no cycle
Explanation: There is no cycle in the linked list.
--------------------------------------------------------------

  class Solution {
public:
    ListNode *detectCycle(ListNode *head) {

      auto s=head,f=head;
       while(f && f->next)
       {
         s=s->next; f=f->next->next; if(s==f) break;
       }
      
       if(!f || !f->next) return NULL;
      
       s=head;
      
       while(s!=f)
       {
         s=s->next;
         f=f->next;
       }
      return s;
    }
};
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

   Remove Linked List Elements

  Input:  1->2->6->3->4->5->6, val = 6
Output: 1->2->3->4->5
------------------------------------------------------------------

class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        if (head == NULL) return NULL;
        head->next = removeElements(head->next, val);
      
       if(head->val==val)
         return head->next;
      else
        return head;
    }
};
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  3Sum
  
Given array nums = [-1, 0, 1, 2, -1, -4],
A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]
---------------------------------------------

class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
      vector<vector<int>> result;
        sort(begin(nums),end(nums));
        for (int i = 0; i < nums.size(); i++) {
            if (i == 0 || nums[i] != nums[i-1]) {
                int start = i + 1, end = nums.size() - 1;
                while (start < end) {
                    int sum = nums[i] + nums[start] + nums[end];
                    if (sum == 0){
                        vector<int> tmp;
                        tmp.push_back(nums[i]);
                        tmp.push_back(nums[start]);
                        tmp.push_back(nums[end]);
                        result.push_back(tmp);
                        int startVal = nums[start];
                        int endVal = nums[end];
                        while (start < end && startVal == nums[start]) {
                            start ++;
                        }
                        while (end > start && endVal == nums[end]) {
                            end --;
                        }
                    }
                    else if (sum < 0) {
                        start ++;
                    }
                    else {
                        end --;
                    }
                }
            }
        }
        return result;
    }
};
.......................................

   ALTERNATE SOLUTION (LEETCODE PAR NHI CHALA BUT INTERVIEWBIT PAR CHAL GYA)

  vector<vector<int>> result;
        if(A.size()<=2)return result;
        sort(A.begin(), A.end());
        for (int i = 0; i < A.size() - 2; i++) {
            long int a = A[i];
            if(a > 0) break;
            if (i > 0 && a == A[i - 1]) continue;
            for (long j = i + 1, k = A.size() - 1; j < k;) {
               long  int b = A[j];
                long int c = A[k];
                long int value = a + b + c;
                if (value == 0)
                {
                    result.push_back({a, b, c});
                    while (j<k && b == A[++j]);
                    while (j < k &&c == A[--k]);
                } else if (value > 0) {
                    k--;
                } else {
                    j++;
                }
            }
        }
        return result;
/////////////////////////////////////////////////////////////////////////////////////

Remove Duplicates from Sorted Array

Given nums = [1,1,2],
Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.

Given nums = [0,0,1,1,1,2,2,3,3,4],
Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.
-----------------------------------------------------------

class Solution {
public:
    int removeDuplicates(vector<int>& a) {
  
       if(!a.size()) return 0;
      int j=0;
      
      for(int i=1;i<a.size();i++)
      {
        if(a[j]!=a[i])
          j++;
        a[j]=a[i];
      }
      return j+1;
      
    }
};
///////////////////////////////////////////////////////////////////////////////////////////////////

Max Consecutive Ones
    OR
Max continuous number of 1’s  

Example 1:
Input: [1,1,0,1,1,1]
Output: 3
Explanation: The first two digits or the last three digits are consecutive 1s.
    The maximum number of consecutive 1s is 3.
-------------------------------------------------------------------------------

class Solution {
public:
    int findMaxConsecutiveOnes(vector<int>& v) {
        int mx=0;
  
        int c=0;
        for(int i=0;i<v.size();i++)
        {
          if(v[i]==1)
          {
            c++;
            mx=max(mx,c);
          }
          else
          {
            c=0;
          }
        }
      return mx;
    }
};
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  Max Consecutive Ones II

  Example 1:

Input: [1,0,1,1,0]
Output: 4
Explanation: Flip the first zero will get the the maximum number of consecutive 1s.
    After flipping, the maximum number of consecutive 1s is 4.
--------------------------------------------------------------------
public class Solution 
{
    public int findMaxConsecutiveOnes(int[] nums)
    {
        int k = 1, low = 0, zeroCount = 0, ret = 0;
        for (int i=0; i<nums.length; i++) {
            if (nums[i] == 0)
            {
                zeroCount++;
            }
            while (zeroCount > k) 
            {
                if (nums[low] == 0)
                {
                    zeroCount--;
                }
                low++;
            }
            ret = Math.max(ret, i - low + 1);
    }
        
        return ret;
    }
}        

 Time: O(n), Space: O(n)
/////////////////////////////////////////////////////////////////////////////////////////////////////

  Max Consecutive Ones III

  Example 1:
Input: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2
Output: 6
Explanation: 
[1,1,1,0,0,1,1,1,1,1,1]
Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.

Example 2:
Input: A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3
Output: 10
Explanation: 
[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.
-----------------------------------------------------------------------

   Max Consecutive Ones III


Given an array A of 0s and 1s, we may change up to K values from 0 to 1.
Return the length of the longest (contiguous) subarray that contains only 1s. 

Example 1:

Input: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2
Output: 6
Explanation: 
[1,1,1,0,0,1,1,1,1,1,1]
Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.
Example 2:

Input: A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3
Output: 10
Explanation: 
[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.
------------------------------------------------------------------------

  class Solution {
public:
    int longestOnes(vector<int>& A, int K) {
         int i = 0, j = 0;
      while (i < A.size()) {
      K = K - ( 1 - A[i++] );
      if (K < 0) K += 1 - A[j++];
     }
      return i - j;
    }
};
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Max Continuous Series of 1s (INTERVIEWBIT)

   Input : 
Array = {1 1 0 1 1 0 0 1 1 1 } 
M = 1

Output : 
[0, 1, 2, 3, 4] 
--------------------------------------------

  vector<int> Solution::maxone(vector<int> &A, int B) {
    int idx = 0, c=0, l=0, maxi = 0;
    int p=0, q=0;
    for(int i=0; i<A.size(); i++)
    {
        if(A[i] == 0)
            c++;
        while(c>B)
        {
            if(A[l] == 0)
                c--;
            l++;
        }
        if(i-l+1>maxi)
        {
            maxi = i-l+1;
            p = l;
            q = i;
        }
    }
    vector<int> res;
    for(int i=p; i<=q; i++)
        res.push_back(i);
    return res;
}
/////////////////////////////////////////////////////////////////////////////////////////////////

 Longest Consecutive Sequence (INTERVIEWBIT)

  Example:
Given [100, 4, 200, 1, 3, 2],
The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.
Your algorithm should run in O(n) complexity.
----------------------------------------------------------

int Solution::longestConsecutive(const vector<int> &A)
 {    
     unordered_set<int> hash;
    for(int i=0;i<A.size();i++)
    {
        hash.insert(A[i]);
    }
    int l=1;
    int maxl=1;
    for(int i=0;i<A.size();i++)
    {
        int j=1;
        l=1;
        if(hash.find(A[i]-1)==hash.end())
        {
            while(hash.find(A[i]+j)!=hash.end())
            {
                j++;
                l++;
            }
            if(l>maxl){
                maxl=l;
            }
        }
    }
    return maxl;
}
/////////////////////////////////////////////////////////////////////////////////////////

  Nth root of a number using log (GFG)
-----------------------------------
#include <bits/stdc++.h> 
using namespace std;
double kthRoot(double n, int k) 
{ 
    return pow(k, 
               (1.0 / k) 
                   * (log(n) 
                      / log(k))); 
} 

int main(void) 
{ 
    double n = 81; 
    int k = 4; 
    printf("%lf ", kthRoot(n, k)); 
    return 0; 
} 

Output:
3.000000

/////////////////////////////////////////////////////////////////////////////////////////////

  Matrix Median 

  Input 1:
    A = [   [1, 3, 5],
            [2, 6, 9],
            [3, 6, 9]   ]
Output 1:  5
Explanation 1:
    A = [1, 2, 3, 3, 5, 6, 6, 9, 9]
    Median is 5. So, we return 5.

Input 2:
    A = [   [5, 17, 100]    ]
Output 2: 17
--------------------------------------------------
  
 int Solution::findMedian(vector<vector<int> > &A) {
      int n = A.size(), m = A[0].size();
    int lo = INT_MAX, hi = INT_MIN;
    for(int i=0; i<n; i++) {
        lo = min(lo, A[i][0]);
        hi = max(hi, A[i][m-1]);
    }
    int mid, res = -1;
    int desiredIndex = (n*m+1)/2;
    int currentIndex;
    while(lo <= hi) {
        mid = lo + (hi-lo)/2;
        
        currentIndex = 0;
        for(int i=0; i<n; i++) {
            currentIndex += upper_bound(A[i].begin(), A[i].end(), mid) - A[i].begin();
        }
        if(currentIndex < desiredIndex) {
            lo = mid+1;
        } else {
            res = mid;
            hi = mid-1;
        }
    }
    return res;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Find Nth positive number whose digital root is X   (GFG)   (samjh nahi aaya)


PROBLEM STATEMENT :  Given a number X ( 1<= X <= 9) and a positive number N, find the Nth positive number whose digital root is X. For example, the digital root of 65 is 2, because 6 + 5 = 11 and 1 + 1 = 2.
.......
Efficient Approach:
We can find digital root of a number K directly using the formula:
digitalRoot(k) = (k - 1)mod 9 +1
From this we can find the N-th number whose digital root is K as,
Nth number = (N - 1)*9 + K
--------------------------------------------------------------------------
#include <bits/stdc++.h> 
using namespace std;   
int findAnswer(int X, int N) 
{ 
    return (N - 1) * 9 + X; 
} 

int main() 
{ 
    int X = 7, N = 43; 
  
    cout << findAnswer(X, N); 
  
    return 0; 
} 

Output:
385
///////////////////////////////////////////////////////////////////////////////////////////////

  Digital Root (repeated digital sum) of the given large integer   (GFG)

 Input : num = "1234"
Output : 1
Explanation : The sum of 1+2+3+4 = 10, 
              digSum(x) == 10
              Hence ans will be 1+0 = 1

Input : num = "5674"
Output : 4 
------------------------------------------------------------

#include <iostream> 
using namespace std; 

string convertToString(int sum) 
{ 
	string str = ""; 
	while (sum) { 
		str = str + (char)((sum % 10) + '0'); 
		sum = sum / 10; 
	}  
	return str; 
} 


string GetIndividulaDigitSum(string str,int len) 
{ 
	int sum = 0; 
	for (int i = 0; i < len; i++)
    { 
		sum = sum + str[i] - '0'; 
	} 
	return convertToString(sum); 
} 

int GetDigitalRoot(string str) 
{  
	if (str.length() == 1) 
    { 
		return str[0] - '0'; 
	} 
	str = GetIndividulaDigitSum(str,str.length()); 
	return GetDigitalRoot(str); 
} 
int main() 
{ 
	string str 
		= "675987890789756545689070986776987"; 

	// Function to print final digit 
	cout << GetDigitalRoot(str); 
} 

output: 5
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

Happy Number (LEETCODE)

Example: 

Input: 19
Output: true
Explanation: 
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
----------------------------------------------------------------

  class Solution {
public:
    bool isHappy(int n) 
    {
     unordered_set<int>mset;
        int sum=0;
        while(sum!=1)
        {
              sum=0;
            while(n)
            {
                sum+=pow(n%10,2);
                n/=10;
            }
            if(mset.count(sum))
                return false;
            else
                mset.insert(sum);
                
            n=sum;
        }
        return true;
    }
};
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 Search a 2D Matrix

 Integers in each row are sorted from left to right.
The first integer of each row is greater than the last integer of the previous row.
..............
Example 1:
Input:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 3
Output: true

Example 2:
Input:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 13
Output: false
--------------------------------------------------------------

class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
   
    if (matrix.size() == 0 || matrix[0].size() == 0)
    {
        return false;
    }

    int low;
    int high;
    for (low = 0, high = matrix.size() - 1; low <= high;)
    {
        int middle = (low + high) / 2;
        if (matrix[middle][0] < target)
        {
            low = middle + 1;
        }
        else if (matrix[middle][0] > target)
        {
            high = middle - 1;
        }
        else
        {
            return true;
        }
    }

    int row = high;
    if (row >= 0)
    {
        for (low = 0, high = matrix[row].size() - 1; low <= high;)
        {
            int middle = (low + high) / 2;
            if (matrix[row][middle] < target)
            {
                low = middle + 1;
            }
            else if (matrix[row][middle] > target)
            {
                high = middle - 1;
            }
            else
            {
                return true;
            }
        }
    }

    return false;
    }
};
//////////////////////////////////////////////////////////////////////////////////////////////

 Single Element in a Sorted Array(LEETCODE)
      OR
  Find the element that appears once in sorted array, and rest element appears twice

Example 1:
Input: nums = [1,1,2,3,3,4,4,8,8]
Output: 2

Example 2:
Input: nums = [3,3,7,7,10,11,11]
Output: 10

Follow up: Your solution should run in O(log n) time and O(1) space.
----------------------------------------------------------------------

  class Solution {
public:
    int singleNonDuplicate(vector<int>& nums) {
       
        ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
        
        int start=0, end = nums.size()-1, mid;
        
        if(end==0)                                      //  boundary conditions
          return nums[0];
        else if(nums[0]!=nums[1])
            return nums[0];
        else if(nums[end]!=nums[end-1])
            return nums[end];
                


	while( start < end ) {
		mid = start + (end-start)/2;
		if( nums[mid] == nums[mid ^ 1] )                //if((mid % 2 == 0 && nums[mid] == nums[mid + 1]) || (mid % 2 == 1 && nums[mid] == nums[mid - 1]))
	
            start = mid + 1;
		else
			end = mid;
	}
	return nums[start];
    }
};
/////////////////////////////////////////////////////////////////////////////////////////////////////

 Search in Rotated Sorted Array  (LEETCODE)


Example 1:

Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
Example 2:

Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1

//there are no duplicates in the array
----------------------------------------------------------


class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n=nums.size();
        if(n==0)
            return -1;
        int i=0;
        int j=n-1;
        int m;
        while(i<=j)
        {
            m=(i+j)/2;
            if(nums[m]==target)
                return m;
            else if(nums[0]<=nums[m])
            {
                if(target>=nums[0]&&target<=nums[m])
                    j=m-1;
                else
                    i=m+1;
            }
            else
            {
                if(target>=nums[m]&&target<=nums[n-1])
                    i=m+1;
                else
                    j=m-1;
            }
        }
        return -1;
    }
};
/////////////////////////////////////////////////////////////////////////////////////////////////

Search in Rotated Sorted Array II

Example 1:

Input: nums = [2,5,6,0,0,1,2], target = 0
Output: true
Example 2:

Input: nums = [2,5,6,0,0,1,2], target = 3
Output: false

//duplicates are there
-------------------------------------------------------------

 class Solution {
public:
    bool search(vector<int>& nums, int target) {
         int l = 0, r = nums.size() - 1;        
        while(l <= r){  
            int mid = l + (r - l) / 2;            
            if(nums[mid] == target) return true;
            if(nums[mid] > nums[r]){
                if(target > nums[mid] || target <= nums[r]) l = mid + 1;    
                else r = mid - 1;                                                               
            }else if(nums[mid] == nums[r]){
                r --;  
            }
            else{
                if(target <= nums[r] && target > nums[mid]) l = mid + 1; 
                else r = mid - 1;                                                               
            }
        }
        return false;      
    }
};
///////////////////////////////////////////////////////////////////////////////////////////////

Kth Largest Element of Two Sorted Arrays

Example 1:

Input: nums1 = [-2, -1, 3, 5, 6, 8], nums2 = [0, 1, 2, 5, 9], k = 4
Output: 5
Explanation: Union of above arrays will be [-2, -1, 0, 1, 2, 3, 5, 5, 6, 8, 9] and the 4th largest element is 5.
Example 2:

Input: nums1 = [2, 4], nums2 = [6], k = 1
Output: 6
Explanation: union of above arrays will be [2, 4, 6] and the 1st largest element is 6.

Follow-up
Can you do it in O(logk) time?
----------------------------------------------------------------------











///////////////////////////////////////////////////////////////////////////////////////////////////////

   Median of Two Sorted Arrays (LEETCODE)
            OR
  Media of an array     

Example 1:

nums1 = [1, 3]
nums2 = [2]

The median is 2.0
Example 2:

nums1 = [1, 2]
nums2 = [3, 4]

The median is (2 + 3)/2 = 2.5
-------------------------------------------

  class Solution {
public:
    double findMedianSortedArrays(vector<int>& A, vector<int>& B) {
 int m = nums1.size(), n = nums2.size(), l = 0, r = m;
    if (m > n) {
        return findMedianSortedArrays(nums2, nums1);
    }
    while (l <= r) {
        int i = (l + r) / 2, j = (m + n + 1) / 2 - i;
        if (i && nums1[i - 1] > nums2[j]) {
            r = i - 1;
        } else if (i < m && nums2[j - 1] > nums1[i]) {
            l = i + 1;
        } else {
            int lmax = !i ? nums2[j - 1] : (!j ? nums1[i - 1] : max(nums1[i - 1], nums2[j - 1]));
            if ((m + n) % 2) {
                return lmax;
            }
            int rmin = i == m ? nums2[j] : (j == n ? nums1[i] : min(nums1[i], nums2[j]));
            return 0.5 * (lmax + rmin);
        }
    }
    return 0.0;
    }
};

TIME : O(log(min(m,n)))
At first, the searching range is [0,m]. And the length of this searching range will be reduced by half after each loop. So, we only need log(m) loops. Since we do constant operations in each loop, so the time complexity is O(log(m)).  Since m≤n, so the time complexity is O(log(min(m,n))).

SPACE : We only need constant memory to store 9 local variables, so the space complexity is O(1).
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Day of the Week


Example 1:
Input: day = 31, month = 8, year = 2019
Output: "Saturday"

Example 2:
Input: day = 18, month = 7, year = 1999
Output: "Sunday"

Example 3:
Input: day = 15, month = 8, year = 1993
Output: "Sunday"

-------------------------------------------

  class Solution {
public:
    string dayOfTheWeek(int day, int month, int year) {
                string daysInWeek [7] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}; // 1
        int DaysByMonthMod7[12] = {0,3,2,5,0,3,5,1,4,6,2,4}; // 2
        if(month < 3) year -= 1; // 3
        return daysInWeek[(year + (year/4 - year/100 + year/400) + DaysByMonthMod7[month-1] + day) % 7]; // 4
 
    }
};
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 Kth Smallest Element in a Sorted Matrix

Example:

matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

return 13.
---------------------------------------------------

class Solution {
public:
    int kthSmallest(vector<vector<int>>& A, int B) {
         int n = A.size(), l=A[0][0], r=A[n-1][n-1];
        while(l<r)
        {
            int mn = 0, m = l+((r-l)/2);
            for(int i = 0; i < n; i++) 
                mn+=upper_bound(A[i].begin(), A[i].end(), m)-A[i].begin();
              if(mn<B)
              {
                l=m+1;
              }
              else
              {
                  r=m;
              }
        }
        return r;
    }
};


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


  Matrix Median


  Input 1:
    A = [   [1, 3, 5],
            [2, 6, 9],
            [3, 6, 9]   ]
Output 1:  5
Explanation 1:
    A = [1, 2, 3, 3, 5, 6, 6, 9, 9]
    Median is 5. So, we return 5.

Input 2:
    A = [   [5, 17, 100]    ]
Output 2: 17
--------------------------------------------------
  
 int Solution::findMedian(vector<vector<int> > &A) {
      int n = A.size(), m = A[0].size();
    int lo = INT_MAX, hi = INT_MIN;
    for(int i=0; i<n; i++) {
        lo = min(lo, A[i][0]);
        hi = max(hi, A[i][m-1]);
    }
    int mid, res = -1;
    int desiredIndex = (n*m+1)/2;
    int currentIndex;
    while(lo <= hi) {
        mid = lo + (hi-lo)/2;
        
        currentIndex = 0;
        for(int i=0; i<n; i++) {
            currentIndex += upper_bound(A[i].begin(), A[i].end(), mid) - A[i].begin();
        }
        if(currentIndex < desiredIndex) {
            lo = mid+1;
        } else {
            res = mid;
            hi = mid-1;
        }
    }
    return res;
}

We can use binary search on answer. In O(N log M), we can count how many elements are smaller than X in the matrix.
So, we use binary search on interval [1, INT_MAX]. So, total complexity is O(30 * N log M).
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  Check if a number if a power of 2 or not in O(1)      

 class Solution {
public:
    bool isPowerOfTwo(int n) {
    if(n<=0)return 0;
      return !(n&(n-1));
    }
};


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Given a HUGE number check if it’s a power of two.
          OR
 Check if a number if a power of 2 (FOR LARGE NUMBERS)     


EXAMPLE:

Input : 3 
Output : 0
2^0 = 1 where as k >= 1

Input : 128
Output : 1 
--------------------------------------------------------------
#include<bits/stdc++.h>
#define int long long 
using namespace std;


int real(string A)
{
    int N=10*(A[0]-'0')+A[1]-'0';
    return N/2;
}
int carry(string A)
{
    int N=10*(A[0]-'0')+A[1]-'0';
    return N%2;
}

int power(string A)
{
    int N=A.size();
    if(N==1)
    {
        if(A[0]=='2'||A[0]=='4'||A[0]=='8') return 1;
        else return 0;
    }
    if((A[N-1]-'0')%2==1) return 0;
    string ans="";
    A="0"+A;
    for(int i=1;i<N+1;i++){
        if(i==1&&A[i-1]=='0'&&(A[i]=='0'||A[i]=='1')) continue;
        string xx="";
        xx+=A[i-1];
        xx+=A[i];
        ans+=real(xx)+'0';
        A[i]=carry(xx)+'0';
    }
    return power(ans);
}

signed main() 
{ 
    string str;
    cin>>str;
    cout<<power(str);
    return 0; 
} 
///////////////////////////////////////////////////////////////////////////////////////////

Counting Bits

Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array.

Example 1:

Input: 2
Output: [0,1,1]
Example 2:

Input: 5
Output: [0,1,1,2,1,2]
----------------------------------------------------

class Solution {
public:
    vector<int> countBits(int num) {
        vector<int> ret(num+1, 0);
        for (int i = 1; i <= num; ++i)
            ret[i] = ret[i&(i-1)] + 1;
        return ret;
    }
};

TIME : O(N) and SPACE : O(N).
////////////////////////////////////////////////////////////////////////////////////////////////////////

Number of 1 Bits



Example 1:
Input: 00000000000000000000000000001011
Output: 3
Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.

Example 2:
Input: 00000000000000000000000010000000
Output: 1
Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit.

Example 3:
Input: 11111111111111111111111111111101
Output: 31
Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits.

----------------------------------------------------------
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int x=__builtin_popcount(n);
        return x;
    }
};

The run time depends on the number of bits in n. Because n in this piece of code is a 32-bit integer, the time complexity is O(1).
The space complexity is O(1), since no additional space is allocated.


ALTERNATE SOLUTION

class Solution {
public:
    int hammingWeight(uint32_t n) {
        int x=0;
      
        while(n)
        {
          n=n&(n-1);
          x++;
        }
        return x;
    }
};

The run time depends on the number of 1-bits in n. In the worst case, all bits in n are 11-bits. In case of a 32-bit integer, the run time is O(1).
The space complexity is O(1), since no additional space is allocated.
//////////////////////////////////////////////////////////////////////////////////////////////////////////

Divide Two Integers
    OR
Divide Integers without / operator



Example 1:
Input: dividend = 10, divisor = 3
Output: 3
Explanation: 10/3 = truncate(3.33333..) = 3.

Example 2:
Input: dividend = 7, divisor = -3
Output: -2
Explanation: 7/-3 = truncate(-2.33333..) = -2.
--------------------------------------------------------

class Solution {
public:
    int divide(int dividend, int divisor) {
      long long sign;
      
      if((dividend<0)^(divisor<0))
         sign =-1;
       else
         sign=1;
      
       long long dvd=dividend;
       long long dvs=divisor;
      
       if(dvd==INT_MIN && dvs==-1)
         return INT_MAX;
      
       dvd=abs(dvd);
       dvs=abs(dvs);
       
      long long res=0;
      
      for(int i=31;i>=0;i--)
      {
        if(dvd>=(dvs<<i))
        {
          dvd-=(dvs<<i);
          res+=(1<<i);    
        }
      }
       return sign*res;
    }
};

//////////////////////////////////////////////////////////////////////////////////

  Subsets  (LEETCODE)
     OR
Power Set (this is very important)

PROBLEM STATEMENT: Given a set of distinct integers, nums, return all possible subsets (the power set).
Note: The solution set must not contain duplicate subsets.

Example:
Input: nums = [1,2,3]
Output:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
-----------------------------------------

class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
       int n = nums.size(), p = 1 << n;
        vector<vector<int>> subs(p);
        for (int i = 0; i < p; i++) {
            for (int j = 0; j < n; j++) {
                if ((i >> j) & 1) {
                    subs[i].push_back(nums[j]);
                }
            }
        }
        return subs;
    }
};

Time complexity: O(N * 2^N) to generate all subsets and then copy them into output list.
Space complexity: O(N* 2^N) to keep all the subsets of length N, since each of N elements could be present or absent.
//////////////////////////////////////////////////////////////////////////////////////////////

   Subsets II  (LEETCODE)

PROBLEM STATEMENT: Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).
Note: The solution set must not contain duplicate subsets.

Example:

Input: [1,2,2]
Output:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
---------------------------------------------------------------

  class Solution {
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        vector<vector<int>> dp;
        
        sort(nums.begin(), nums.end());

        dp.push_back({});

        for (auto i = 0; i < nums.size(); i++) {
            auto size = dp.size();

            for (auto j = 0; j < size; j++) {
                auto v = dp[j];
                bool found = false;

                v.push_back(nums[i]);
                for (auto k = 0; k < dp.size(); k++)
                    if (v == dp[k]) {
                        found = true;
                        break;
                    }

                if (!found)
                    dp.push_back(v);
            }
        }
        return dp;
    }
};
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Find most significant set bit of a number

Examples:

Input : 10
Output : 8
Binary representation of 10 is 1010
The most significant bit corresponds
to decimal number 8.

Input : 18
Output : 16

----------------------------------------------------------------
#include <iostream> 
using namespace std; 

int setBitNumber(int n) 
{ 
   
    n |= n >> 1; 
    n |= n >> 2; 
    n |= n >> 4; 
    n |= n >> 8; 
    n |= n >> 16; 
    n = n + 1; 
    return (n >> 1); 
} 

int main() 
{ 
    int n = 273; 
    cout << setBitNumber(n); 
    return 0; 
} 

OUTPUT: 256
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

 Find square of a number without using multiplication or division operators.

---------------------------------------------------------------------------------

SOLUTION 1 : (ADD ODD (INTUITIVE))

#include <iostream>
using namespace std;

int findSquare(int num)
{
	int odd = 1;
	int sq = 0;

	// convert number to positive if it is negative
	num = abs(num);

	// add odd numbers num times to result
	while (num--)
	{
		sq = sq + odd;
		odd = odd + 2;
	}

	return sq;
}

int main()
{
	cout << findSquare(8) << " " << findSquare(-4);

	return 0;
}

ALTERNATE SOLUTION : (USING BITMASKING)

  #include <iostream>
using namespace std;

int findSquare(int num)
{
	// base case
	if (num < 2)
		return num;

	// convert number to positive if it is negative
	num = abs(num);

	// drop last bit from num (divide it by 2)
	int i = num >> 1;

	// if num is odd
	if (num & 1)
		return ((findSquare(i) << 2) + (i << 2) + 1);

	// if num is even
	else
		return (findSquare(i) << 2);
}

int main()
{
	cout << findSquare(8);

	return 0;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

Implement Stack using array

---------------------------------

#include <iostream>
using namespace std;
#define MAX_SIZE 101 

class Stack
{
private:
  int A[MAX_SIZE];  // array to store the stack
    int top;   // variable to mark the top index of stack. 
public:
    // constructor
    Stack()
    {
        top = -1; // for empty array, set top = -1
    }

    // Push operation to insert an element on top of stack. 
    void Push(int x) 
    {
      if(top == MAX_SIZE -1) { // overflow case. 
            printf("Error: stack overflow\n");
            return;
        }
        A[++top] = x;
    }
 
    // Pop operation to remove an element from top of stack.
    void Pop() 
    {
        if(top == -1) { // If stack is empty, pop should throw error. 
            printf("Error: No element to pop\n");
            return;
        }
        top--;
    }
 
    // Top operation to return element at top of stack. 
    int Top() 
    {
        return A[top];
    }
 
    // This function will return 1 (true) if stack is empty, 0 (false) otherwise
    int IsEmpty()
    {
        if(top == -1) return 1;
        return 0;
    }

    // ONLY FOR TESTING - NOT A VALID OPERATION WITH STACK 
    // This function is just to test the implementation of stack. 
    // This will print all the elements in the stack at any stage. 
    void Print() {
        int i;
        printf("Stack: ");
        for(i = 0;i<=top;i++)
            printf("%d ",A[i]);
        printf("\n");
    }
};

int main()
{
    // Code to test the implementation. 
    // calling Print() after each push or pop to see the state of stack. 
    Stack S;
    S.Push(2);S.Print();
    S.Push(5);S.Print();
    S.Push(10);S.Print();
    S.Pop();S.Print();
    S.Push(12);S.Print();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Implement Stack using linked list

..........................................

#include <iostream>
using namespace std;
#define MAX_SIZE 101 

struct node
{
    int data;
    struct node *next;
};
typedef struct node node;

node *top;

void initialize()
{
    top = NULL;
}

void push(int value)
{
    node *tmp;
    tmp = malloc(sizeof(node));
    tmp -> data = value;
    tmp -> next = top;
    top = tmp;
}

int pop()
{
    node *tmp;
    int n;
    tmp = top;
    n = tmp->data;
    top = top->next;
    free(tmp);
    return n;
}

int Top()
{
    return top->data;
}

int isempty()
{
    return top==NULL;
}

void display(node *head)
{
    if(head == NULL)
    {
        printf("NULL\n");
    }
    else
    {
        printf("%d\n", head -> data);
        display(head->next);
    }
}

int main()
{
    initialize();
    push(10);
    push(20);
    push(30);
    printf("The top is %d\n",Top());
    pop();
    printf("The top after pop is %d\n",Top());
    display(top);
    return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Implement Stack using Queues

--------------------------------------------------

/* Program to implement a stack 
using two queue */
#include <bits/stdc++.h> 
using namespace std; 

class Stack { 
	queue<int> q1, q2; 
	int curr_size; 

public: 
	Stack() 
	{ 
		curr_size = 0; 
	} 

	void pop() 
	{ 
		if (q1.empty()) 
			return; 

		// Leave one element in q1 and 
		// push others in q2. 
		while (q1.size() != 1) { 
			q2.push(q1.front()); 
			q1.pop(); 
		} 

		// Pop the only left element 
		// from q1 
		q1.pop(); 
		curr_size--; 

		// swap the names of two queues 
		queue<int> q = q1; 
		q1 = q2; 
		q2 = q; 
	} 

	void push(int x) 
	{ 
		q1.push(x); 
		curr_size++; 
	} 

	int top() 
	{ 
		if (q1.empty()) 
			return -1; 

		while (q1.size() != 1) { 
			q2.push(q1.front()); 
			q1.pop(); 
		} 

		// last pushed element 
		int temp = q1.front(); 

		// to empty the auxiliary queue after 
		// last operation 
		q1.pop(); 

		// push last element to q2 
		q2.push(temp); 

		// swap the two queues names 
		queue<int> q = q1; 
		q1 = q2; 
		q2 = q; 
		return temp; 
	} 

	int size() 
	{ 
		return curr_size; 
	} 
}; 

int main() 
{ 
	Stack s; 
	s.push(1); 
	s.push(2); 
	s.push(3); 
	s.push(4); 

	cout << "current size: " << s.size() 
		<< endl; 
	cout << s.top() << endl; 
	s.pop(); 
	cout << s.top() << endl; 
	s.pop(); 
	cout << s.top() << endl; 
	cout << "current size: " << s.size() 
		<< endl; 
	return 0; 
} 

current size: 4
4
3
2
current size: 2


Version A (efficient push):
push:
enqueue in queue1
pop:
while size of queue1 is bigger than 1, pipe dequeued items from queue1 into queue2
dequeue and return the last item of queue1, then switch the names of queue1 and queue2
..................................................
ALTERNATE SOLUTION:

/* Program to implement a stack using 
two queue */
#include <bits/stdc++.h> 

using namespace std; 

class Stack { 
	// Two inbuilt queues 
	queue<int> q1, q2; 

	// To maintain current number of 
	// elements 
	int curr_size; 

public: 
	Stack() 
	{ 
		curr_size = 0; 
	} 

	void push(int x) 
	{ 
		curr_size++; 

		// Push x first in empty q2 
		q2.push(x); 

		// Push all the remaining 
		// elements in q1 to q2. 
		while (!q1.empty()) { 
			q2.push(q1.front()); 
			q1.pop(); 
		} 

		// swap the names of two queues 
		queue<int> q = q1; 
		q1 = q2; 
		q2 = q; 
	} 

	void pop() 
	{ 

		// if no elements are there in q1 
		if (q1.empty()) 
			return; 
		q1.pop(); 
		curr_size--; 
	} 

	int top() 
	{ 
		if (q1.empty()) 
			return -1; 
		return q1.front(); 
	} 

	int size() 
	{ 
		return curr_size; 
	} 
}; 

int main() 
{ 
	Stack s; 
	s.push(1); 
	s.push(2); 
	s.push(3); 

	cout << "current size: " << s.size() 
		<< endl; 
	cout << s.top() << endl; 
	s.pop(); 
	cout << s.top() << endl; 
	s.pop(); 
	cout << s.top() << endl; 

	cout << "current size: " << s.size() 
		<< endl; 
	return 0; 
} 

current size: 3
3
2
1
current size: 1


Version B (efficient pop):
push:
enqueue in queue2
enqueue all items of queue1 in queue2, then switch the names of queue1 and queue2
pop:
deqeue from queue1
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Implement queue using array
---------------------------------------

/* Queue - Circular Array implementation in C++*/
#include<iostream>
using namespace std; 
#define MAX_SIZE 101  //maximum size of the array that will store Queue. 

// Creating a class named Queue.
class Queue
{
private:
	int A[MAX_SIZE];
	int front, rear; 
public:
	// Constructor - set front and rear as -1. 
	// We are assuming that for an empty Queue, both front and rear will be -1.
	Queue()
	{
		front = -1; 
		rear = -1;
	}

	// To check wheter Queue is empty or not
	bool IsEmpty()
	{
		return (front == -1 && rear == -1); 
	}

	// To check whether Queue is full or not
	bool IsFull()
	{
		return (rear+1)%MAX_SIZE == front ? true : false;
	}

	// Inserts an element in queue at rear end
	void Enqueue(int x)
	{
		cout<<"Enqueuing "<<x<<" \n";
		if(IsFull())
		{
			cout<<"Error: Queue is Full\n";
			return;
		}
		if (IsEmpty())
		{ 
			front = rear = 0; 
		}
		else
		{
		    rear = (rear+1)%MAX_SIZE;
		}
		A[rear] = x;
	}

	// Removes an element in Queue from front end. 
	void Dequeue()
	{
		cout<<"Dequeuing \n";
		if(IsEmpty())
		{
			cout<<"Error: Queue is Empty\n";
			return;
		}
		else if(front == rear ) 
		{
			rear = front = -1;
		}
		else
		{
			front = (front+1)%MAX_SIZE;
		}
	}
	// Returns element at front of queue. 
	int Front()
	{
		if(front == -1)
		{
			cout<<"Error: cannot return front from empty queue\n";
			return -1; 
		}
		return A[front];
	}
	/* 
	   Printing the elements in queue from front to rear. 
	   This function is only to test the code. 
	   This is not a standard function for Queue implementation. 
	*/
	void Print()
	{
		// Finding number of elements in queue  
		int count = (rear+MAX_SIZE-front)%MAX_SIZE + 1;
		cout<<"Queue       : ";
		for(int i = 0; i <count; i++)
		{
			int index = (front+i) % MAX_SIZE; // Index of element while travesing circularly from front
			cout<<A[index]<<" ";
		}
		cout<<"\n\n";
	}
};

int main()
{
	/*Driver Code to test the implementation
	  Printing the elements in Queue after each Enqueue or Dequeue 
	*/
   Queue Q; // creating an instance of Queue. 
   Q.Enqueue(2);  Q.Print();  
   Q.Enqueue(4);  Q.Print();  
   Q.Enqueue(6);  Q.Print();
   Q.Dequeue();	  Q.Print();
   Q.Enqueue(8);  Q.Print();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////

Implement queue using Linked list

--------------------------------------------------------

#include<stdio.h>
#include<stdlib.h>

struct Node {
	int data;
	struct Node* next;
};

// Two glboal variables to store address of front and rear nodes. 
struct Node* front = NULL;
struct Node* rear = NULL;

// To Enqueue an integer
void Enqueue(int x) {
	struct Node* temp = 
		(struct Node*)malloc(sizeof(struct Node));
	temp->data =x; 
	temp->next = NULL;
	if(front == NULL && rear == NULL){
		front = rear = temp;
		return;
	}
	rear->next = temp;
	rear = temp;
}

// To Dequeue an integer.
void Dequeue() {
	struct Node* temp = front;
	if(front == NULL) {
		printf("Queue is Empty\n");
		return;
	}
	if(front == rear) {
		front = rear = NULL;
	}
	else {
		front = front->next;
	}
	free(temp);
}

int Front() {
	if(front == NULL) {
		printf("Queue is empty\n");
		return;
	}
	return front->data;
}

void Print() {
	struct Node* temp = front;
	while(temp != NULL) {
		printf("%d ",temp->data);
		temp = temp->next;
	}
	printf("\n");
}

int main(){
	/* Drive code to test the implementation. */
	// Printing elements in Queue after each Enqueue or Dequeue 
	Enqueue(2); Print(); 
	Enqueue(4); Print();
	Enqueue(6); Print();
	Dequeue();  Print();
	Enqueue(8); Print();
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

Implement Queue using Stack

--------------------------------------------------------

USING TWO STACKS

#include <iostream>
#include <stack>
#include <algorithm>
#include <cstdlib>
using namespace std;

// Implement Queue using two stacks
class Queue {
	stack<int> s1, s2;

public:
	// Enqueue an item to the queue
	void enqueue(int data)
	{
		// Push item into the first stack
		s1.push(data);
	}

	// Dequeue an item from the queue
	int dequeue()
	{
		// if both stacks are empty
		if (s1.empty() && s2.empty()) {
			cout << "Underflow!!";
			exit(0);
		}

		// if second stack is empty, move elements from first stack to it
		if (s2.empty()) {
			while (!s1.empty()) {
				s2.push(s1.top());
				s1.pop();
			}
			// or make call to swap(s1, s2)
		}

		// return the top item from the second stack
		int top = s2.top();
		s2.pop();
		return top;
	}
};

int main()
{
	int keys[] = { 1, 2, 3, 4, 5 };
	Queue q;

	// insert above keys
	for (int key : keys) {
		q.enqueue(key);
	}

	cout << q.dequeue() << '\n';	// print 1
	cout << q.dequeue() << '\n';	// print 2

	return 0;
}

.....................................................................
ALTERNATIVE SOLUTION: (IMPLEMENT ONE STACK WITH RECURSIVE CALL STACK)


#include <iostream>
#include <stack>
#include <cstdlib>
using namespace std;

// Implement Queue using single stack
class Queue {
	stack<int> s;

public:
	// Enqueue an item to the queue
	void enqueue(int data)
	{
		// Push item into the first stack
		s.push(data);
	}

	// Dequeue an item from the queue
	int dequeue()
	{
		// if stack is empty
		if (s.empty()) {
			cout << "Underflow!!";
			exit(0);
		}

		// pop an item from the stack
		int top = s.top();
		s.pop();

		// if stack becomes empty, return the popped item
		if (s.empty()) {
			return top;
		}

		// recur
		int item = dequeue();

		// push popped item back to the stack
		s.push(top);

		// return the result of dequeue() call
		return item;
	}
};

int main()
{
	int keys[] = { 1, 2, 3, 4, 5 };
	Queue q;

	// insert above keys into the queue
	for (int key : keys) {
		q.enqueue(key);
	}

	cout << q.dequeue() << '\n';	// print 1
	cout << q.dequeue() << '\n';	// print 2

	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Check for balanced parentheses

---------------------------------------------------------------------

#include<iostream>
#include<stack>
#include<string>
using namespace std;
// Function to check whether two characters are opening 
// and closing of same type. 
bool ArePair(char opening,char closing)
{
	if(opening == '(' && closing == ')') return true;
	else if(opening == '{' && closing == '}') return true;
	else if(opening == '[' && closing == ']') return true;
	return false;
}
bool AreParanthesesBalanced(string exp)
{
	stack<char>  S;
	for(int i =0;i<exp.length();i++)
	{
		if(exp[i] == '(' || exp[i] == '{' || exp[i] == '[')
			S.push(exp[i]);
		else if(exp[i] == ')' || exp[i] == '}' || exp[i] == ']')
		{
			if(S.empty() || !ArePair(S.top(),exp[i]))
				return false;
			else
				S.pop();
		}
	}
	return S.empty() ? true:false;
}

int main()
{
	/*Code to test the function AreParanthesesBalanced*/
	string expression;
	cout<<"Enter an expression:  "; // input expression from STDIN/Console
	cin>>expression;
	if(AreParanthesesBalanced(expression))
		cout<<"Balanced\n";
	else
		cout<<"Not Balanced\n";
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Next Greater Element
--------------------------------------------------------------------------------

#include <bits/stdc++.h> 
using namespace std; 

void printNGE(int arr[], int n) 
{ 
 stack < int > s; 

s.push(arr[0]); 

for (int i = 1; i < n; i++)
 { 

    if (s.empty()) { 
    s.push(arr[i]); 
    continue; 
    } 

    
    while (s.empty() == false && s.top() < arr[i]) 
    {        
        cout << s.top() << " --> " << arr[i] << endl; 
        s.pop(); 
    } 

   
    s.push(arr[i]); 
} 

while (s.empty() == false) 
  { 
    cout << s.top() << " --> " << -1 << endl; 
    s.pop(); 
  } 
} 


int main() { 
int arr[] = {11, 13, 21, 3}; 
int n = sizeof(arr) / sizeof(arr[0]); 
printNGE(arr, n); 
return 0; 
}

TIME : O(N)
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Next Smaller Element
----------------------------------------------------------

#include <bits/stdc++.h> 
using namespace std; 

void printNSE(int arr[], int n) 
{ 
    stack<int> s; 

        s.push(arr[0]); 

    for (int i = 1; i < n; i++)
     { 
        if (s.empty())
        { 
            s.push(arr[i]); 
            continue; 
        } 

       while (s.empty() == false && s.top() > arr[i]) 
        { 
            cout << s.top() << " --> " << arr[i] << endl; 
            s.pop(); 
        } 

        s.push(arr[i]); 
    } 

    while (s.empty() == false) 
    { 
        cout << s.top() << " --> " << -1 << endl; 
        s.pop(); 
    } 
} 

int main() 
{ 
    int arr[] = { 11, 13, 21, 3 }; 
    int n = sizeof(arr) / sizeof(arr[0]); 
    printNSE(arr, n); 
    return 0; 
}

TIME : O(N)

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Reverse Words in a String

Example 1:

Input: "the sky is blue"
Output: "blue is sky the"
Example 2:

Input: "  hello world!  "
Output: "world! hello"
Explanation: Your reversed string should not contain leading or trailing spaces.
Example 3:

Input: "a good   example"
Output: "example good a"
Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.
---------------------------------------------------------------

class Solution {
public:
    string reverseWords(string s) {
          
       int i,start,end,len=0;      
       for(i=0;i<s.size();i++)
      {
        if(s[i]!=' ')
        {
          start=i;
          break;
        }
      }
      
      for(i=s.size()-1;i>=0;i--)
      {
          if(s[i]!=' ')
        {
           end=i;
           break;
        }
      }
      
      
      for(i=start; i<=end; i++)
      {
        if(s[i]==' ' && s[i-1]==' ')
          continue;
        s[len++]=s[i];
      }
      
      
      s.erase(s.begin()+len, s.end());
      
      reverse(s.begin(),s.end());
      
      start=0;
      for(i=0;i<s.size();i++)
      {
        if(s[i]==' ')
        {
          reverse(s.begin()+start, s.begin()+i);
          start=(i+1);
        }
      }
      
      reverse(s.begin()+start, s.end());
      return s;
    }
};
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 Longest Palindrome in a string
       OR
 Longest Palindromic Substring

Example 1:

Input: "babad"
Output: "bab"
Note: "aba" is also a valid answer.
Example 2:

Input: "cbbd"
Output: "bb"
------------------------------------------------------------

APPROACH 1 : ( Brute Force)

The obvious brute force solution is to pick all possible starting and ending positions for a substring, and verify if it is a palindrome.

Complexity Analysis
Time complexity : O(n^3). Assume that nn is the length of the input string, there are a total of (binomial)(n 2) = n(n−1)/2 such substrings (excluding the trivial solution where a character itself is a palindrome). Since verifying each substring takes O(n) time, the run time complexity is O(n^3)
Space complexity : O(1).


..............................................................................

APPROACH 2 : (EXPAND AROUND CENTER)

int expandFromMiddle(string s, int left, int right)
     {
       while(left>=0 && right<s.size() && s[left]==s[right])
       {
         left--;
         right++;
       }
      return right-left-1;
 }

class Solution {
public:
  
    string longestPalindrome(string s) {
      
      if(s.size()<2)return s;
      
      int start=0,end=0;
      for(int i=0;i<s.size();i++)
      {
        int l1=expandFromMiddle(s, i, i);
        int l2=expandFromMiddle(s, i, i+1);
        int l=max(l1,l2);
        if(l>end-start)
        {
          start=i-(l-1)/2;
          end=i+(l/2);
        }
      }
      
      return s.substr(start,end-start+1);
    }
};

Time complexity : O(n^2).Since expanding a palindrome around its center could take O(n) time, the overall complexity is O(n^2).
Space complexity : O(1)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

REVERSE INTEGER


Given a 32-bit signed integer, reverse digits of an integer.

Example 1:
Input: 123
Output: 321
Example 2:

Input: -123
Output: -321
Example 3:

Input: 120
Output: 21

Note:
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.
---------------------------------------------------------------------------

  class Solution {
public:
    int reverse(int x) {
        int rev = 0;
        while (x != 0) {
            int pop = x % 10;
            x /= 10;
            if (rev > INT_MAX/10 || (rev == INT_MAX / 10 && pop > 7)) return 0;
            if (rev < INT_MIN/10 || (rev == INT_MIN / 10 && pop < -8)) return 0;
            rev = rev * 10 + pop;
        }
        return rev;
    }
};

Time Complexity: O(log(x)). There are roughly log(base10)(x) digits in x.
Space Complexity: O(1).
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 create bst
   OR
  Function to create a new Node in heap
  ---------------------------------------------------
  
  BstNode* GetNewNode(int data) {
    BstNode* newNode = new BstNode();
    newNode->data = data;
    newNode->left = newNode->right = NULL;
    return newNode;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Insert into a Binary Search Tree


For example, 

Given the tree:
        4
       / \
      2   7
     / \
    1   3
And the value to insert: 5
You can return this binary search tree:

         4
       /   \
      2     7
     / \   /
    1   3 5
This tree is also valid:

         5
       /   \
      2     7
     / \   
    1   3
         \
          4
------------------------------------------------------------------

class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
    if (root == NULL) {
        return false;
    }
    else if (root->val == val) {
        return true;
    }
    else if (val <= root->val) {
        return searchBST(root->left, val);
    }
    else {
        return searchBST(root->right, val);
    }
    }
};
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 To search an element in BST, returns true if element is found
 ------------------------------------------------------------------------
 
 bool Search(BstNode* root, int data) {
    if (root == NULL) {
        return false;
    }
    else if (root->data == data) {
        return true;
    }
    else if (data <= root->data) {
        return Search(root->left, data);
    }
    else {
        return Search(root->right, data);
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Populating Next Right Pointers in Each Node

PROBLEM STATEMENT : You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.
Initially, all next pointers are set to NULL.

Follow up:
You may only use constant extra space.
Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.
 
Example 1:
Input: root = [1,2,3,4,5,6,7]
Output: [1,#,2,3,#,4,5,6,7,#]
Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.

--------------------------------------------------------------------------------------------------


class Solution {
public:
    Node* connect(Node* root) {
        if(root == nullptr) return root;
        int count = 0;
        queue<Node*> q;
        q.push(root);
        
        while(!q.empty())
        {
            int count = q.size();
            while(count--)
            {
                Node* curr = q.front();
                q.pop();
                  if(count == 0) curr->next = nullptr;
                else
                    curr->next = q.front();
                if(curr->left) q.push(curr->left);
                if(curr->right) q.push(curr->right);
            }
        }
        return root;
    }
};
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


Construct BST from given keys.















////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 Validate Binary Search Tree
     OR
   check is a bt is bst or not leetcode


Example 1:

    2
   / \
  1   3
Input: [2,1,3]
Output: true
Example 2:

    5
   / \
  1   4
     / \
    3   6
Input: [5,1,4,null,null,3,6]
Output: false
Explanation: The root node's value is 5 but its right child's value is 4.
-----------------------------------------------------------------------------------

APPROACH 1: (RECURSION)

class Solution {
  public :
  bool helper(TreeNode* root, long lower, long upper) {
    if (!root) return true;

    return (lower<root->val && root->val<upper && helper(root->left, lower, root->val) && helper(root->right, root->val, upper));
  }

    bool isValidBST(TreeNode* root) {
    return helper(root,LONG_MIN, LONG_MAX);
  }
};

Time complexity : O(N) since we visit each node exactly once.
Space complexity : O(N) since we keep up to the entire tree.
........................................................

APPROACH 2: (ITERATIVE SOLUTION)

class Solution {
public :
  bool isValidBST(TreeNode* root) {
    if (root == NULL) return true;
    stack<TreeNode*> st;
    TreeNode *curr = root;
    TreeNode *prev = NULL;

    while (curr != NULL || !st.empty()) {

      while (curr != NULL) {
        st.push(curr);
        curr = curr->left;
      }
      curr = st.top(); st.pop();
      if (prev != NULL && prev->val >= curr->val) return false;
      prev = curr;
      curr = curr->right;
    }
    return true;
  }
};

Time complexity : O(N) since we visit each node exactly once.
Space complexity : O(N) since we keep up to the entire tree.

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Search in a Binary Search Tree
  OR
Search given Key in BST



INPUT: Given the tree:
        4
       / \
      2   7
     / \
    1   3
And the value to search: 2

 OUTPUT: You should return this subtree:

      2     
     / \   
    1   3
---------------------------------

class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
    while (root != nullptr && root->val != val) 
    {
      if(root->val > val) 
          root=root->left ;
        else
            root=root->right;
    }
    return root;
    }
};

TIME: O(N).
SPACE: O(1).
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Find the closest element in Binary Search Tree  (gfg)

Input  :  k = 4
Output :  4

Input  :  k = 18
Output :  17

Input  :  k = 12
Output :  9
---------------------------------------------------------------------------------

SOLUTION 1: (TIME EFFICIENT)

#include<bits/stdc++.h> 
using namespace std; 

/* A binary tree node has key, pointer to left child 
and a pointer to right child */
struct Node 
{ 
	int key; 
	struct Node* left, *right; 
}; 

/* Utility that allocates a new node with the 
given key and NULL left and right pointers. */
struct Node* newnode(int key) 
{ 
	struct Node* node = new (struct Node); 
	node->key = key; 
	node->left = node->right = NULL; 
	return (node); 
} 

// Function to find node with minimum absolute 
// difference with given K 
// min_diff --> minimum difference till now 
// min_diff_key --> node having minimum absolute 
//				 difference with K 
void maxDiffUtil(struct Node *ptr, int k, int &min_diff, 
									int &min_diff_key) 
{ 
	if (ptr == NULL) 
		return ; 

	// If k itself is present 
	if (ptr->key == k) 
	{ 
		min_diff_key = k; 
		return; 
	} 

	// update min_diff and min_diff_key by checking 
	// current node value 
	if (min_diff > abs(ptr->key - k)) 
	{ 
		min_diff = abs(ptr->key - k); 
		min_diff_key = ptr->key; 
	} 

	// if k is less than ptr->key then move in 
	// left subtree else in right subtree 
	if (k < ptr->key) 
		maxDiffUtil(ptr->left, k, min_diff, min_diff_key); 
	else
		maxDiffUtil(ptr->right, k, min_diff, min_diff_key); 
} 

// Wrapper over maxDiffUtil() 
int maxDiff(Node *root, int k) 
{ 
	// Initialize minimum difference 
	int min_diff = INT_MAX, min_diff_key = -1; 

	// Find value of min_diff_key (Closest key 
	// in tree with k) 
	maxDiffUtil(root, k, min_diff, min_diff_key); 

	return min_diff_key; 
} 

// Driver program to run the case 
int main() 
{ 
	struct Node *root = newnode(9); 
	root->left = newnode(4); 
	root->right = newnode(17); 
	root->left->left = newnode(3); 
	root->left->right = newnode(6); 
	root->left->right->left = newnode(5); 
	root->left->right->right = newnode(7); 
	root->right->right = newnode(22); 
	root->right->right->left = newnode(20); 
	int k = 18; 
	cout << maxDiff(root, k); 
	return 0; 
} 

Time complexity : O(h) where h is height of given Binary Search Tree

............................................

ALTERNATE METHOD : (SPACE EFFICIENT)

// CPP program to find closest value in 
// a Binary Search Tree. 
#include <iostream> 
#include <limits.h> 
using namespace std; 

// Tree Node 
struct Node { 
	int data; 
	Node *left, *right; 
}; 

// Utility function to create a new Node 
Node* newNode(int data) 
{ 
	Node* temp = new Node(); 
	temp->data = data; 
	temp->left = temp->right = NULL; 
	return temp; 
} 

// Function to find the Node closest to the 
// given key in BST using Morris Traversal 
Node* closestNodeUsingMorrisTraversal(Node* root, 
										int key) 
{ 
	int diff = INT_MAX; 
	Node* curr = root; 
	Node* closest; 

	while (curr) { 
		if (curr->left == NULL) { 

			// updating diff if the current diff is 
			// smaller than prev difference 
			if (diff > abs(curr->data - key)) { 
				diff = abs(curr->data - key); 
				closest = curr; 
			} 

			curr = curr->right; 
		} 

		else { 

			// finding the inorder predecessor 
			Node* pre = curr->left; 
			while (pre->right != NULL && 
				pre->right != curr) 
				pre = pre->right; 

			if (pre->right == NULL) { 
				pre->right = curr; 
				curr = curr->left; 
			} 

			// threaded link between curr and 
			// its predecessor already exists 
			else { 
				pre->right = NULL; 

				// if a closer Node found, then update 
				// the diff and set closest to current 
				if (diff > abs(curr->data - key)) { 
					diff = abs(curr->data - key); 
					closest = curr; 
				} 

				// moving to the right child 
				curr = curr->right; 
			} 
		} 
	} 

	return closest; 
} 

// Driver Code 
int main() 
{ 
	/* Constructed binary tree is 
		5 
		/ \ 
	3	 9 
	/ \ / \ 
	1 2 8 12 */
	Node* root = newNode(5); 
	root->left = newNode(3); 
	root->right = newNode(9); 
	root->left->left = newNode(1); 
	root->left->right = newNode(2); 
	root->right->left = newNode(8); 
	root->right->right = newNode(12); 

	cout << closestNodeUsingMorrisTraversal(root, 10)->data; 

	return 0; 
} 

Time Complexity: O(n)
Auxillary Space : O(1)
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


Lowest Common Ancestor of a Binary Search Tree
           OR
Find LCA of two nodes in BST

Example 1:

Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
Output: 6
Explanation: The LCA of nodes 2 and 8 is 6.
Example 2:

Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
Output: 2
Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.
 

Constraints:

All of the nodes' values will be unique.
p and q are different and both values will exist in the BST.
----------------------

SOLUTION 1: (Recursive Approach)

class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
          // Value of current node or parent node.
        int parentVal = root->val;

        // Value of p
        int pVal = p->val;

        // Value of q;
        int qVal = q->val;

        if (pVal > parentVal && qVal > parentVal) {
            // If both p and q are greater than parent
            return lowestCommonAncestor(root->right, p, q);
        } else if (pVal < parentVal && qVal < parentVal) {
            // If both p and q are lesser than parent
            return lowestCommonAncestor(root->left, p, q);
        } else {
            // We have found the split point, i.e. the LCA node.
            return root;
    }
    }
};

Complexity Analysis
Time Complexity: O(N), where N is the number of nodes in the BST. In the worst case we might be visiting all the nodes of the BST.
Space Complexity: O(N). This is because the maximum amount of space utilized by the recursion stack would be N since the height of a skewed BST could be N.
...........

SOLUTION 2: (Iterative Approach)

class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        // Value of p
        int pVal = p->val;

        // Value of q;
        int qVal = q->val;
        
       // Start from the root node of the tree
        TreeNode* node = root;

        // Traverse the tree
        while (node != NULL) {

            // Value of ancestor/parent node.
            int parentVal = node->val;

            if (pVal > parentVal && qVal > parentVal) {
                // If both p and q are greater than parent
                node = node->right;
            } else if (pVal < parentVal && qVal < parentVal) {
                // If both p and q are lesser than parent
                node = node->left;
            } else {
                // We have found the split point, i.e. the LCA node.
                return node;
            }
        }
        return NULL;
    }
};

Time Complexity : O(N), where N is the number of nodes in the BST. In the worst case we might be visiting all the nodes of the BST.
Space Complexity : O(1)
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Find the inorder predecessor/successor of a given Key in BST.
-----------------------------------------

  #include <iostream>
using namespace std;

// BST Node
struct Node
{
  int key;
  struct Node *left, *right;
};

// This function finds predecessor and successor of key in BST.
// It sets pre and suc as predecessor and successor respectively
void findPreSuc(Node* root, Node*& pre, Node*& suc, int key)
{
  // Base case
  if (root == NULL)  return ;

  // If key is present at root
  if (root->key == key)
  {
    // the maximum value in left subtree is predecessor
    if (root->left != NULL)
    {
      Node* tmp = root->left;
      while (tmp->right)
        tmp = tmp->right;
      pre = tmp ;
    }

    // the minimum value in right subtree is successor
    if (root->right != NULL)
    {
      Node* tmp = root->right ;
      while (tmp->left)
        tmp = tmp->left ;
      suc = tmp ;
    }
    return ;
  }

  // If key is smaller than root's key, go to left subtree
  if (root->key > key)
  {
    suc = root ;
    findPreSuc(root->left, pre, suc, key) ;
  }
  else // go to right subtree
  {
    pre = root ;
    findPreSuc(root->right, pre, suc, key) ;
  }
}

// A utility function to create a new BST node
Node *newNode(int item)
{
  Node *temp =  new Node;
  temp->key = item;
  temp->left = temp->right = NULL;
  return temp;
}

/* A utility function to insert a new node with given key in BST */
Node* insert(Node* node, int key)
{
  if (node == NULL) return newNode(key);
  if (key < node->key)
    node->left  = insert(node->left, key);
  else
    node->right = insert(node->right, key);
  return node;
}

// Driver program to test above function
int main()
{
  int key = 65;    //Key to be searched in BST

  /* Let us create following BST
             50
          /     \
         30      70
        /  \    /  \
      20   40  60   80 */
  Node *root = NULL;
  root = insert(root, 50);
  insert(root, 30);
  insert(root, 20);
  insert(root, 40);
  insert(root, 70);
  insert(root, 60);
  insert(root, 80);


  Node* pre = NULL, *suc = NULL;

  findPreSuc(root, pre, suc, key);
  if (pre != NULL)
    cout << "Predecessor is " << pre->key << endl;
  else
    cout << "No Predecessor";

  if (suc != NULL)
    cout << "Successor is " << suc->key;
  else
    cout << "No Successor";
  return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  Find the inorder predecessor of a given Key in BST.
--------------------------------------------------

#include <iostream>
using namespace std;

// Data structure to store a Binary Search Tree node
struct Node {
	int data;
	Node *left, *right;
};

// Function to create a new binary tree node having given key
Node* newNode(int key)
{
	Node* node = new Node;
	node->data = key;
	node->left = node->right = nullptr;

	return node;
}

// Recursive function to insert a key into BST
Node* insert(Node* root, int key)
{
	// if the root is null, create a new node and return it
	if (root == nullptr)
		return newNode(key);

	// if given key is less than the root node, recur for left subtree
	if (key < root->data)
		root->left = insert(root->left, key);

	// if given key is more than the root node, recur for right subtree
	else
		root->right = insert(root->right, key);

	return root;
}

// Helper function to find maximum value node in given BST
Node* findMaximum(Node* root)
{
	while (root->right)
		root = root->right;

	return root;
}

// Iterative function to find in-order predecessor for given key in a BST
Node* findPredecessor(Node* root, int key)
{
	Node* prec = nullptr;

	while (1)
	{
		// if given key is less than the root node, visit left subtree
		if (key < root->data)
		{
			root = root->left;
		}

		// if given key is more than the root node, visit right subtree
		else if (key > root->data)
		{
			// update predecessor to current node before visiting
			// right subtree
			prec = root;
			root = root->right;
		}

		// if node with key's value is found, predecessor is maximum value
		// node in its left subtree (if any)
		else
		{
			if (root->left)
				prec = findMaximum(root->left);
			break;
		}

		// if key doesn't exist in binary tree
		if (!root)
			return nullptr;
	}

	// return predecessor if any
	return prec;
}

int main()
{
	/* Construct below tree
               15
             /    \
            /      \
           10       20
          / \      /  \
         /   \    /    \
        8    12  16    25
	*/

	int keys[] = { 15, 10, 20, 8, 12, 16, 25 };

	Node* root = nullptr;
	for (int key : keys)
		root = insert(root, key);

	// find in-order predecessor for each key
	for (int key : keys)
	{
		Node* prec = findPredecessor(root, key);

		if (prec != nullptr)
			cout << "Predecessor of node " << key << " is " << prec->data << '\n';
		else
			cout << "Predecessor doesn't exists for " << key << '\n';
	}

	return 0;
}

OUTPUT: 
        Predecessor of node 15 is 12.
        Predecessor of node 10 is 8
        Predecessor of node 20 is 16
        Predecessor does not exist for node 8.
        Predecessor of node 12 is 10
        Predecessor of node 16 is 15
        Predecessor of node 25 is 20

TIME : O(N).
SPACE: O(1).
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

   Find the inorder successor of a given Key in BST.
-------------------------------------------------

#include <iostream>
using namespace std;

struct Node {
	int data;
	Node *left, *right;
};

// Function to create a new binary tree node having given key
Node* newNode(int key)
{
	Node* node = new Node;
	node->data = key;
	node->left = node->right = nullptr;

	return node;
}

// Recursive function to insert a key into BST
Node* insert(Node* root, int key)
{
	// if the root is null, create a new node and return it
	if (root == nullptr)
		return newNode(key);

	// if given key is less than the root node, recur for left subtree
	if (key < root->data)
		root->left = insert(root->left, key);

	// if given key is more than the root node, recur for right subtree
	else
		root->right = insert(root->right, key);

	return root;
}

// Helper function to find minimum value node in given BST
Node* findMinimum(Node* root)
{
	while (root->left)
		root = root->left;

	return root;
}

// Iterative function to find inorder successor for given key in a BST
Node* findSuccessor(Node* root, int key)
{
	Node* succ = nullptr;

	while (1)
	{
		// if given key is less than the root node, visit left subtree
		if (key < root->data)
		{
			// update successor to current node before visiting left subtree
			succ = root;
			root = root->left;
		}

		// if given key is more than the root node, visit right subtree
		else if (key > root->data)
		{
			root = root->right;
		}

		// if node with key's value is found, the successor is minimum value
		// node in its right subtree (if any)
		else
		{
			if (root->right)
				succ = findMinimum(root->right);
			break;
		}

		// if key doesn't exist in binary tree
		if (!root)
			return nullptr;
	}

	// return Successor if any
	return succ;
}

int main()
{
	/* Construct below tree
               15
             /    \
            /      \
           10       20
          / \      /  \
         /   \    /    \
        8    12  16    25
	*/

	int keys[] = { 15, 10, 20, 8, 12, 16, 25 };

	Node* root = nullptr;
	for (int key : keys)
		root = insert(root, key);

	// find in-order successor for each key
	for (int key : keys)
	{
		Node* prec = findSuccessor(root, key);

		if (prec != nullptr)
			cout << "Successor of node " << key << " is " << prec->data;
		else
			cout << "Successor doesn't exists for " << key;

		cout << '\n';
	}

	return 0;
}

OUTPUT: 
         Successor of node 15 is 16.
         Successor of node 10 is 12
         Successor of node 20 is 25
         Successor of node 8  is 10
         Successor of node 12 is 15
         Successor of node 16 is 20
         Successor of node 25 is 25

TIME : O(N).
SPACE: O(1).
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  Ceil in a BST

-----------------------------------


#include <bits/stdc++.h> 
using namespace std; 

class node { 
public: 
	int key; 
	node* left; 
	node* right; 
}; 

node* newNode(int key) 
{ 
	node* Node = new node(); 
	Node->key = key; 
	Node->left = NULL; 
	Node->right = NULL; 
	return (Node); 
} 

int Ceil(node* root, int input) 
{ 
	if (root == NULL) 
		return -1; 

	if (root->key == input) 
		return root->key; 

	if (root->key < input) 
		return Ceil(root->right, input); 

	int ceil = Ceil(root->left, input); 
	return (ceil >= input) ? ceil : root->key; 
} 


int main() 
{ 
	node* root = newNode(8); 

	root->left = newNode(4); 
	root->right = newNode(12); 

	root->left->left = newNode(2); 
	root->left->right = newNode(6); 

	root->right->left = newNode(10); 
	root->right->right = newNode(14); 

	for (int i = 0; i < 16; i++) 
		cout << i << " " << Ceil(root, i) << endl; 

	return 0; 
} 

Output:
0  2
1  2
2  2
3  4
4  4
5  6
6  6
7  8
8  8
9  10
10  10
11  12
12  12
13  14
14  14
15  -1
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  Floor in Binary Search Tree (BST)

Input : x = 14 and root of below tree
            10
           /  \
          5    15
              /  \
            12    30
Output : 12

Input : x = 15 and root of below tree
            10
           /  \
          5    15
              /  \
            12    30
Output : 15    
-----------------------------------
#include <bits/stdc++.h>
using namespace std;

struct Node {
  int data;
  Node *left, *right;
};

Node* newNode(int key)
{
  Node* temp = new Node;
  temp->left = temp->right = NULL;
  temp->data = key;
  return temp;
}

Node* insert(Node* root, int key)
{
  if (!root)
    return newNode(key);
  if (key < root->data)
    root->left = insert(root->left, key);
  else
    root->right = insert(root->right, key);
  return root;
}

int floor(Node* root, int key)
{
  if (!root)
    return INT_MAX;

  if (root->data == key)
    return root->data;

  if (root->data > key)
    return floor(root->left, key);

  int floorValue = floor(root->right, key);
  return (floorValue <= key) ? floorValue : root->data;
}

int main()
{
  Node* root = NULL;
  root = insert(root, 7);
  insert(root, 10);
  insert(root, 5);
  insert(root, 3);
  insert(root, 6);
  insert(root, 8);
  insert(root, 12);
  cout << floor(root, 9) << endl;
  return 0;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Floor value Kth root of a number using Recursive Binary Search

Examples:

Input: N = 27, K = 3
Output: 3
Explanation:
Kth root of 27 = 3. Therefore 3 is the greatest whole number less than equal to Kth root of 25.

Input: N = 36, K = 3
Output: 3
Explanation:
Kth root of 36 = 3.30
Therefore 3 is the greatest whole number less than equal to Kth root of 36 (3.30)
-------------------------------------------------------------

#include <bits/stdc++.h>
using namespace std;

int power(int x, unsigned int y)
{
  int temp;
  if (y == 0)
    return 1;
  temp = power(x, y / 2);
  if (y % 2 == 0)
    return temp * temp;
  else
    return x * temp * temp;
}

int nthRootSearch(int low, int high,
                  int N, int K)
{
  if (low <= high)
  {
    int mid = (low + high) / 2;

    if ((power(mid, K) <= N)
        && (power(mid + 1, K) > N)) {
      return mid;
    }

    else if (power(mid, K) < N) {
      return nthRootSearch(mid + 1,
                           high, N, K);
    }
    else {
      return nthRootSearch(low,
                           mid - 1,
                           N, K);
    }
  }
  return low;
}

int main()
{
  int N = 16, K = 4;
  cout << nthRootSearch(0, N, N, K)
       << endl;
  return 0;
}

OUTPUT: 2
Time Complexity: O(log N)
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Product of all Subarrays of an Array
--------------------------------

#include <bits/stdc++.h> 
using namespace std; 

void product_subarrays(long long int arr[], int n) 
{ 
  long long int res = 1; 

  for (int i = 0; i < n; i++) { 
    long long int product = 1; 
    for (int j = i; j < n; j++) { 
      product = product * arr[j]; 
      res *= product; 
    } 
  } 
    cout << res << "\n"; 
} 

int main() 
{ 
  long long int arr[] = { 10, 3, 7 }; 
  int n = sizeof(arr) / sizeof(arr[0]); 
  product_subarrays(arr, n); 
  return 0; 
} 

Output:
30870
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Floor and ceil in BST
------------------------------------------

#include <iostream>
#include <iomanip>
using namespace std;

struct Node {
	int data;
	Node *left, *right;
};

Node* newNode(int key)
{
	Node* node = new Node;
	node->data = key;
	node->left = node->right = nullptr;

	return node;
}

Node* insert(Node* root, int key)
{
	if (root == nullptr)
		return newNode(key);

	if (key < root->data)
		root->left = insert(root->left, key);
	else
		root->right = insert(root->right, key);

	return root;
}

void findFloorCeil(Node* root, Node* &floor, Node* &ceil, int key)
{
	while (root)
	{
		if (root->data == key)
		{
			floor = root;
			ceil = root;
			break;
		}

		else if (key < root->data)
		{
			ceil = root;
			root = root->left;
		}

		else
		{
			floor = root;
			root = root->right;
		}
	}
}

int main()
{
	int keys[] = { 2, 4, 6, 8, 9, 10, 12 };
	Node* root = nullptr;
	
   for (int key : keys)
    root = insert(root, key);

   for (int i = 0; i < 15; i++)
	{
		Node *floor = nullptr, *ceil = nullptr;
		findFloorCeil(root, floor, ceil, i);

		cout << setw(2) << i << " --> ";
		cout << setw(4) << (floor? floor->data: -1);
		cout << setw(4) << (ceil? ceil->data: -1) << endl;
	}
	return 0;
}

OUTPUT:
 0 -->   -1   2
 1 -->   -1   2
 2 -->    2   2
 3 -->    2   4
 4 -->    4   4
 5 -->    4   6
 6 -->    6   6
 7 -->    6   8
 8 -->    8   8
 9 -->    9   9
10 -->   10  10
11 -->   10  12
12 -->   12  12
13 -->   12  -1
14 -->   12  -1

 
TIME: O(N).
SPACE: O(1).
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Second Minimum Node In a Binary Tree

Example 1:

Input: 
    2
   / \
  2   5
     / \
    5   7

Output: 5
Explanation: The smallest value is 2, the second smallest value is 5.
 

Example 2:

Input: 
    2
   / \
  2   2

Output: -1
Explanation: The smallest value is 2, but there isn't any second smallest value.
--------------------------------------

class Solution {
public:

     void inorder(TreeNode* root, set<int>&res)
    {
        if(!root) return;
        inorder(root->left,res);
        res.insert(root->val);
        inorder(root->right,res);
    }
    
    
    int findSecondMinimumValue(TreeNode* root) {
        set<int>v;
        inorder(root, v);
        
        int n=v.size();
        if(n>=2)
        {
            auto it=v.begin();
            advance(it,1);
            return *it;
        }
        return -1;
    }
};
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    Kth Smallest Element in a BST

Example 1:

Input: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
Output: 1
Example 2:

Input: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
Output: 3
--------------------------------------
  
SOLUTION 1: (RECURSIVE METHOD)

class Solution {
public:
    
    void inorder(TreeNode* root, set<int>&res)
    {
        if(!root) return;
        inorder(root->left,res);
        res.insert(root->val);
        inorder(root->right,res);
    }
    
    int kthSmallest(TreeNode* root, int k) 
    {
        set<int>v;
        inorder(root, v);
        
        int n=v.size();
        if(n>=k)
        {
            auto it=v.begin();
            advance(it,k-1);
            return *it;
        }
        return -1;
    }
};
............................

SOLUTION2 : (ITERATIVE METHOD)



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  BST iterator

 Example:
BSTIterator iterator = new BSTIterator(root);
iterator.next();    // return 3
iterator.next();    // return 7
iterator.hasNext(); // return true
iterator.next();    // return 9
iterator.hasNext(); // return true
iterator.next();    // return 15
iterator.hasNext(); // return true
iterator.next();    // return 20
iterator.hasNext(); // return false
 
Note:
next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.
You may assume that next() call will always be valid, that is, there will be at least a next smallest number in the BST when next() is called.
-----------------------------------























///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 Depth first search 

-----------------------------

   
  




 
 
  
  
 
