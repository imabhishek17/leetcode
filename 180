 Find the duplicate in an array of N integers. 
             OR
   Find the Duplicate Number
   
   Example 1:
Input: [1,3,4,2,2]
Output: 2
Example 2:

Input: [3,1,3,4,2]
Output: 3
--------------


 class Solution {
public:
    int findDuplicate(vector<int>& nums)
    {
      for(int i=0;i<nums.size();i++)
      {
         int idx=abs(nums[i]);
         if(nums[idx]<0) return idx;
            nums[idx]=-nums[idx];
      }
        return -1;
	}
};
//////////////////////////////////////////////////////////////// 
   
   
Find All Duplicates in an Array(LEETCODE)
Example:
Input:
[4,3,2,7,8,2,3,1]

Output:
[2,3]
-----------------

class Solution {
public:
    vector<int> findDuplicates(vector<int>& nums) 
    {
       vector<int>vec;
        for(int i=0;i<nums.size();i++)
        {
         int idx=abs(nums[i])-1;
         if(nums[idx]<0) vec.push_back(idx+1);
            nums[idx]=-nums[idx];
        }
        return vec;
    }
};
/////////////////////////////////////////////////////////////////////

  Multiply Strings   (LEETCODE)

  Example 1:

Input: num1 = "2", num2 = "3"
Output: "6"
Example 2:

Input: num1 = "123", num2 = "456"
Output: "56088"
----------------------------------------------------

class Solution {
public:
    string multiply(string a, string b) {
    if (a=="0" || b=="0")
        return "0";
    int m = a.size() - 1, n = b.size() - 1, carry = 0;
    string product;
    for (int i=0; i<=m+n || carry; ++i) {
        for (int j=max(0, i-n); j<=min(i, m); ++j)
            carry += (a[m-j] - '0') * (b[n-i+j] - '0');
        product += carry % 10 + '0';
        carry /= 10;
    }
    reverse(begin(product), end(product));
    return product;
    }
};

/////////////////////////////////////////////////////////////////////

   Add Binary

  Example 1:

Input: a = "11", b = "1"
Output: "100"
Example 2:

Input: a = "1010", b = "1011"
Output: "10101"
---------------------------------------------
class Solution {
public:
    string addBinary(string a, string b) {
       string s = "";
        
        int c = 0, i = a.size() - 1, j = b.size() - 1;
        while(i >= 0 || j >= 0 || c == 1)
        {
            c += i >= 0 ? a[i --] - '0' : 0;
            c += j >= 0 ? b[j --] - '0' : 0;
            s = char(c % 2 + '0') + s;
            c /= 2;
        }
        
        return s;
    }
};

////////////////////////////////////////////////////////////////////////

   Add to Array-Form of Integer

   Example 1:

Input: A = [1,2,0,0], K = 34
Output: [1,2,3,4]
Explanation: 1200 + 34 = 1234
Example 2:

Input: A = [2,7,4], K = 181
Output: [4,5,5]
Explanation: 274 + 181 = 455
Example 3:

Input: A = [2,1,5], K = 806
Output: [1,0,2,1]
Explanation: 215 + 806 = 1021
Example 4:

Input: A = [9,9,9,9,9,9,9,9,9,9], K = 1
Output: [1,0,0,0,0,0,0,0,0,0,0]
Explanation: 9999999999 + 1 = 10000000000
---------------------------------------------------------

class Solution {
public:
    vector<int> addToArrayForm(vector<int>& A, int K) {
      reverse(A.begin(), A.end());
    for (int i = 0; i < A.size(); i++) {
        A[i] += K;
        K = A[i] / 10;
        A[i] %= 10;
    }
    while (K) {
        A.push_back(K%10);
        K /= 10;
    }
    reverse(A.begin(), A.end());
    return A;
    }
};

Time Complexity: O(max(N,log K))
space: O(1)
/////////////////////////////////////////////////////////////////////////

  Plus One

  Example 1:

Input: [1,2,3]
Output: [1,2,4]
Explanation: The array represents the integer 123.
Example 2:

Input: [4,3,2,1]
Output: [4,3,2,2]
Explanation: The array represents the integer 4321.
-----------------------------------------------------------

class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
         for(int i = digits.size() - 1;i >= 0;i--){
            if(digits[i] != 9){
                digits[i]++;
                return digits;
            }
            else
                digits[i] = 0;
        }
        digits.insert(digits.begin(),1);
        return digits;
    }
};

////////////////////////////////////////////////////////////////////////

Sum of Two Integers

Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.
Example 1:
Input: a = 1, b = 2
Output: 3

Example 2:
Input: a = -2, b = 3
Output: 1
-------------------------------------------------------------------

class Solution {
public:
    int getSum(int a, int b) {
        if (b==0) return a;
	int sum = a^b; //find sum
	int carry = (unsigned int)(a & b)<<1; //find carry
	return getSum(sum, carry);
    }
};
/////////////////////////////////////////////////////////////////////////

 Sort an array of 0’s 1’s 2’s without using extra space or sorting algo 

   Input: [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
--------------------------------

class Solution {
public:
    void sortColors(vector<int>& nums) 
    { 
      int a=0,b=0,c=0;
        for(int i=0;i<nums.size();i++)
        {
            if(nums[i]==0)a++;
            if(nums[i]==1)b++;
            if(nums[i]==2)c++;
        }
        int x=0;
        while(a--)
        {
          nums[x++]=0;
        }
         while(b--)
        {
          nums[x++]=1;
        }
         while(c--)
        {
          nums[x++]=2;
        }
        
    }
    
};
//////////////////////////////////////////////////////////////////////////////////////////

   Missing Number

   Input: [3,0,1]
Output: 2

Input: [9,6,4,2,3,5,7,0,1]
Output: 8
-------------------------------------------

class Solution {
public:
    int missingNumber(vector<int>& nums) {
       int sum=0;
        for(int i=0;i<nums.size();i++)
        {
          sum^=nums[i]^(i+1);
        }

        return sum;
    }
};
///////////////////////////////////////////////////////////////////////////////////////////////

Repeat and Missing Number Array


Input:[3 1 2 5 3] 
Output:[3, 4] 

-------------------------------------------

class Solution {
public:
    vector<int> repeatedNumber(const vector<int> &V) {
       long long sum = 0;
       long long squareSum = 0;
       long long temp;
       for (int i = 0; i < V.size(); i++) {
           temp = V[i];
           sum += temp;
           sum -= (i + 1);
           squareSum += (temp * temp);
           squareSum -= ((long long)(i + 1) * (long long)(i + 1));
       }
       // sum = A - B
       // squareSum = A^2 - B^2 = (A - B)(A + B)
       // squareSum / sum = A + B
       squareSum /= sum;

       // Now we have A + B and A - B. Lets figure out A and B now. 
       int A = (int) ((sum + squareSum) / 2);
       int B = squareSum - A;

       vector<int> ret;
       ret.push_back(A);
       ret.push_back(B);
       return ret;
    }
};
///////////////////////////////////////////////////////////////////////////////////////////////////////

Numbers With Repeated Digits

Example 1:

Input: 20
Output: 1
Explanation: The only positive number (<= 20) with at least 1 repeated digit is 11.
Example 2:

Input: 100
Output: 10
Explanation: The positive numbers (<= 100) with atleast 1 repeated digit are 11, 22, 33, 44, 55, 66, 77, 88, 99, and 100.
-------------------------------------------------------------------

class Solution {
public:
    int numDupDigitsAtMostN(int N) {
         if(N < 10) return 0;
        int k = 0;
        for(int i = N; i > 0; i /= 10)
          k++;
        
      vector<int>digit(k,0);
      int i=0,j=N;
      while(i<k)
      {
        digit[k-1-i]=j%10;
        j/=10;
        i++;
      }
      
        int noDupBaseSum = 0;
        vector<int>noDupBase(k-1,0);
        for(int i = 0; i < k - 1; i++)
        {
            
           if(i==0)
           {
            noDupBase[i]=9; 
           }
          else
          {
            noDupBase[i]=noDupBase[i-1]*(10-i);
          }
          
            noDupBaseSum += noDupBase[i];
        }
        
        int count[10] = {0};
        vector<int>noDupRes(k,0);
        bool duplicate = false;
        for(int i = 0; i < k; i++)
        {
          
           if(i==0)
           {
            noDupRes[i]=9; 
           }
           else
           {
            noDupRes[i]=noDupRes[i-1]*(10-i);
           }
          
            if(!duplicate)
            {
                int diff = 0;
                for(int j = digit[i] + 1; j < 10; j++)
                  diff += count[j] == 0;
                
                noDupRes[i] -= diff;
                count[digit[i]]++;
                if(count[digit[i]] > 1) duplicate = true;
            }
        }
        return N - (noDupBaseSum + noDupRes[k - 1]);
    }
};
///////////////////////////////////////////////////////////////////////////////////////

 Missing Number


Example 1:

Input: [3,0,1]
Output: 2
Example 2:

Input: [9,6,4,2,3,5,7,0,1]
Output: 8
----------------------------------

class Solution {
public:
    int missingNumber(vector<int>& nums) {
       int sum=0;
        for(int i=0;i<nums.size();i++)
        {
          sum^=nums[i]^(i+1);
        }

        return sum;
    }
};
///////////////////////////////////////////////////////////////////////////////////////////

Find All Numbers Disappeared in an Array

Example:

Input:
[4,3,2,7,8,2,3,1]

Output:
[5,6]
-------------------------------------------------------

class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        int len = nums.size();
        for(int i=0; i<len; i++) {
            int m = abs(nums[i])-1; // index start from 0
            nums[m] = nums[m]>0 ? -nums[m] : nums[m];
        }
        vector<int> res;
        for(int i = 0; i<len; i++) {
            if(nums[i] > 0) res.push_back(i+1);
        }
        return res;
    }
};
////////////////////////////////////////////////////////////////////////////////////////////////////////

   Kadane’s Algorithm 
        OR
   Maximum Subarray(LEETCODE)


   Example:

Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
-----------------------------------------------------------------

class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int cs=0,ms=INT_MIN;
        for(int i=0;i<nums.size();i++)
        {
         cs=cs+nums[i];
            if(cs<nums[i])
                cs=nums[i];
            if(ms<cs)
                ms=cs;
        }
        return ms;
        
    }
};
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////


Merge Overlapping Subintervals 
   OR
Merge Intervals

Example 1:

Input: [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].
Example 2:

Input: [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
---------------------------------------------------------------------------

class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
      
      if(!intervals.size())return {};
        vector<vector<int>>ans;
      sort(begin(intervals),end(intervals));
        ans.push_back(intervals[0]);
      
        for(int i=1;i<intervals.size();i++)
        {
          int n=ans.size();
          if(intervals[i][0]<=ans[n-1][1])
            ans[n-1][1]=max(intervals[i][1],ans[n-1][1]);
          
          else
            ans.push_back(intervals[i]);
        }
      return ans;
        
    }
};
//////////////////////////////////////////////////////////////////////////////////////////////

Set Matrix Zeros 

Example 1:
Input: 
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
Output: 
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]

Example 2:
Input: 
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
Output: 
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]
---------------------------------------------

class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
      int n=matrix.size();
      int m=matrix[0].size();
      int r[n];
      int c[m];
      for(int i=0;i<n;i++)
      	r[i]=1;

      for(int i=0;i<m;i++)
      	c[i]=1;
      

      for(int i=0;i<n;i++)
      {
      	for(int j=0;j<m;j++)
        {
        	if(matrix[i][j]==0)
        	{
        		r[i]=0;
                c[j]=0;
            
        	}
        }
      }

      for(int i=0;i<n;i++)
      {
        for(int j=0;j<m;j++)
        {
        	if(r[i]==0||c[j]==0)
        	{
              matrix[i][j]=0;
        	}
        }
      }
      
      
    }
};

Time Complexity : O(M×N)
Space Complexity : O(M+N)


ALTERNATE SOLUTION:

class Solution {
public:
    void setZeroes(vector<vector<int>>& v) {
        int r=v.size(), c=v[0].size();
        bool x=0;
        
        for(int i=0;i<r;i++)
        {
            if(v[i][0]==0)
            {
                x=1;
            }
            for(int j=1;j<c;j++)
            {
                if(v[i][j]==0)
                {
                    v[0][j]=0;
                    v[i][0]=0;
                }
            }
        }
        
        for(int i=1;i<r;i++)
        {
          for(int j=1;j<c;j++)
          {
            if(v[i][0]==0 || v[0][j]==0)
            {
                v[i][j]=0;
            }
          }
        }
        
        if(v[0][0]==0)
        {
            for(int j=0;j<c;j++)
            {
                v[0][j]=0;
            }
        }
        
        if(x)
        {
          for(int i=0;i<r;i++)
          {
              v[i][0]=0;
          }
        }
        
    }
};


Time Complexity : O(M×N)
Space Complexity : O(1)

/////////////////////////////////////////////////////////////////////////////////////////////////

Pascal Triangle 

Input: 5
Output:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
------------------------------------

class Solution {
public:
    vector<vector<int>> generate(int numRows) {
      int n=numRows;
      vector<vector<int>>a(n);
      
      for(int i=0;i<n;i++)
      {
        a[i].resize(i+1);
        a[i][0]=a[i][i]=1;
        
        for(int j=1;j<i;j++)
        {
          a[i][j]=a[i-1][j-1]+a[i-1][j];
        }
      }
        
      return a;
    }
};

TIME : O(N^2)
SPACE: O(N^2)
/////////////////////////////////////////////////////////////////////////////////////////

Next Permutation 
-------------------------------


class Solution {
public:
    void nextPermutation(vector<int>& nums) {
    
      next_permutation(nums.begin(),nums.end());
      
    }
};

ALTERNATIVE  (FULL CODE):

void swap(vector<int>&nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

void reverse( vector<int>&nums, int start) {
        int i = start, j = nums.size() - 1;
        while (i < j) {
            swap(nums, i, j);
            i++;
            j--;
        }
    }

class Solution {
public:
    void nextPermutation(vector<int>& nums) {
            int i = nums.size() - 2;
        while (i >= 0 && nums[i + 1] <= nums[i]) {
            i--;
        }
        if (i >= 0) {
            int j = nums.size() - 1;
            while (j >= 0 && nums[j] <= nums[i]) {
                j--;
            }
            swap(nums, i, j);
        }
        reverse(nums, i + 1);
    
    }
};
////////////////////////////////////////////////////////////////////////////////////////////////////

  Rotate Image  
     OR
 Rotate Matrix  



Example 1:
Given input matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

rotate the input matrix in-place such that it becomes:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]


Example 2:
Given input matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

rotate the input matrix in-place such that it becomes:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
-----------------------------------------------------------------

class Solution {
public:
    void rotate(vector<vector<int>>& v) {
        int n=v.size(),m=v[0].size();
        vector<vector<int>>a(n,vector<int>(m,0));
        
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<m;j++)
            {
                a[j][m-1-i]=v[i][j];
            }
        }
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<m;j++)
            {
                v[i][j]=a[i][j];
            }
        }
        
    }
};

TIME: O(N^2)
SPACE: O(N^2)


ALTERNATIVE SOLUTION (optimised (in terms of space, time is same in both))


class Solution {
public:
    void rotate(vector<vector<int>>& v) {
        int n=v.size();
        
        for(int i=0;i<n;i++)      //transpose
        {
            for(int j=i;j<n;j++)
            {
              int temp=v[i][j];
              v[i][j]=v[j][i];
              v[j][i]=temp;
            }
        }
        
        for(int i=0;i<n;i++)            //swap elements of each row (automatically the coloumns will reverse)
        {
          for(int j=0;j<(n/2);j++)
          {
              int temp=v[i][j];
              v[i][j]=v[i][n-1-j];
              v[i][n-1-j]=temp;
          }
        }
    }
};


TIME: O(N^2)
SPACE: O(N^2)
////////////////////////////////////////////////////////////////////////////////////////////////////


  Lexicographically next permutation in C++ (GFG)
------------------------------------------------------

  // Find the next lexicographically 
// greater permutation of a word 

#include <algorithm> 
#include <iostream> 

using namespace std; 

int main() 
{ 
	string s = { "gfg" }; 
	bool val 
		= next_permutation(s.begin(), 
						s.end()); 
	if (val == false) 
		cout << "No Word Possible"
			<< endl; 
	else
		cout << s << endl; 
	return 0; 
} 

ALTERNATIVE SOLUTION:

#include <iostream> 

using namespace std; 

void swap(char* a, char* b) 
{ 
	if (*a == *b) 
		return; 
	*a ^= *b; 
	*b ^= *a; 
	*a ^= *b; 
} 
void rev(string& s, int l, int r) 
{ 
	while (l < r) 
		swap(&s[l++], &s[r--]); 
} 

int bsearch(string& s, int l, int r, int key) 
{ 
	int index = -1; 
	while (l <= r) { 
		int mid = l + (r - l) / 2; 
		if (s[mid] <= key) 
			r = mid - 1; 
		else { 
			l = mid + 1; 
			if (index == -1 || s[index] >= s[mid]) 
				index = mid; 
		} 
	} 
	return index; 
} 

bool nextpermutation(string& s) 
{ 
	int len = s.length(), i = len - 2; 
	while (i >= 0 && s[i] >= s[i + 1]) 
		--i; 
	if (i < 0) 
		return false; 
	else { 
		int index = bsearch(s, i + 1, len - 1, s[i]); 
		swap(&s[i], &s[index]); 
		rev(s, i + 1, len - 1); 
		return true; 
	} 
} 

int main() 
{ 
	string s = { "gfg" }; 
	bool val = nextpermutation(s); 
	if (val == false) 
		cout << "No Word Possible" << endl; 
	else
		cout << s << endl; 
	return 0; 
} 

   output: ggf

   TIME : O(logN) 
   SPACE: O(N)
/////////////////////////////////////////////////////////////////////////////////////////////////////////


Reverse a LinkedList   (RECURSIVE AND ITERATIVE APPROACH)

Input: 1->2->3->4->5->NULL
Output: 5->4->3->2->1->NULL
-------------------------------------------- 

 class Solution {
public:
    ListNode* reverseList(ListNode* head) 
    {
      
    if(!head || !head->next) return head;
    ListNode* p = reverseList(head->next);
    head->next->next = head;
    head->next = nullptr;
    return p;
    }
};

 TIME and SPACE : O(N) AND O(N)
...................
ALTERNATIVE SOLUTION

class Solution {
public:
    ListNode* reverseList(ListNode* head) 
    {
        ListNode * c,*p,*n;
 
  c=head;
  p=NULL;

  while(c!=NULL)
  {
  // save the next node
   n=c->next;
   //make the current node next to prev
   c->next=p;
    //just update prev and current
   p=c;
   c=n;
  }
  head=p;
        
        return head;
    }
};

TIME and SPACE : O(N) AND O(1)

/////////////////////////////////////////////////////////////////////////////////////////

  Middle of the Linked List

  Example 1:
Input: [1,2,3,4,5]
Output: Node 3 from this list (Serialization: [3,4,5])
The returned node has value 3.  (The judge's serialization of this node is [3,4,5]).
Note that we returned a ListNode object ans, such that:
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.

Example 2:
Input: [1,2,3,4,5,6]
Output: Node 4 from this list (Serialization: [4,5,6])
Since the list has two middle nodes with values 3 and 4, we return the second one.

-----------------------------------------
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        vector<ListNode*> A = {head};
        while (A.back()->next != NULL)
            A.push_back(A.back()->next);
        return A[A.size() / 2];
    }
};
  TIME AND SPACE: O(N) and O(1).

 ALTERNATIVE SOLUTION :

   class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode* sp=head, *fp=head;
      
        while(fp!=NULL &&fp->next!=NULL)
        {
          sp=sp->next;
          fp=fp->next->next;
        }
        
      return sp;
    }
};

TIME AND SPACE: O(N) and O(1).
//////////////////////////////////////////////////////////////////////////////////////////////////////////

 Merge Two Sorted Lists

 Input: 1->2->4, 1->3->4
Output: 1->1->2->3->4->4
-----------------------------

class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
         if(!l1) return l2;
         if(!l2) return l1;
      
        ListNode* c;
      
       if(l1->val>l2->val)
       {
         c=l2;
         c->next=mergeTwoLists(l1,l2->next);
       }
        else
       {
         c=l1;
         c->next=mergeTwoLists(l1->next,l2);
       }
      
      return c;
    }
};

TIME : O(N*M)
//////////////////////////////////////////////////////////////////////////////////////////////

  Remove Nth Node From End of List


Example:
Given linked list: 1->2->3->4->5, and n = 2.
After removing the second node from the end, the linked list becomes 1->2->3->5.


--------------------------------------------------------
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n)
    {
    if(!head || !head->next)  return NULL;
              
        auto s=head;
        auto f=head;
        
        int i=0;
        while(f->next!=NULL && i!=n){
                f=f->next;
                i++;
        }
        if(i!=n){
            head=head->next;
            return head;
        }
        while(f->next!=NULL){
            s=s->next;
            f=f->next;
        }
        s->next=s->next->next;
        return head;
    }
};

TIME AND SPACE: O(N) and O(1).
////////////////////////////////////////////////////////////////////////////////////////////////////

  Delete Node in a Linked List

  Input: head = [4,5,1,9], node = 5
Output: [4,1,9]
Explanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function

------------------------------------------------------------------------------------

class Solution {
public:
    void deleteNode(ListNode* node) {
      node->val=node->next->val;
      node->next=node->next->next;
    }
};

Time and space complexity are both O(1).


ALTERNATIVE SOLUTION: 

class Solution {
public:
    void deleteNode(ListNode* node)
    {
        ListNode* temp;
        temp=node->next;
        node->val=node->next->val;
        node->next=node->next->next;
  
    }
};
/////////////////////////////////////////////////////////////////////////////////////////////////

  Add Two Numbers

  Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 0 -> 8
Explanation: 342 + 465 = 807.
--------------------------------------------------

  
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        if (l1 == NULL and l2 == NULL) return NULL;
			else if (l1 == NULL) return l2; 
			else if (l2 == NULL) return l1; 

			int a = l1->val + l2->val;
			ListNode *p = new ListNode(a % 10);
			p->next = addTwoNumbers(l1->next,l2->next);
			if (a >= 10) p->next = addTwoNumbers(p->next, new ListNode(1));
			return p;
    }
};


ALTERNATIVE SOLUTION


class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
         ListNode* dummyHead = new ListNode(0);
    ListNode* p = l1; ListNode* q = l2; ListNode* curr = dummyHead;
    int carry = 0;
    while (p != nullptr || q != nullptr) {
        int x = (p != nullptr) ? p->val : 0;
        int y = (q != nullptr) ? q->val : 0;
        int sum = carry + x + y;
        carry = sum / 10;
        curr->next = new ListNode(sum % 10);
        curr = curr->next;
        if (p != nullptr) p = p->next;
        if (q != nullptr) q = q->next;
    }
    if (carry > 0) 
    {
        curr->next = new ListNode(carry);
    }
    return dummyHead->next;
    }
};

time and space : O(max(m,n)).
//////////////////////////////////////////////////////////////////////////////////////////////////////

Find intersection point of Y LinkedList 


Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
Output: Reference of the node with value = 8
Input Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.
-------------------------------------------------
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        
      ListNode* aptr,*bptr;
      aptr=headA, bptr=headB;
      
      while(bptr!=aptr)
      {
        if(aptr==NULL) aptr=headB;
        else aptr=aptr->next;
        
        if(bptr==NULL) bptr=headA;
        else bptr=bptr->next;
      }
      
      return bptr;
      
    }
};

Time complexity : O(m+n)
Space complexity : O(1).
/////////////////////////////////////////////////////////////////////////////////////////////////////

   Palindrome Linked List

Example 1:

Input: 1->2
Output: false
Example 2:

Input: 1->2->2->1
Output: true
------------------------------

class Solution {
public:
    bool isPalindrome(ListNode* head) {
      
      ListNode* sp=head,*fp=head,*mid=NULL;
       
      while(fp!=NULL && fp->next!=NULL)
      {
        sp=sp->next;
        fp=fp->next->next;
      }
      
     ListNode* p=NULL, *n;
      while(sp!=NULL)
      {
        n=sp->next;
        sp->next=p;
        p=sp;
        sp=n;
      }
      
      while(p!=NULL)
      {
        if(head->val!=p->val)
        return false;
        
        head=head->next;
        p=p->next;
      }

       return true;
    }
};
//////////////////////////////////////////////////////////////////////////////////////

Reverse a LinkedList in groups. 
            OR
Reverse Nodes in k-Group

Example:
Given this linked list: 1->2->3->4->5
For k = 2, you should return: 2->1->4->3->5
For k = 3, you should return: 3->2->1->4->5
------------------------------------------------------

class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
         ListNode* p=head, *c=head, *n;
      
      int count=0;
      while(p!=NULL && count!=k)
      {
        p=p->next;
        count++;
      }
      if(count==k)
      {
         p=reverseKGroup(p,k);
        while(count>0)
        { 
          // save the next node
          n=c->next;
          //make the current node next to prev
          c->next=p;
          //just update prev and current
          p=c;
          c=n;
           count--;
        }
        head=p;  
      }
      return head;
    }
};
/////////////////////////////////////////////////////////////////////////////////////////

    Rotate List

Example 1:
Input: 1->2->3->4->5->NULL, k = 2
Output: 4->5->1->2->3->NULL
Explanation:
rotate 1 steps to the right: 5->1->2->3->4->NULL
rotate 2 steps to the right: 4->5->1->2->3->NULL

Example 2:
Input: 0->1->2->NULL, k = 4
Output: 2->0->1->NULL
Explanation:
rotate 1 steps to the right: 2->0->1->NULL
rotate 2 steps to the right: 1->2->0->NULL
rotate 3 steps to the right: 0->1->2->NULL
rotate 4 steps to the right: 2->0->1->NULL
--------------------------------------------------------

class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        
      if(!head || !head->next || k==0) return head;
      
      int len=1;
      auto f=head;
      while(f->next)
      {
        f=f->next;
        len++;
      }
      
      k=k%len;
      f->next=head;
      
      for(int i=0;i<(len-k);i++)
      {
        f=f->next;
      }
      
      head=f->next;
      f->next=NULL;
      return head;
    }
};
////////////////////////////////////////////////////////////////////////////////////////////////////

Linked List Cycle

 Example 1:

Input: head = [3,2,0,-4], pos = 1
Output: true
Explanation: There is a cycle in the linked list, where tail connects to the second node.

Example 2:

Input: head = [1,2], pos = 0
Output: true
Explanation: There is a cycle in the linked list, where tail connects to the first node.

Example 3:

Input: head = [1], pos = -1
Output: false
Explanation: There is no cycle in the linked list.
-----------------------------------------------------------------

class Solution {
public:
    bool hasCycle(ListNode *head) {
      
      if(!head || !head->next) return 0;
      
      auto s=head, f=head;
      
  
        while(f && f->next)
      {    
        s=s->next;
        f=f->next->next;
         if(f==s)return 1;
      }
      return 0;
    }
};

O(N) AND O(1)
///////////////////////////////////////////////////////////////////////////////////////////////////////

  Linked List Cycle II
         OR
  Find the starting point of the loop. 


  Example 1:
Input: head = [3,2,0,-4], pos = 1
Output: tail connects to node index 1
Explanation: There is a cycle in the linked list, where tail connects to the second node.


Example 2:
Input: head = [1,2], pos = 0
Output: tail connects to node index 0
Explanation: There is a cycle in the linked list, where tail connects to the first node.


Example 3:
Input: head = [1], pos = -1
Output: no cycle
Explanation: There is no cycle in the linked list.
--------------------------------------------------------------

  class Solution {
public:
    ListNode *detectCycle(ListNode *head) {

      auto s=head,f=head;
       while(f && f->next)
       {
         s=s->next; f=f->next->next; if(s==f) break;
       }
      
       if(!f || !f->next) return NULL;
      
       s=head;
      
       while(s!=f)
       {
         s=s->next;
         f=f->next;
       }
      return s;
    }
};
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

   Remove Linked List Elements

  Input:  1->2->6->3->4->5->6, val = 6
Output: 1->2->3->4->5
------------------------------------------------------------------

class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        if (head == NULL) return NULL;
        head->next = removeElements(head->next, val);
      
       if(head->val==val)
         return head->next;
      else
        return head;
    }
};
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  3Sum
  
Given array nums = [-1, 0, 1, 2, -1, -4],
A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]
---------------------------------------------

class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
      vector<vector<int>> result;
        sort(begin(nums),end(nums));
        for (int i = 0; i < nums.size(); i++) {
            if (i == 0 || nums[i] != nums[i-1]) {
                int start = i + 1, end = nums.size() - 1;
                while (start < end) {
                    int sum = nums[i] + nums[start] + nums[end];
                    if (sum == 0){
                        vector<int> tmp;
                        tmp.push_back(nums[i]);
                        tmp.push_back(nums[start]);
                        tmp.push_back(nums[end]);
                        result.push_back(tmp);
                        int startVal = nums[start];
                        int endVal = nums[end];
                        while (start < end && startVal == nums[start]) {
                            start ++;
                        }
                        while (end > start && endVal == nums[end]) {
                            end --;
                        }
                    }
                    else if (sum < 0) {
                        start ++;
                    }
                    else {
                        end --;
                    }
                }
            }
        }
        return result;
    }
};
.......................................

   ALTERNATE SOLUTION (LEETCODE PAR NHI CHALA BUT INTERVIEWBIT PAR CHAL GYA)

  vector<vector<int>> result;
        if(A.size()<=2)return result;
        sort(A.begin(), A.end());
        for (int i = 0; i < A.size() - 2; i++) {
            long int a = A[i];
            if(a > 0) break;
            if (i > 0 && a == A[i - 1]) continue;
            for (long j = i + 1, k = A.size() - 1; j < k;) {
               long  int b = A[j];
                long int c = A[k];
                long int value = a + b + c;
                if (value == 0)
                {
                    result.push_back({a, b, c});
                    while (j<k && b == A[++j]);
                    while (j < k &&c == A[--k]);
                } else if (value > 0) {
                    k--;
                } else {
                    j++;
                }
            }
        }
        return result;
/////////////////////////////////////////////////////////////////////////////////////

Remove Duplicates from Sorted Array

Given nums = [1,1,2],
Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.

Given nums = [0,0,1,1,1,2,2,3,3,4],
Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.
-----------------------------------------------------------

class Solution {
public:
    int removeDuplicates(vector<int>& a) {
  
       if(!a.size()) return 0;
      int j=0;
      
      for(int i=1;i<a.size();i++)
      {
        if(a[j]!=a[i])
          j++;
        a[j]=a[i];
      }
      return j+1;
      
    }
};
///////////////////////////////////////////////////////////////////////////////////////////////////

Max Consecutive Ones
    OR
Max continuous number of 1’s  

Example 1:
Input: [1,1,0,1,1,1]
Output: 3
Explanation: The first two digits or the last three digits are consecutive 1s.
    The maximum number of consecutive 1s is 3.
-------------------------------------------------------------------------------

class Solution {
public:
    int findMaxConsecutiveOnes(vector<int>& v) {
        int mx=0;
  
        int c=0;
        for(int i=0;i<v.size();i++)
        {
          if(v[i]==1)
          {
            c++;
            mx=max(mx,c);
          }
          else
          {
            c=0;
          }
        }
      return mx;
    }
};
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  Max Consecutive Ones II

  Example 1:

Input: [1,0,1,1,0]
Output: 4
Explanation: Flip the first zero will get the the maximum number of consecutive 1s.
    After flipping, the maximum number of consecutive 1s is 4.
--------------------------------------------------------------------
public class Solution 
{
    public int findMaxConsecutiveOnes(int[] nums)
    {
        int k = 1, low = 0, zeroCount = 0, ret = 0;
        for (int i=0; i<nums.length; i++) {
            if (nums[i] == 0)
            {
                zeroCount++;
            }
            while (zeroCount > k) 
            {
                if (nums[low] == 0)
                {
                    zeroCount--;
                }
                low++;
            }
            ret = Math.max(ret, i - low + 1);
    }
        
        return ret;
    }
}        

 Time: O(n), Space: O(n)
/////////////////////////////////////////////////////////////////////////////////////////////////////

  Max Consecutive Ones III

  Example 1:
Input: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2
Output: 6
Explanation: 
[1,1,1,0,0,1,1,1,1,1,1]
Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.

Example 2:
Input: A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3
Output: 10
Explanation: 
[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.
-----------------------------------------------------------------------

   Max Consecutive Ones III


Given an array A of 0s and 1s, we may change up to K values from 0 to 1.
Return the length of the longest (contiguous) subarray that contains only 1s. 

Example 1:

Input: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2
Output: 6
Explanation: 
[1,1,1,0,0,1,1,1,1,1,1]
Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.
Example 2:

Input: A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3
Output: 10
Explanation: 
[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.
------------------------------------------------------------------------

  class Solution {
public:
    int longestOnes(vector<int>& A, int K) {
         int i = 0, j = 0;
      while (i < A.size()) {
      K = K - ( 1 - A[i++] );
      if (K < 0) K += 1 - A[j++];
     }
      return i - j;
    }
};
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Max Continuous Series of 1s (INTERVIEWBIT)

   Input : 
Array = {1 1 0 1 1 0 0 1 1 1 } 
M = 1

Output : 
[0, 1, 2, 3, 4] 
--------------------------------------------

  vector<int> Solution::maxone(vector<int> &A, int B) {
    int idx = 0, c=0, l=0, maxi = 0;
    int p=0, q=0;
    for(int i=0; i<A.size(); i++)
    {
        if(A[i] == 0)
            c++;
        while(c>B)
        {
            if(A[l] == 0)
                c--;
            l++;
        }
        if(i-l+1>maxi)
        {
            maxi = i-l+1;
            p = l;
            q = i;
        }
    }
    vector<int> res;
    for(int i=p; i<=q; i++)
        res.push_back(i);
    return res;
}
/////////////////////////////////////////////////////////////////////////////////////////////////

 Longest Consecutive Sequence (INTERVIEWBIT)

  Example:
Given [100, 4, 200, 1, 3, 2],
The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.
Your algorithm should run in O(n) complexity.
----------------------------------------------------------

int Solution::longestConsecutive(const vector<int> &A)
 {    
     unordered_set<int> hash;
    for(int i=0;i<A.size();i++)
    {
        hash.insert(A[i]);
    }
    int l=1;
    int maxl=1;
    for(int i=0;i<A.size();i++)
    {
        int j=1;
        l=1;
        if(hash.find(A[i]-1)==hash.end())
        {
            while(hash.find(A[i]+j)!=hash.end())
            {
                j++;
                l++;
            }
            if(l>maxl){
                maxl=l;
            }
        }
    }
    return maxl;
}
/////////////////////////////////////////////////////////////////////////////////////////

