Write an Efficient C Program to Reverse Bits of a Number

Input : n = 1
Output : 2147483648  
On a machine with size of unsigned
bit as 32. Reverse of 0....001 is
100....0.

Input : n = 2147483648
Output : 1  
----------------------------------------------

unsigned int reverseBits(unsigned int num) 
{ 
	unsigned int NO_OF_BITS = sizeof(num) * 8; 
	unsigned int reverse_num = 0, i, temp; 

	for (i = 0; i < NO_OF_BITS; i++) 
	{ 
		temp = (num & (1 << i)); 
		if(temp) 
			reverse_num |= (1 << ((NO_OF_BITS - 1) - i)); 
	} 

	return reverse_num; 
} 

int main() 
{ 
	unsigned int x = 2; 
	printf("%u", reverseBits(x)); 
	getchar(); 
} 

Time Complexity: O(n)
Space Complexity: O(1)
......................................................
SOLUTION 2: (OPTIMISED)

unsigned int reverseBits(unsigned int num) 
{ 
	unsigned int count = sizeof(num) * 8 - 1; 
	unsigned int reverse_num = num; 
	
	num >>= 1; 
	while(num) 
	{ 
	reverse_num <<= 1;	 
	reverse_num |= num & 1; 
	num >>= 1; 
	count--; 
	} 
	reverse_num <<= count; 
	return reverse_num; 
} 

int main() 
{ 
	unsigned int x = 1; 
	printf("%u", reverseBits(x)); 
	getchar(); 
} 

Time Complexity: O(log n)
Space Complexity: O(1)
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 
Find the duplicate in an array of N integers. 
             OR
   Find the Duplicate Number
   
   Example 1:
Input: [1,3,4,2,2]
Output: 2
Example 2:

Input: [3,1,3,4,2]
Output: 3
--------------


 class Solution {
public:
    int findDuplicate(vector<int>& nums)
    {
      for(int i=0;i<nums.size();i++)
      {
         int idx=abs(nums[i]);
         if(nums[idx]<0) return idx;
            nums[idx]=-nums[idx];
      }
        return -1;
	}
};

SOLUTION 3: (USING LOOKUP TABLE)

// CPP program to reverse bits using lookup table. 
#include<bits/stdc++.h> 
using namespace std; 

// Generate a lookup table for 32bit operating system 
// using macro 
#define R2(n)	 n,	 n + 2*64,	 n + 1*64,	 n + 3*64 
#define R4(n) R2(n), R2(n + 2*16), R2(n + 1*16), R2(n + 3*16) 
#define R6(n) R4(n), R4(n + 2*4 ), R4(n + 1*4 ), R4(n + 3*4 ) 

// Lookup table that store the reverse of each table 
unsigned int lookuptable[256] = { R6(0), R6(2), R6(1), R6(3) }; 

/* Function to reverse bits of num */
int reverseBits(unsigned int num) 
{ 
	int reverse_num = 0; 

	// Reverse and then rearrange 

				// first chunk of 8 bits from right 
	reverse_num = lookuptable[ num & 0xff ]<<24 | 

				// second chunk of 8 bits from right 
				lookuptable[ (num >> 8) & 0xff ]<<16 | 

				lookuptable[ (num >> 16 )& 0xff ]<< 8 | 
				lookuptable[ (num >>24 ) & 0xff ] ; 
	
	return reverse_num; 
} 

int main() 
{ 
	int x = 12456; 
	printf("%u", reverseBits(x));	 
	return 0; 
} 

TIME: O(1)
//////////////////////////////////////////////////////////////// 
 
Program for Binary To Decimal Conversion  
 

Examples :

Input : 111
Output : 7

Input : 1010
Output : 10

Input: 100001
Output: 33

------------------------------------------------------
#include <iostream> 
#include <string> 
using namespace std; 

int binaryToDecimal(string n) 
{ 
	string num = n; 
	int dec_value = 0; 
 
	int base = 1; 
	int len = num.length(); 
	for (int i = len - 1; i >= 0; i--) { 
		if (num[i] == '1') 
			dec_value += base; 
		base = base * 2; 
	} 

	return dec_value; 
} 

int main() 
{ 
	string num = "10101001"; 
	cout << binaryToDecimal(num) << endl; 
} 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Program for Decimal to Binary Conversion

Examples:

Input : 7
Output : 111

Input : 10
Output : 1010

Input: 33
Output: 100001
---------------------------------------------------------------------------------------
#include <iostream> 
using namespace std; 
int decToBinary(int n) 
{ 
	for (int i = 31; i >= 0; i--) { 
		int k = n >> i; 
		if (k & 1) 
			cout << "1"; 
		else
			cout << "0"; 
	} 
} 
 
int main() 
{ 
	int n = 32; 
	decToBinary(n); 
} 

Output :
00000000000000000000000000100000

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Find All Duplicates in an Array(LEETCODE)
Example:
Input:
[4,3,2,7,8,2,3,1]

Output:
[2,3]
-----------------

CASE 1: (if elements are in the range of 1 to n.)

class Solution {
public:
    vector<int> findDuplicates(vector<int>& nums) 
    {
       vector<int>vec;
        for(int i=0;i<nums.size();i++)
        {
         int idx=abs(nums[i])-1;
         if(nums[idx]<0) vec.push_back(idx+1);
            nums[idx]=-nums[idx];
        }
        return vec;
    }
};
.......................................................
CASE 2: (If all elements are in range of 0 to n-1 and return answer in sorted order).

vector<int> duplicates(int a[], int n)
{
 		for (int i = 0; i < n; i++)
		{
			int idx = a[i] % n;
			a[idx] += n;
		}

		bool flag = 0;
		vector<int>ans;

		for (int i = 0; i < n; i++)
		{
			if (a[i] / n > 1)
			{
				ans.push_back(i);
				flag = 1;
			}
		}

		if (flag == 0)
			return { -1};
		return ans;
       
}

TIME and SPACE: O(N) & O(N)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


  Multiply Strings   (LEETCODE)

  Example 1:

Input: num1 = "2", num2 = "3"
Output: "6"
Example 2:

Input: num1 = "123", num2 = "456"
Output: "56088"
----------------------------------------------------

class Solution {
public:
    string multiply(string a, string b) {
    if (a=="0" || b=="0")
        return "0";
    int m = a.size() - 1, n = b.size() - 1, carry = 0;
    string product;
    for (int i=0; i<=m+n || carry; ++i) {
        for (int j=max(0, i-n); j<=min(i, m); ++j)
            carry += (a[m-j] - '0') * (b[n-i+j] - '0');
        product += carry % 10 + '0';
        carry /= 10;
    }
    reverse(begin(product), end(product));
    return product;
    }
};

/////////////////////////////////////////////////////////////////////

   Add Binary

  Example 1:

Input: a = "11", b = "1"
Output: "100"
Example 2:

Input: a = "1010", b = "1011"
Output: "10101"
---------------------------------------------
class Solution {
public:
    string addBinary(string a, string b) {
       string s = "";
        
        int c = 0, i = a.size() - 1, j = b.size() - 1;
        while(i >= 0 || j >= 0 || c == 1)
        {
            c += i >= 0 ? a[i --] - '0' : 0;
            c += j >= 0 ? b[j --] - '0' : 0;
            s = char(c % 2 + '0') + s;
            c /= 2;
        }
        
        return s;
    }
};

////////////////////////////////////////////////////////////////////////

   Add to Array-Form of Integer

   Example 1:

Input: A = [1,2,0,0], K = 34
Output: [1,2,3,4]
Explanation: 1200 + 34 = 1234
Example 2:

Input: A = [2,7,4], K = 181
Output: [4,5,5]
Explanation: 274 + 181 = 455
Example 3:

Input: A = [2,1,5], K = 806
Output: [1,0,2,1]
Explanation: 215 + 806 = 1021
Example 4:

Input: A = [9,9,9,9,9,9,9,9,9,9], K = 1
Output: [1,0,0,0,0,0,0,0,0,0,0]
Explanation: 9999999999 + 1 = 10000000000
---------------------------------------------------------

class Solution {
public:
    vector<int> addToArrayForm(vector<int>& A, int K) {
      reverse(A.begin(), A.end());
    for (int i = 0; i < A.size(); i++) {
        A[i] += K;
        K = A[i] / 10;
        A[i] %= 10;
    }
    while (K) {
        A.push_back(K%10);
        K /= 10;
    }
    reverse(A.begin(), A.end());
    return A;
    }
};

Time Complexity: O(max(N,log K))
space: O(1)
/////////////////////////////////////////////////////////////////////////

Add two numbers represented by two arrays

	Examples :
Input : n = 3, m = 3
        a[] = { 1, 2, 3 }
        b[] = { 2, 1, 4 }
Output : 337
123 + 214 = 337

Input : n = 4, m = 3
        a[] = { 9, 5, 4, 9 }
        b[] = { 2, 1, 4 }
Output : 9763

-------------------------------------------------

#include <bits/stdc++.h> 
using namespace std; 

int calSumUtil(int a[], int b[], int n, int m) 
{ 
	int sum[n]; 
	int i = n - 1, j = m - 1, k = n - 1; 
	int carry = 0, s = 0; 

	while (j >= 0) 
	{ 
     	s = a[i] + b[j] + carry; 
		sum[k] = (s % 10); 
    	carry = s / 10; 
		k--; 
		i--; 
		j--; 
	} 

	while (i >= 0) 
	{ 
		s = a[i] + carry; 
		sum[k] = (s % 10); 
		carry = s / 10; 
		i--; 
		k--; 
	} 
	int ans = 0;  
	
	if (carry) 
		ans = 10; 

	for (int i = 0; i <= n - 1; i++) 
	{ 
		ans += sum[i]; 
		ans *= 10; 
	}
	return ans / 10; 
} 

int calSum(int a[], int b[], int n, int m) 
{ 
	if (n >= m) 
		return calSumUtil(a, b, n, m); 
	else
		return calSumUtil(b, a, m, n); 
} 

int main() 
{ 
	int a[] = { 9, 3, 9 }; 
	int b[] = { 6, 1 }; 
	int n = sizeof(a) / sizeof(a[0]); 
	int m = sizeof(b) / sizeof(b[0]); 
	cout << calSum(a, b, n, m) << endl; 
	return 0; 
} 

OUTPUT: 1000

/////////////////////////////////////////////////////////////////////////////
  Plus One

  Example 1:

Input: [1,2,3]
Output: [1,2,4]
Explanation: The array represents the integer 123.
Example 2:

Input: [4,3,2,1]
Output: [4,3,2,2]
Explanation: The array represents the integer 4321.
-----------------------------------------------------------

class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
         for(int i = digits.size() - 1;i >= 0;i--){
            if(digits[i] != 9){
                digits[i]++;
                return digits;
            }
            else
                digits[i] = 0;
        }
        digits.insert(digits.begin(),1);
        return digits;
    }
};

////////////////////////////////////////////////////////////////////////

Sum of Two Integers

Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.
Example 1:
Input: a = 1, b = 2
Output: 3

Example 2:
Input: a = -2, b = 3
Output: 1
-------------------------------------------------------------------

class Solution {
public:
    int getSum(int a, int b) {
        if (b==0) return a;
	int sum = a^b; //find sum
	int carry = (unsigned int)(a & b)<<1; //find carry
	return getSum(sum, carry);
    }
};
/////////////////////////////////////////////////////////////////////////

 Sort an array of 0’s 1’s 2’s without using extra space or sorting algo 

   Input: [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
--------------------------------

class Solution {
public:
    void sortColors(vector<int>& nums) 
    { 
      int a=0,b=0,c=0;
        for(int i=0;i<nums.size();i++)
        {
            if(nums[i]==0)a++;
            if(nums[i]==1)b++;
            if(nums[i]==2)c++;
        }
        int x=0;
        while(a--)
        {
          nums[x++]=0;
        }
         while(b--)
        {
          nums[x++]=1;
        }
         while(c--)
        {
          nums[x++]=2;
        }
        
    }
    
};
//////////////////////////////////////////////////////////////////////////////////////////

   Missing Number

   Input: [3,0,1]
Output: 2

Input: [9,6,4,2,3,5,7,0,1]
Output: 8
-------------------------------------------

class Solution {
public:
    int missingNumber(vector<int>& nums) {
       int sum=0;
        for(int i=0;i<nums.size();i++)
        {
          sum^=nums[i]^(i+1);
        }

        return sum;
    }
};
///////////////////////////////////////////////////////////////////////////////////////////////

Repeat and Missing Number Array


Input:[3 1 2 5 3] 
Output:[3, 4] 

-------------------------------------------

class Solution {
public:
    vector<int> repeatedNumber(const vector<int> &V) {
       long long sum = 0;
       long long squareSum = 0;
       long long temp;
       for (int i = 0; i < V.size(); i++) {
           temp = V[i];
           sum += temp;
           sum -= (i + 1);
           squareSum += (temp * temp);
           squareSum -= ((long long)(i + 1) * (long long)(i + 1));
       }
       // sum = A - B
       // squareSum = A^2 - B^2 = (A - B)(A + B)
       // squareSum / sum = A + B
       squareSum /= sum;

       // Now we have A + B and A - B. Lets figure out A and B now. 
       int A = (int) ((sum + squareSum) / 2);
       int B = squareSum - A;

       vector<int> ret;
       ret.push_back(A);
       ret.push_back(B);
       return ret;
    }
};
///////////////////////////////////////////////////////////////////////////////////////////////////////

Numbers With Repeated Digits

Example 1:

Input: 20
Output: 1
Explanation: The only positive number (<= 20) with at least 1 repeated digit is 11.
Example 2:

Input: 100
Output: 10
Explanation: The positive numbers (<= 100) with atleast 1 repeated digit are 11, 22, 33, 44, 55, 66, 77, 88, 99, and 100.
-------------------------------------------------------------------

class Solution {
public:
    int numDupDigitsAtMostN(int N) {
         if(N < 10) return 0;
        int k = 0;
        for(int i = N; i > 0; i /= 10)
          k++;
        
      vector<int>digit(k,0);
      int i=0,j=N;
      while(i<k)
      {
        digit[k-1-i]=j%10;
        j/=10;
        i++;
      }
      
        int noDupBaseSum = 0;
        vector<int>noDupBase(k-1,0);
        for(int i = 0; i < k - 1; i++)
        {
            
           if(i==0)
           {
            noDupBase[i]=9; 
           }
          else
          {
            noDupBase[i]=noDupBase[i-1]*(10-i);
          }
          
            noDupBaseSum += noDupBase[i];
        }
        
        int count[10] = {0};
        vector<int>noDupRes(k,0);
        bool duplicate = false;
        for(int i = 0; i < k; i++)
        {
          
           if(i==0)
           {
            noDupRes[i]=9; 
           }
           else
           {
            noDupRes[i]=noDupRes[i-1]*(10-i);
           }
          
            if(!duplicate)
            {
                int diff = 0;
                for(int j = digit[i] + 1; j < 10; j++)
                  diff += count[j] == 0;
                
                noDupRes[i] -= diff;
                count[digit[i]]++;
                if(count[digit[i]] > 1) duplicate = true;
            }
        }
        return N - (noDupBaseSum + noDupRes[k - 1]);
    }
};
///////////////////////////////////////////////////////////////////////////////////////

Find All Numbers Disappeared in an Array

Example:

Input:
[4,3,2,7,8,2,3,1]

Output:
[5,6]
-------------------------------------------------------

class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        int len = nums.size();
        for(int i=0; i<len; i++) {
            int m = abs(nums[i])-1; // index start from 0
            nums[m] = nums[m]>0 ? -nums[m] : nums[m];
        }
        vector<int> res;
        for(int i = 0; i<len; i++) {
            if(nums[i] > 0) res.push_back(i+1);
        }
        return res;
    }
};
////////////////////////////////////////////////////////////////////////////////////////////////////////

 Merge two Sorted Array without any extra space.

Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.
Note:
The number of elements initialized in nums1 and nums2 are m and n respectively.
You may assume that nums1 has enough space (size that is equal to m + n) to hold additional elements from nums2.

Example:
Input:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3
Output: [1,2,2,3,5,6]
--------------------------------------------------------

class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
       int i=0,j=0,k=0;
        i=m-1;
        j=n-1;
        k=(m+n-1);
        while(i>=0 && j>=0)
        {
            if(nums1[i]>nums2[j])
                nums1[k--]=nums1[i--];
            else
                nums1[k--]=nums2[j--];
        }
        while(j>=0)
        {
            nums1[k--]=nums2[j--];
        }
    }
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////
   Kadane’s Algorithm 
        OR
   Maximum Subarray(LEETCODE)


   Example:

Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
-----------------------------------------------------------------

class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int cs=0,ms=INT_MIN;
        for(int i=0;i<nums.size();i++)
        {
         cs=cs+nums[i];
            if(cs<nums[i])
                cs=nums[i];
            if(ms<cs)
                ms=cs;
        }
        return ms;
        
    }
};
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////


Merge Overlapping Subintervals  (O(NlogN) and O(1))
   OR
Merge Intervals

Example 1:

Input: [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].
Example 2:

Input: [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
---------------------------------------------------------------------------

class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
      
      if(!intervals.size())return {};
        vector<vector<int>>ans;
      sort(begin(intervals),end(intervals));
        ans.push_back(intervals[0]);
      
        for(int i=1;i<intervals.size();i++)
        {
          int n=ans.size();
          if(intervals[i][0]<=ans[n-1][1])
            ans[n-1][1]=max(intervals[i][1],ans[n-1][1]);
          
          else
            ans.push_back(intervals[i]);
        }
      return ans;
        
    }
};
         
    (SAME SOLUTION BUT WAY OF ASKING IS DIFFERENT) 
	    
 vector<pair<int,int>> overlappedInterval(vector<pair<int,int>> vec, int n) {
    sort(vec.begin(),vec.end());
       
    int fir=0;
        
        
    for(int i = 1; i < n; i++) {
        
        if (vec[fir].second >= vec[i].first )
            vec[fir].second = max(vec[fir].second ,vec[i].second);
        
        else {
            fir++;
            vec[fir].first = vec[i].first;
            vec[fir].second = vec[i].second;
        }
    }
    vec.erase(vec.begin()+fir+1, vec.end());
    return vec;
}	

    
//////////////////////////////////////////////////////////////////////////////////////////////

Set Matrix Zeros 

Example 1:
Input: 
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
Output: 
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]

Example 2:
Input: 
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
Output: 
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]
---------------------------------------------

class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
      int n=matrix.size();
      int m=matrix[0].size();
      int r[n];
      int c[m];
      for(int i=0;i<n;i++)
      	r[i]=1;

      for(int i=0;i<m;i++)
      	c[i]=1;
      

      for(int i=0;i<n;i++)
      {
      	for(int j=0;j<m;j++)
        {
        	if(matrix[i][j]==0)
        	{
        		r[i]=0;
                c[j]=0;
            
        	}
        }
      }

      for(int i=0;i<n;i++)
      {
        for(int j=0;j<m;j++)
        {
        	if(r[i]==0||c[j]==0)
        	{
              matrix[i][j]=0;
        	}
        }
      }
      
      
    }
};

Time Complexity : O(M×N)
Space Complexity : O(M+N)


ALTERNATE SOLUTION:

class Solution {
public:
    void setZeroes(vector<vector<int>>& mat) {
        int n = mat.size(), m = mat[0].size();
        bool col = 0;
        
        for(int i = 0; i < n; i++)
        {
            if(mat[i][0]==0)
            col=1;
            
            for(int j = 1; j < m ; j++ )
            {
               if(mat[i][j]==0)
               {
                   mat[i][0]=mat[0][j]=0;
               }
            }
        }
        
        for(int i=n-1; i>=0; i--)
        {
            for(int j=m-1; j>=1; j--)
            {
                if(mat[i][0]==0 or mat[0][j]==0)
                    mat[i][j]=0;
            }
            if(col==1)
            {
                mat[i][0]=0;
            }
        }
    }
};


Time Complexity : O(M×N)
Space Complexity : O(1)

/////////////////////////////////////////////////////////////////////////////////////////////////

Pascal Triangle 

Input: 5
Output:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
------------------------------------

class Solution {
public:
    vector<vector<int>> generate(int numRows) {
      int n=numRows;
      vector<vector<int>>a(n);
      
      for(int i=0;i<n;i++)
      {
        a[i].resize(i+1);
        a[i][0]=a[i][i]=1;
        
        for(int j=1;j<i;j++)
        {
          a[i][j]=a[i-1][j-1]+a[i-1][j];
        }
      }
        
      return a;
    }
};

TIME : O(N^2)
SPACE: O(N^2)
/////////////////////////////////////////////////////////////////////////////////////////

Pascal's Triangle II

Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal's triangle.
Note that the row index starts from 0.
Could you optimize your algorithm to use only O(k) extra space?

Example:
Input: 3
Output: [1,3,3,1]
------------------------------
#define ll unsigned long long 

class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<int>r;
        r.resize(rowIndex+1);
        r[0] = r[rowIndex] = 1;
        
        for(int i=1;i<(r.size()+1)/2;i++)
        {
            r[i]=r[rowIndex-i]=(ll) r[i-1]* (ll) (rowIndex+1-i)/i;
        }
        
        return r;
        
    }
};

TIME: O(N)
SPACE:O(k)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Next Permutation 

1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
-------------------------------
SOLUTION 1: (BRUTE FORCE)

Complexity Analysis
Time complexity : O(n!)O(n!). Total possible permutations is n!n!.
Space complexity : O(n)O(n). Since an array will be used to store the permutations.
............................

SOLUTION 2: (USING STL)
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
    
      next_permutation(nums.begin(),nums.end());
      
    }
};
...........................
ALTERNATIVE  (FULL CODE):

void swap(vector<int>&nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

void reverse( vector<int>&nums, int start) {
        int i = start, j = nums.size() - 1;
        while (i < j) {
            swap(nums, i, j);
            i++;
            j--;
        }
    }

class Solution {
public:
    void nextPermutation(vector<int>& nums) {
            int i = nums.size() - 2;
        while (i >= 0 && nums[i + 1] <= nums[i]) {
            i--;
        }
        if (i >= 0) {
            int j = nums.size() - 1;
            while (j >= 0 && nums[j] <= nums[i]) {
                j--;
            }
            swap(nums, i, j);
        }
        reverse(nums, i + 1);
    
    }
};

Complexity Analysis

Time complexity : O(n). In worst case, only two scans of the whole array are needed.
Space complexity : O(1). No extra space is used. In place replacements are done
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Inversion of Array (Using Merge Sort)













////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 Best Time to Buy and Sell Stock 1

Example 1:
Input: [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
             Not 7-1 = 6, as selling price needs to be larger than buying price.
Example 2:
Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
--------------------------------

SOLUTION 1 : (BRUTE FORCE)

class Solution {
public:
    int maxProfit(vector<int>& prices) {
        
        if(!prices.size()) return 0;
        
        int maxprofit = 0;
        for (int i = 0; i < prices.size() - 1; i++) {
            for (int j = i + 1; j < prices.size(); j++) {
                int profit = prices[j] - prices[i];
                if (profit > maxprofit)
                    maxprofit = profit;
            }
        }
        return maxprofit;
    }
};
.....................................................................

SOLUTION 2: (OPTIMISED APPROACH)

 class Solution {
public:
    int maxProfit(vector<int>& v) {
     int mp=0,mn=INT_MAX;
      int n=v.size();
      for(int i=0;i<n;i++)
      {
        mn=min(mn,v[i]);
        mp=max(mp,v[i]-mn);
      }
      return mp;
    }
};

TIME : O(N)
SPACE : O(1)
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Best Time to Buy and Sell Stock II

Example 1:
Input: [7,1,5,3,6,4]
Output: 7
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.

Example 2:
Input: [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are
             engaging multiple transactions at the same time. You must sell before buying again.

Example 3:
Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
-----------------------------------------------------

class Solution {
public:
    int maxProfit(vector<int>& v) {
        int mp=0;
        int n=v.size();
        for(int i=0;i<n-1;i++)
        {
           if(v[i]<v[i+1])
           {
               mp+=(v[i+1]-v[i]);
           }
        }
        return mp;
    }
};

TIME :O(N)
SPACE: O(1)
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

   Best Time to Buy and Sell Stock III

  Example 1:
Input: [3,3,5,0,0,3,1,4]
Output: 6
Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.
             Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.

Example 2:
Input: [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are
             engaging multiple transactions at the same time. You must sell before buying again.

Example 3:
Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
-------------------------------------------------------------------

  class Solution
{
 public:
    int maxProfit(vector<int>& prices) 
    {
       int fb=INT_MIN,fs=0,sb=INT_MIN,ss=0;
        
        for(int i=0;i<prices.size();i++)
        {
            fb=max(fb,-prices[i]);
            fs=max(fs,fb+prices[i]);
            sb=max(sb,fs-prices[i]);
            ss=max(ss,sb+prices[i]);
        }
        return ss;
    }
};

TIME :O(N)
SPACE: O(1)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

   Best Time to Buy and Sell Stock IV

  Example 1:
Input: [2,4,1], k = 2
Output: 2
Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.

Example 2:
Input: [3,2,6,5,0,3], k = 2
Output: 7
Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.
             Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.
-----------------------------------------------------

  class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
    
        int n=prices.size();
        if(n<=1 || k<=0) return 0;
        
        int profit=0;
        if(k>=(n/2))
        {
            for(int i=0;i<n-1;i++)
            {
                if(prices[i]<prices[i+1])
                profit+=(prices[i+1]-prices[i]);
            }
            return profit;
        }
        vector<int>buy(k,INT_MIN),sell(k);
        
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<k;j++)
            {
                buy[j]=max(buy[j], j==0?0-prices[i]:sell[j-1]-prices[i]);
                sell[j]=max(sell[j], buy[j]+prices[i]);
            }
        }
        return sell[k-1];
        
        
    }
};

TIME: O(nk)
SPACE: O(nk).  
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Best Time to Buy and Sell Stock with Cooldown

Example:
Input: [1,2,3,0,2]
Output: 3 
Explanation: transactions = [buy, sell, cooldown, buy, sell]
----------------------------------------------------------------

   SOLUTION 1: (using DYNAMIC PROGRAMMING) 

  class Solution {
public:
    int maxProfit(vector<int>& prices) {
     
        int n=prices.size();
        
        if(n<=1)
            return 0;
        
        if(n==2 && prices[0]<prices[1]) 
            return prices[1]-prices[0];
        
        vector<vector<int>>dp(n,vector<int>(2));
        
        dp[0][0]=0;
        dp[0][1]=-prices[0];
        dp[1][0]=max(dp[0][0],dp[0][1]+prices[1]);
        dp[1][1]=max(dp[0][1],dp[0][0]-prices[1]);
        
        for(int i=2;i<n;i++)
        {
            dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i]);
            dp[i][1]=max(dp[i-1][1],dp[i-2][0]-prices[i]);
        }
        return dp[n-1][0];
    }
};

TIME:O(N)
SPACE:O(N)
........................

  SOLUTION 2: (space optimised)

  class Solution {
public:
    int maxProfit(vector<int>& prices) {
     
        if(prices.size()<=1)return 0;
        
       int sold = 0, hold = INT_MIN, rest = 0;
    for (int i=0; i<prices.size(); ++i)
    {
        int prvSold = sold;
        sold = hold + prices[i];
        hold = max(hold, rest-prices[i]);
        rest = max(rest, prvSold);
    }
    return max(sold, rest);
    }
};

TIME:O(N)
SPACE:O(1)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Best Time to Buy and Sell Stock with Transaction Fee

 Example 1:
Input: prices = [1, 3, 2, 8, 4, 9], fee = 2
Output: 8
Explanation: The maximum profit can be achieved by:
Buying at prices[0] = 1
Selling at prices[3] = 8
Buying at prices[4] = 4
Selling at prices[5] = 9
The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
---------------------------------------------------------

class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
         int cash = 0, hold = -prices[0];
        for (int i = 1; i < prices.size(); i++) {
            cash = max(cash, hold + prices[i] - fee);
            hold = max(hold, cash - prices[i]);
        }
        return cash;
    }
};

TIME:O(N)
SPACE:O(1)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  Rotate Image  
     OR
 Rotate Matrix  



Example 1:
Given input matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

rotate the input matrix in-place such that it becomes:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]


Example 2:
Given input matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

rotate the input matrix in-place such that it becomes:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
-----------------------------------------------------------------

class Solution {
public:
    void rotate(vector<vector<int>>& v) {
        int n=v.size(),m=v[0].size();
        vector<vector<int>>a(n,vector<int>(m,0));
        
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<m;j++)
            {
                a[j][m-1-i]=v[i][j];
            }
        }
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<m;j++)
            {
                v[i][j]=a[i][j];
            }
        }
        
    }
};

TIME: O(N^2)
SPACE: O(N^2)


ALTERNATIVE SOLUTION (optimised (in terms of space, time is same in both))


class Solution {
public:
    void rotate(vector<vector<int>>& v) {
        int n=v.size();
        
        for(int i=0;i<n;i++)      //transpose
        {
            for(int j=i;j<n;j++)
            {
              int temp=v[i][j];
              v[i][j]=v[j][i];
              v[j][i]=temp;
            }
        }
        
        for(int i=0;i<n;i++)            //swap elements of each row (automatically the coloumns will reverse)
        {
          for(int j=0;j<(n/2);j++)
          {
              int temp=v[i][j];
              v[i][j]=v[i][n-1-j];
              v[i][n-1-j]=temp;
          }
        }
    }
};


TIME: O(N^2)
SPACE: O(N^2)
////////////////////////////////////////////////////////////////////////////////////////////////////


  Lexicographically next permutation in C++ (GFG)
------------------------------------------------------

#include <algorithm> 
#include <iostream> 

using namespace std; 

int main() 
{ 
	string s = { "gfg" }; 
	bool val 
		= next_permutation(s.begin(), 
						s.end()); 
	if (val == false) 
		cout << "No Word Possible"
			<< endl; 
	else
		cout << s << endl; 
	return 0; 
} 

ALTERNATIVE SOLUTION:

#include <iostream> 

using namespace std; 

void swap(char* a, char* b) 
{ 
	if (*a == *b) 
		return; 
	*a ^= *b; 
	*b ^= *a; 
	*a ^= *b; 
} 
void rev(string& s, int l, int r) 
{ 
	while (l < r) 
		swap(&s[l++], &s[r--]); 
} 

int bsearch(string& s, int l, int r, int key) 
{ 
	int index = -1; 
	while (l <= r) { 
		int mid = l + (r - l) / 2; 
		if (s[mid] <= key) 
			r = mid - 1; 
		else { 
			l = mid + 1; 
			if (index == -1 || s[index] >= s[mid]) 
				index = mid; 
		} 
	} 
	return index; 
} 

bool nextpermutation(string& s) 
{ 
	int len = s.length(), i = len - 2; 
	while (i >= 0 && s[i] >= s[i + 1]) 
		--i; 
	if (i < 0) 
		return false; 
	else { 
		int index = bsearch(s, i + 1, len - 1, s[i]); 
		swap(&s[i], &s[index]); 
		rev(s, i + 1, len - 1); 
		return true; 
	} 
} 

int main() 
{ 
	string s = { "gfg" }; 
	bool val = nextpermutation(s); 
	if (val == false) 
		cout << "No Word Possible" << endl; 
	else
		cout << s << endl; 
	return 0; 
} 

   output: ggf

   TIME : O(logN) 
   SPACE: O(N)
/////////////////////////////////////////////////////////////////////////////////////////////////////////
 
Excel Sheet Column Number

Given a column title as appear in an Excel sheet, return its corresponding column number.
For example:
    A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28 
    ...

Example 1:
Input: "A"
Output: 1

Example 2:
Input: "AB"
Output: 28

Example 3:
Input: "ZY"
Output: 701
---------------------------------
class Solution {
public:
    int titleToNumber(string s) {
      int ans=0;  
      int n=s.size();
      for(int i=0;i<n;i++)
          ans=26*ans+(s[i]-'A'+1);
       return ans;
    }
  
};
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Excel Sheet Column Title

Given a positive integer, return its corresponding column title as appear in an Excel sheet.
For example:

    1 -> A
    2 -> B
    3 -> C
    ...
    26 -> Z
    27 -> AA
    28 -> AB 
    ...

Example 1:
Input: 1
Output: "A"

Example 2:
Input: 28
Output: "AB"

Example 3:
Input: 701
Output: "ZY"
--------------------------------

class Solution {
public:
    string convertToTitle(int n) {
      string s="";
      while(n)
      {
      s=(char)((n-1)%26+'A')+s;
        n=(n-1)/26;
      }
      return s;
  }
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 Integer to English Words

Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 2^31 - 1.
Example 1:
Input: 123
Output: "One Hundred Twenty Three"

Example 2:
Input: 12345
Output: "Twelve Thousand Three Hundred Forty Five"

Example 3:
Input: 1234567
Output: "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"

Example 4:
Input: 1234567891
Output: "One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One"
-----------------------------------------

vector<pair<int, string>> nums =
{
    {1000000000, "Billion"}, {1000000, "Million"}, {1000, "Thousand"}, {100, "Hundred"},
    {90, "Ninety"},{80, "Eighty"},{70, "Seventy"},{60, "Sixty"}, 
    {50, "Fifty"}, {40, "Forty"}, {30, "Thirty"}, {20, "Twenty"},
    {19, "Nineteen"}, {18, "Eighteen"}, {17, "Seventeen"}, {16, "Sixteen"}, {15, "Fifteen"},
    {14, "Fourteen"}, {13, "Thirteen"}, {12, "Twelve"}, {11, "Eleven"}, {10, "Ten"},
    {9, "Nine"},{8, "Eight"},{7, "Seven"},{6, "Six"}, {5, "Five"}, {4, "Four"}, {3, "Three"}, {2, "Two"}, {1, "One"}
};

class Solution {
public:
    string numberToWords(int num) {
         if (num == 0) return "Zero";
  for (auto it = nums.begin(); ; ++it)
    if (num / it->first > 0)
      return (num >= 100 ? numberToWords(num / it->first) + " " : "") + it->second +
        (num % it->first == 0 ? "" : " " + numberToWords(num % it->first));
    }
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Pow(x, n)
   OR
Find n^x in log N

Example 1:
Input: 2.00000, 10
Output: 1024.00000

Example 2:
Input: 2.10000, 3
Output: 9.26100

Example 3:
Input: 2.00000, -2
Output: 0.25000
Explanation: 2-2 = 1/22 = 1/4 = 0.25
---------------------------------------

class Solution {
public:
    double myPow(double x, int n) {
      if(n==0)return 1;
        double m=myPow(x,(n/2));
       
      if(n%2==0)
        return m*m;
      else
      {
        if(n>0)
             return x*m*m;
        else
             return (m*m)/x;
      }
    }
};

TIME: O(logn)
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 Factorial Trailing Zeroes

Example 1:

Input: 3
Output: 0
Explanation: 3! = 6, no trailing zero.
Example 2:

Input: 5
Output: 1
Explanation: 5! = 120, one trailing zero.

Note: Your solution should be in logarithmic time complexity.
----------------------------------------------

class Solution {
public:
    int trailingZeroes(int n) {
      int c=0;
      while(n>0)
      {
        c+=n/5;
        n/=5;
      }
      return c;
        
      
    }
};
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Find GCD in Log N
 
--------------------------------

#include <bits/stdc++.h> 
using namespace std; 
  
int gcd(int a, int b) 
{ 
    if (a == 0) 
        return b; 
    return gcd(b % a, a); 
} 
int main() 
{ 
    int a = 10, b = 15; 
    cout << "GCD(" << a << ", " 
         << b << ") = " << gcd(a, b)  
                        << endl; 
    a = 35, b = 10; 
    cout << "GCD(" << a << ", " 
         << b << ") = " << gcd(a, b)  
                        << endl; 
    a = 31, b = 2; 
    cout << "GCD(" << a << ", " 
         << b << ") = " << gcd(a, b) << endl; 
    return 0; 
} 

GCD(10, 15) = 5
GCD(35, 10) = 5
GCD(31, 2) = 1
Time Complexity: O(Log min(a, b))

............................................
ALTERNATE SOLUTION:(Extended Euclidean Algorithm)
 (i.e. ax + by = gcd(a, b)) 


#include <bits/stdc++.h>  
using namespace std; 
int gcdExtended(int a, int b, int *x, int *y)  
{  
    if (a == 0)  
    {  
        *x = 0;  
        *y = 1;  
        return b;  
    }  
    int x1, y1;  
    int gcd = gcdExtended(b%a, a, &x1, &y1);  
    *x = y1 - (b/a) * x1;  
    *y = x1;  
  
    return gcd;  
}  
  
int main()  
{  
    int x, y, a = 35, b = 15;  
    int g = gcdExtended(a, b, &x, &y);  
    cout << "GCD(" << a << ", " << b  
         << ") = " << g << endl; 
    return 0;  
}  
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Program to find LCM of 2 numbers without using GCD

Examples:

Input: 7, 5
Output: 35

Input: 2, 6
Output: 6
----------------------------------------
#include <bits/stdc++.h> 
using namespace std; 
 
int findLCM(int a, int b) 
{ 
	int lar = max(a, b); 
	int small = min(a, b); 
	for (int i = lar; ; i += lar) { 
		if (i % small == 0) 
			return i; 
	} 
} 

int main() 
{ 
	int a = 5, b = 7; 
	cout << "LCM of " << a << " and "
		<< b << " is " << findLCM(a, b); 
	return 0; 
} 

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GCD of more than two (or array) numbers

Input  : arr[] = {1, 2, 3}
Output : 1

Input  : arr[] = {2, 4, 6, 8}
Output : 2
------------------------------

#include <bits/stdc++.h> 
using namespace std; 
  
// Function to return gcd of a and b 
int gcd(int a, int b) 
{ 
    if (a == 0) 
        return b; 
    return gcd(b % a, a); 
} 
  
// Function to find gcd of array of 
// numbers 
int findGCD(int arr[], int n) 
{ 
    int result = arr[0]; 
    for (int i = 1; i < n; i++) 
    { 
        result = gcd(arr[i], result); 
  
        if(result == 1) 
        { 
           return 1; 
        } 
    } 
    return result; 
} 
  
// Driver code 
int main() 
{ 
    int arr[] = { 2, 4, 6, 8, 16 }; 
    int n = sizeof(arr) / sizeof(arr[0]); 
    cout << findGCD(arr, n) << endl; 
    return 0; 
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  Unique path 1
    OR
 Grid Unique Paths

Example 1:
Input: m = 3, n = 2
Output: 3
Explanation:
From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -> Right -> Down
2. Right -> Down -> Right
3. Down -> Right -> Right

Example 2:
Input: m = 7, n = 3
Output: 28
----------------------------------
class Solution {
public:
    int uniquePaths(int m, int n) {
        
      vector<vector<int>>dp(m,vector<int>(n));
      
      for(int i=0;i<n;i++)
      {
         dp[0][i]=1;
      }
    
     for(int i=0;i<m;i++)
     {
        dp[i][0]=1;
     }
        
      for(int i=1;i<m;i++)
      {
        for(int j=1;j<n;j++)
        {
          dp[i][j]=dp[i-1][j]+dp[i][j-1];
        }
      }
      return dp[m-1][n-1];
    }
};

TIME: O(N*M)
SPACE: O(N*M)
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  Unique Paths II

Example 1:
Input:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
Output: 2
Explanation:
There is one obstacle in the middle of the 3x3 grid above.
There are two ways to reach the bottom-right corner:
1. Right -> Right -> Down -> Down
2. Down -> Down -> Right -> Right
------------------------------------------------------------

  SOLUTION 1: (using DYNAMIC PROGRAMMING)

  class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& v) {
        
        int m=v.size(),n=v[0].size();
        vector<vector<int>>dp(m,vector<int>(n));
        
        for(int i=0;i<n;i++)
        {
              if(v[0][i]==1)
              break;
              dp[0][i]=1;
        }
        for(int i=0;i<m;i++)
        {
              if(v[i][0]==1)
              break;
              dp[i][0]=1;
        }
        
        for(int i=1;i<m;i++)
        {
            for(int j=1;j<n;j++)
            {
                if(v[i][j]==0)
                    dp[i][j]=dp[i-1][j]+dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
};

TIME: O(N*M)
SPACE: O(N*M)
......................................

SOLUTION 2: (SPACE OPTIMISED)

 class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>&v) {
      
      int r=v.size();
      int c=v[0].size();
      
      if(v[0][0]==1)return 0;
      
      v[0][0]=1;
      
      for(int i=1;i<c;i++)
      {
        if(v[0][i]==0 && v[0][i-1]==1)
        {
          v[0][i]=1;
        }
        else
        {
          v[0][i]=0;
        }
      }
      
      for(int i=1;i<r;i++)
      {
        if(v[i][0]==0 && v[i-1][0]==1)
        {
          v[i][0]=1;
        }
        else
        {
          v[i][0]=0;
        }
      }
      
      for(int i=1;i<r;i++)
      {
        for(int j=1;j<c;j++)
        {
          if(v[i][j]==0)
          {
            v[i][j]=v[i-1][j]+v[i][j-1];
          }
          else
          {
            v[i][j]=0;
          }
        }
      }
      
      return v[r-1][c-1];
    }
};

TIME: O(N*M)
SPACE: O(1)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


 Unique Paths III

  On a 2-dimensional grid, there are 4 types of squares:
1 represents the starting square.  There is exactly one starting square.
2 represents the ending square.  There is exactly one ending square.
0 represents empty squares we can walk over.
-1 represents obstacles that we cannot walk over.
Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.

Example 1:
Input: [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
Output: 2
Explanation: We have the following two paths: 
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)

Example 2:
Input: [[1,0,0,0],[0,0,0,0],[0,0,0,2]]
Output: 4
Explanation: We have the following four paths: 
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)
2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)
3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)
4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)

Example 3:
Input: [[0,1],[2,0]]
Output: 0
Explanation: 
There is no path that walks over every empty square exactly once.
Note that the starting and ending square can be anywhere in the grid.
-----------------------------------------------------
   
  SOLUTION 1: (using DFS)

 class Solution {
 int startx,starty,endx,endy,path,m,n,ans=0;     
    
 void dfs(vector<vector<int>> grid, int i, int j, int p)
    {
        if(i<0 || i>=m || j<0 || j>=n || grid[i][j]==-1) return ;
        
        if(i==endx && j==endy && p==path)
        { 
         ans++;
         return ;
        }
        grid[i][j]=-1;
         dfs(grid, i, j+1, p+1);
         dfs(grid, i+1, j, p+1);
         dfs(grid, i, j-1, p+1);
         dfs(grid, i-1, j, p+1);
    }
    
public:
    int uniquePathsIII(vector<vector<int>>& grid) {
        
        m=grid.size(),n=grid[0].size();
        path=m*n;
        
        for(int i=0;i<m;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(grid[i][j]==1)
                {
                    startx=i;
                    starty=j;
                }
                else if(grid[i][j]==2)
                {
                    endx=i;
                    endy=j;
                }
                else if(grid[i][j]==-1)
                {
                    path--;
                }
            }
        }
        dfs(grid,startx,starty,1);
        return ans;    
    }
};

  Time Complexity: O(4^(R*C)), where R,C are the number of rows and columns in the grid.
  Space Complexity: O(R*C).

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Valid Mountain Array (LEETCODE)

Example 1:
Input: [2,1]
Output: false

Example 2:
Input: [3,5,5]
Output: false

Example 3:
Input: [0,3,2,1]
Output: true
----------------------

class Solution {
public:
    bool validMountainArray(vector<int>& a) {
        
        int n=a.size();
        
        int i=0,j=n-1;
        
        while(i+1<n && a[i]<a[i+1])i++;
        while(j>0 && a[j-1]>a[j])j--;
        
        return (i>0 && i==j && j<n-1);
        
    }
};

Time Complexity: O(N), where N is the length of A.
Space Complexity: O(1)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 Two Sum

 Example:
Given nums = [2, 7, 11, 15], target = 9,
Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
--------------------------------------

class Solution {
public:
    vector<int> twoSum(vector<int>& A, int B) {
     int n = A.size();
    vector<int> v;
    if (n < 2) {
        return v;
    }
    unordered_map<int, int> seen;
    seen.reserve(A.size());
    for (int i = 0; i < A.size(); ++i) {
        long long target = B - A[i];
        if (target < INT_MIN || target > INT_MAX) continue;
        auto it = seen.find(target);
        if (it != seen.end())
            return vector<int>{ it->second , i  };
        seen.insert(make_pair(A[i], i));
    }
    return vector<int>{};
    }
};

Time complexity : O(n). We traverse the list containing n elements only once. Each look up in the table costs only O(1) time.
Space complexity : O(n). The extra space required depends on the number of items stored in the hash table, which stores at most n elements.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 Two Sum II - Input array is sorted(LEETCODE)             (JUST UPPER WAALE KI TARAH SAME HAI BAS +1 KAR DIA INDEXES MAI RETURN KARATE TIME)

  Example:
Input: numbers = [2,7,11,15], target = 9
Output: [1,2]
Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.
-----------------------------------------------------------------------------

class Solution {
public:
    vector<int> twoSum(vector<int>& A, int B) {
         int n = A.size();
    vector<int> v;
    if (n < 2) {
        return v;
    }
    unordered_map<int, int> seen;
    seen.reserve(A.size());
    for (int i = 0; i < A.size(); ++i) {
        long long target = B - A[i];
        if (target < INT_MIN || target > INT_MAX) continue;
        auto it = seen.find(target);
        if (it != seen.end())
            return vector<int>{ it->second+1 , i+1  };
        seen.insert(make_pair(A[i], i));
    }
    return vector<int>{};
    }
};

Time complexity : O(n). We traverse the list containing n elements only once. Each look up in the table costs only O(1) time.
Space complexity : O(n). The extra space required depends on the number of items stored in the hash table, which stores at most n elements.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Two Sum Less Than K

Given an array A of integers and integer K, return the maximum S such that there exists i < j with A[i] + A[j] = S and S < K. If no i, j exist satisfying this equation, then return -1.

Example 1:
Input: A = [34,23,1,24,75,33,54,8], K = 60
Output: 58
Explanation: 
We can use 34 and 24 to sum 58 which is less than 60.

Example 2:
Input: A = [10,20,30], K = 15
Output: -1
Explanation: 
In this case it's not possible to get a pair sum less that 15.
----------------------------------------------------------------------

 class Solution {
      public:

       int twoSumLessThanK(vector<int>A, int K)
        {
          int res = -1;

          if(A == NULL || A.length == 0)
          {
              return res;
          }
          
          sort(A.begin(),A.end());

          int l = 0;
         int r  = A.length-1;
        
         while(l<r)
         {
             int sum = A[l] + A[r];
             if(sum < K)
             {
                 res = Math.max(res, sum);
                 l++;
             }
             else
             {
                 r--;
             }
         }
         return res;
     }
 }

Time Complexity: O(nlogn), n = A.length.
Space: O(1).

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Two Sum IV - Input is a BST

Example 1:
Input: 
    5
   / \
  3   6
 / \   \
2   4   7
Target = 9
Output: True

Example 2:
Input: 
    5
   / \
  3   6
 / \   \
2   4   7

Target = 28
Output: False
----------------------------------------

SOLUTION 1: (SET)

  class Solution
{
  public:
  
    bool dfs(TreeNode* root, int k, set<int>s) 
    {
        if (root == NULL) return false;
        if (s.count(k - root->val)) return true;
        s.insert(root->val);
        return dfs(root->left, k, s) || dfs(root->right, k, s);
    }    
    bool findTarget(TreeNode* root, int k) 
    {
         set<int>s;
        return dfs(root, k, s);
    }  
};

Time Complexity: O(n), Space Complexity: O(n).
....................................................

SOLUTION 2: (USING BST)

class Solution {
public:
    vector<int>vec;
    
     void inorder(TreeNode* node)
    {
        if(!node)
            return;
        inorder(node -> left);
        vec.push_back(node -> val);
        inorder(node -> right);
    }
 
    bool findTarget(TreeNode* root, int k) {
         if(!root)
            return false;
        inorder(root);
        int i = 0, j = vec.size()-1;
        while(i < j)
        {
            int sum = vec[i]+vec[j];
            if(sum == k)
                return true;
            else if(sum < k)
                i++;
            else
                j--;
        }
        return false;
    }
};

Time Complexity: O(n), Space Complexity: O(n).
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  4Sum

Example:
Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.
A solution set is:
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]

Note:
The solution set must not contain duplicate quadruplets.
----------------------------------------------------------

class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>>res;
        sort(nums.begin(),nums.end());
        int n=nums.size();
        
        for(int i=0;i<n-3;i++)
        {
            if(i>0 && nums[i]==nums[i-1])
                continue;
            
            for(int j=i+1;j<n-2;j++)
            {
                if(j>1 && nums[j]==nums[j-1] && (j-i)>1)
                    continue;
                
                int k=j+1;
                int l=n-1;
                
                while(k<l)
              {
                if(nums[i]+nums[j]+nums[k]+nums[l]==target)
                {
                    res.push_back({nums[i],nums[j],nums[k],nums[l]});
                    while(k+1<l-1 && nums[k]==nums[k+1] && nums[l-1]==nums[l])
                        k++,l--;
                    
                    k++,l--;
                }
                else if(nums[i]+nums[j]+nums[k]+nums[l]-target>0)
                {
                    l--;
                }
                else
                {
                    k++;
                }
               }
            }
        }
        return res;
    }
};

TIME: O(n^3)
SPACE: O(n).
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  4 sum II

Example:
Input:
A = [ 1, 2]
B = [-2,-1]
C = [-1, 2]
D = [ 0, 2]
Output:
2
Explanation:
The two tuples are:
1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0
-------------------------------------------------------------
 class Solution {
public:
    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {
     unordered_map<int,int>m;
        
        for(auto a: A)
        {
            for(auto b:B)
            {
                m[a+b]++;
            }
        }
        int count=0;
        for(auto c: C)
        {
            for(auto d:D)
            {
                count+=m[0-(c+d)];        //a+b+c+d=0 =>>>> a+b= -(c+d);
            }
        }
        return count;
        
    }
 };

TIME: O(n^2)
SPACE: O(n^2)
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Longest Consecutive Sequence

Example:
Input: [100, 4, 200, 1, 3, 2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
----------------------------------------------------------------------------------------------------------

SOLUTION 1: (SORTING)

class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        
        if(!nums.size()) return 0;
        sort(nums.begin(),nums.end());
        int n=nums.size(),c=1;
        int mx=INT_MIN;
        for(int i=1;i<n;i++)
        {
          if(nums[i]!=nums[i-1])
          {
            if(nums[i-1]+1==nums[i])
                c++;
            else
                mx=max(mx,c),c=1;
           }
        }
        return max(mx,c);
        
    }
};

TIME: O(nlogn)
SPACE: O(1)
...............................................

SOLUTION 2:  (SET)

class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
       if(nums.size()==0)return 0;
        
        set<int>s;
        for(int x:nums)
            s.insert(x);
        
        int mx=0,cn=0,c=0;
        for(int x: s)
        {
            if(!s.count(x-1))
            {
              cn=x;
              c=1;
                
              while(s.count(cn+1))
              {
                  cn++;
                  c++;
              }
                mx=max(mx,c);
            }
        }
        return max(mx,c);
    }
};

Time complexity: O(n).
Only one traversal is needed and the time complexity is O(n) under the assumption that hash insert and search take O(1) time.
Auxiliary space : O(n).
To store every element in set O(n) space is needed.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Length of Longest Subarray with 0 sum

--------------------------------------------

#include <bits/stdc++.h> 
using namespace std; 

int maxLen(int arr[], int n) 
{ 
	unordered_map<int, int> presum; 

	int sum = 0,max_len = 0;  
	for (int i = 0; i < n; i++) 
	{ 
		sum += arr[i]; 

		if (arr[i] == 0 && max_len == 0) 
			max_len = 1; 

		if (sum == 0) 
			max_len = i + 1; 

		if(presum.find(sum)==presum.end()) 	
		   presum[sum] = i; 
		 
		if (presum.find(sum) != presum.end()) 
		   max_len = max(max_len, i - presum[sum]); 
	} 

	return max_len; 
} 
 
int main() 
{ 
	int arr[] = { 15, -2, 2, -8, 1, 7, 10, 23 }; 
	int n = sizeof(arr) / sizeof(arr[0]); 
	cout << "Length of the longest 0 sum subarray is "
		<< maxLen(arr, n); 

	return 0; 
} 

output: 5

TIME AND SPACE: O(n)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Largest Continuous Sequence Zero Sum

Find the largest continuous sequence in a array which sums to zero.
Example:
Input:  {1 ,2 ,-2 ,4 ,-4}
Output: {2 ,-2 ,4 ,-4}
------------------------------------------------------------------------

vector<int> Solution::lszero(vector<int> &A) {
  if(A.size()==0)
        return {};
        
    vector<int>v;
    unordered_map<int,int>m;      //{prefixSum,index}
    int i,p=0,k=0,l=0;
    m.insert({0,-1});         //if first element is 0
    for(i=0;i<A.size();++i)
    {
        p+=A[i];
        if(m.find(p)!=m.end())
        {
            if(i-m[p]>l-k)
            {
                k=m[p];
                l=i;
            }
        }
        else
            m.insert({p,i});
    }
    for(i=k+1;i<=l;++i)
        v.push_back(A[i]);
    return v;
}

TIME: O(n)
SPACE: O(n)

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Length of Longest sub-array having sum k

Examples:
Input : arr[] = { 10, 5, 2, 7, 1, 9 }, k = 15
Output : 4
The sub-array is {5, 2, 7, 1}.

Input : arr[] = {-5, 8, -14, 2, 4, 12}, k = -5
Output : 5
---------------------------------------------------

#include <bits/stdc++.h>
using namespace std;
int lenOfLongSubarr(int arr[], int n, int k)
{
	unordered_map<int, int> um;
	int sum = 0, maxLen = 0;

	for (int i = 0; i < n; i++)
	{
		sum += arr[i];
		if (sum == k)
			maxLen = i + 1;

		if (um.find(sum) == um.end())
			um[sum] = i;

		if (um.find(sum - k) != um.end()) 
            maxLen = max(maxLen, i - um[sum-k]); 
	}
	return maxLen;
}

int main()
{
#ifndef ONLINE_JUDGE
	// for getting input from input.txt
	freopen("input.txt", "r", stdin);
	// for writing output to output.txt
	freopen("output.txt", "w", stdout);
#endif
	int arr[] = {10, 5, 2, 7, 1, 9};
	int n = sizeof(arr) / sizeof(arr[0]);
	int k = 15;
	cout << "Length = "
	     << lenOfLongSubarr(arr, n, k);
	return 0;
}

TIME: O(n)
SPACE: O(n)

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Count the Number of Subarrays with Sum Equals K (LEETCODE)

Example 1:
Input:nums = [1,1,1], k = 2
Output: 2
------------------------------------

class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int n = nums.size();
        if(n==0)
            return 0;
        
        unordered_map<int,int> mymap;   
        int currSUM=0, i=0, count=0;
        
        for(int i=0;i<n;i++)
        {
            currSUM += nums[i];
            
            if(currSUM == k)   
                count += 1;
            
            if(mymap.find(currSUM-k)!=mymap.end())
                count += mymap[currSUM-k];
            
            mymap[currSUM] += 1;
        }
        return count;
    }
};

TIME: O(n)
SPACE: O(n)
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Count the number of subarrays having a given XOR
------------------------------------------------------

#include <bits/stdc++.h>
using namespace std;

int main()
{
#ifndef ONLINE_JUDGE
	// for getting input from input.txt
	freopen("input.txt", "r", stdin);
	// for writing output to output.txt
	freopen("output.txt", "w", stdout);
#endif
	int n;
	cin >> n;
	int arr[n];

	for (int i = 0; i < n; i++)
		cin >> arr[i];

	int m;
	cin >> m;

	long long ans = 0;
	vector<int>xorArr(n);

	unordered_map<int, int> mp;
	xorArr[0] = arr[0];

	for (int i = 1; i < n; i++)
		xorArr[i] = xorArr[i - 1] ^ arr[i];

	for (int i = 0; i < n; i++)
	{
		int tmp = m ^ xorArr[i];
		ans = ans + ((long long)mp[tmp]);
		if (xorArr[i] == m)
			ans++;
		mp[xorArr[i]]++;
	}
	cout << "ans= " << ans;
}


Output: ans= 4

Time Complexity: O(n)
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Longest substring without repeat

Example 1:
Input: "abcabcbb"
Output: 3 
Explanation: The answer is "abc", with the length of 3.
 
Example 2:
Input: "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.

Example 3:
Input: "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3. 
             Note that the answer must be a substring, "pwke" is a subsequence and not a substring.
-------------------------------------------------------------------------------------
 
SOLUTION:1 (BRUTE FORCE)

 TIME : O(n^2) and SPACE: O(n)

...............................

SOLUTION 2: (SLIDING WINDOW ALGO)

class Solution {
public:
    int lengthOfLongestSubstring(string s) {
      if(!s.size()) return 0;
        
        int i=0,j=0,mx=0;
        int n=s.size();
        
        set<int>ms;
        
        while(j<n)
        {
            if(ms.find(s[j])==ms.end())
            {
                ms.insert(s[j]);
                j++;
                mx=max(j-i,mx);
            }
            else
            {
                ms.erase(s[i]);
                i++;
            }
        }
        return mx;
    } 
};

TIME : O(2*n)~O(n) and SPACE: O(n)
.............................................

SOLUTION 3: (SLIDING WINDOW ALGO OPTIMISED)

class Solution {
public:
    int lengthOfLongestSubstring(string s) {
      int n = s.size(), ans = 0, i=0, j=0;
        map<char, int> m; 
        
    while (j < n)
	{
		if (m.count(s[j]))
        {
           i = max(m[s[j]], i);
        }
		ans = max(ans, j - i + 1);
		m[s[j]] = j + 1;
		j++;
	}
        return ans;
    } 
};

Time complexity : O(2n)~O(n). In the worst case each character will be visited twice by i and j.

Space complexity : O(min(m,n)). Same as the previous approach. We need O(k) space for the sliding window, where k is the size of the Set. The size of the Set is upper bounded by the size of the string n and the size of the charset/alphabet m.

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Reverse a LinkedList   (RECURSIVE AND ITERATIVE APPROACH)

Input: 1->2->3->4->5->NULL
Output: 5->4->3->2->1->NULL
-------------------------------------------- 

 class Solution {
public:
    ListNode* reverseList(ListNode* head) 
    {
      
    if(!head || !head->next) return head;
    ListNode* p = reverseList(head->next);
    head->next->next = head;
    head->next = nullptr;
    return p;
    }
};

 TIME and SPACE : O(N) AND O(N)
...................
ALTERNATIVE SOLUTION

class Solution {
public:
    ListNode* reverseList(ListNode* head) 
    {
        ListNode * c,*p,*n;
 
  c=head;
  p=NULL;

  while(c!=NULL)
  {
  // save the next node
   n=c->next;
   //make the current node next to prev
   c->next=p;
    //just update prev and current
   p=c;
   c=n;
  }
  head=p;
        
        return head;
    }
};

TIME and SPACE : O(N) AND O(1)

/////////////////////////////////////////////////////////////////////////////////////////

  Middle of the Linked List

  Example 1:
Input: [1,2,3,4,5]
Output: Node 3 from this list (Serialization: [3,4,5])
The returned node has value 3.  (The judge's serialization of this node is [3,4,5]).
Note that we returned a ListNode object ans, such that:
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.

Example 2:
Input: [1,2,3,4,5,6]
Output: Node 4 from this list (Serialization: [4,5,6])
Since the list has two middle nodes with values 3 and 4, we return the second one.

-----------------------------------------
   class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode* sp=head, *fp=head;
      
        while(fp!=NULL &&fp->next!=NULL)
        {
          sp=sp->next;
          fp=fp->next->next;
        }
        
      return sp;
    }
};

TIME AND SPACE: O(N) and O(1).
//////////////////////////////////////////////////////////////////////////////////////////////////////////

 Merge Two Sorted Lists

 Input: 1->2->4, 1->3->4
Output: 1->1->2->3->4->4
-----------------------------

class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
         if(!l1) return l2;
         if(!l2) return l1;
      
        ListNode* c;
      
       if(l1->val>l2->val)
       {
         c=l2;
         c->next=mergeTwoLists(l1,l2->next);
       }
        else
       {
         c=l1;
         c->next=mergeTwoLists(l1->next,l2);
       }
      
      return c;
    }
};

TIME : O(N*M)
//////////////////////////////////////////////////////////////////////////////////////////////

  Remove Nth Node From End of List


Example:
Given linked list: 1->2->3->4->5, and n = 2.
After removing the second node from the end, the linked list becomes 1->2->3->5.


--------------------------------------------------------
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n)
    {
    if(!head || !head->next)  return NULL;
              
        auto s=head;
        auto f=head;
        
        int i=0;
        while(f->next!=NULL && i!=n){
                f=f->next;
                i++;
        }
        if(i!=n){
            head=head->next;
            return head;
        }
        while(f->next!=NULL){
            s=s->next;
            f=f->next;
        }
        s->next=s->next->next;
        return head;
    }
};

TIME AND SPACE: O(N) and O(1).
////////////////////////////////////////////////////////////////////////////////////////////////////

  Delete Node in a Linked List

  Input: head = [4,5,1,9], node = 5
Output: [4,1,9]
Explanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function

------------------------------------------------------------------------------------

class Solution {
public:
    void deleteNode(ListNode* node) {
      node->val=node->next->val;
      node->next=node->next->next;
    }
};

Time and space complexity are both O(1).


ALTERNATIVE SOLUTION: 

class Solution {
public:
    void deleteNode(ListNode* node)
    {
        ListNode* temp;
        temp=node->next;
        node->val=node->next->val;
        node->next=node->next->next;
  
    }
};
/////////////////////////////////////////////////////////////////////////////////////////////////

  Add Two Numbers as linked list

  Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 0 -> 8
Explanation: 342 + 465 = 807.

NOTE: You may assume the two numbers do not contain any leading zero, except the number 0 itself.
--------------------------------------------------

  
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        if (l1 == NULL and l2 == NULL) return NULL;
			else if (l1 == NULL) return l2; 
			else if (l2 == NULL) return l1; 

			int a = l1->val + l2->val;
			ListNode *p = new ListNode(a % 10);
			p->next = addTwoNumbers(l1->next,l2->next);
			if (a >= 10) p->next = addTwoNumbers(p->next, new ListNode(1));
			return p;
    }
};


ALTERNATIVE SOLUTION


class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
         ListNode* dummyHead = new ListNode(0);
    ListNode* p = l1; ListNode* q = l2; ListNode* curr = dummyHead;
    int carry = 0;
    while (p != nullptr || q != nullptr) {
        int x = (p != nullptr) ? p->val : 0;
        int y = (q != nullptr) ? q->val : 0;
        int sum = carry + x + y;
        carry = sum / 10;
        curr->next = new ListNode(sum % 10);
        curr = curr->next;
        if (p != nullptr) p = p->next;
        if (q != nullptr) q = q->next;
    }
    if (carry > 0) 
    {
        curr->next = new ListNode(carry);
    }
    return dummyHead->next;
    }
};

time and space : O(max(m,n)).
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Add Two Numbers as linked list II

Follow up:
What if you cannot modify the input lists? In other words, reversing the lists is not allowed.
Example:
Input: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 8 -> 0 -> 7
--------------------------------------------------------------------

class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        int n1 = 0, n2 = 0, carry = 0;
        ListNode *curr1 = l1, *curr2 = l2, *res = NULL;
        while( curr1 ){ curr1=curr1->next; n1++; }
        while( curr2 ){ curr2=curr2->next; n2++; } 
        curr1 = l1; curr2 = l2;
        while( n1 > 0 && n2 > 0){
            int sum = 0;
            if( n1 >= n2 ){ sum += curr1->val; curr1=curr1->next; n1--;}
            if( n2 > n1 ){ sum += curr2->val; curr2=curr2->next; n2--;}
            res = addToFront( sum, res );
        }
        curr1 = res; res = NULL;
        while( curr1 ){
            curr1->val += carry; carry = curr1->val/10;
            res = addToFront( curr1->val%10, res );
            curr2 = curr1; 
            curr1 = curr1->next;
            delete curr2;
        }
        if( carry ) res = addToFront( 1, res );
        return res;
    }
    ListNode* addToFront( int val, ListNode* head ){
        ListNode* temp = new ListNode(val);
        temp->next = head;
        return temp;
 
    }
};

TIME: O(n)
SPACE: O(1)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Find intersection point of Y LinkedList 

Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
Output: Reference of the node with value = 8
Input Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.
-------------------------------------------------
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        
      ListNode* aptr,*bptr;
      aptr=headA, bptr=headB;
      
      while(bptr!=aptr)
      {
        if(aptr==NULL) aptr=headB;
        else aptr=aptr->next;
        
        if(bptr==NULL) bptr=headA;
        else bptr=bptr->next;
      }
      
      return bptr;
      
    }
};

Time complexity : O(m+n)
Space complexity : O(1).
/////////////////////////////////////////////////////////////////////////////////////////////////////

   Palindrome Linked List

Example 1:

Input: 1->2
Output: false
Example 2:

Input: 1->2->2->1
Output: true
------------------------------

class Solution {
public:
    bool isPalindrome(ListNode* head) {
      
      ListNode* sp=head,*fp=head,*mid=NULL;
       
      while(fp!=NULL && fp->next!=NULL)
      {
        sp=sp->next;
        fp=fp->next->next;
      }
      
     ListNode* p=NULL, *n;
      while(sp!=NULL)
      {
        n=sp->next;
        sp->next=p;
        p=sp;
        sp=n;
      }
      
      while(p!=NULL)
      {
        if(head->val!=p->val)
        return false;
        
        head=head->next;
        p=p->next;
      }

       return true;
    }
};
//////////////////////////////////////////////////////////////////////////////////////

Reverse a LinkedList in groups. 
            OR
Reverse Nodes in k-Group

Example:
Given this linked list: 1->2->3->4->5
For k = 2, you should return: 2->1->4->3->5
For k = 3, you should return: 3->2->1->4->5
------------------------------------------------------

class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
         ListNode* p=head, *c=head, *n;
      
      int count=0;
      while(p!=NULL && count!=k)
      {
        p=p->next;
        count++;
      }
      if(count==k)
      {
         p=reverseKGroup(p,k);
        while(count>0)
        { 
          // save the next node
          n=c->next;
          //make the current node next to prev
          c->next=p;
          //just update prev and current
          p=c;
          c=n;
           count--;
        }
        head=p;  
      }
      return head;
    }
};
/////////////////////////////////////////////////////////////////////////////////////////

    Rotate List

Example 1:
Input: 1->2->3->4->5->NULL, k = 2
Output: 4->5->1->2->3->NULL
Explanation:
rotate 1 steps to the right: 5->1->2->3->4->NULL
rotate 2 steps to the right: 4->5->1->2->3->NULL

Example 2:
Input: 0->1->2->NULL, k = 4
Output: 2->0->1->NULL
Explanation:
rotate 1 steps to the right: 2->0->1->NULL
rotate 2 steps to the right: 1->2->0->NULL
rotate 3 steps to the right: 0->1->2->NULL
rotate 4 steps to the right: 2->0->1->NULL
--------------------------------------------------------

class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        
      if(!head || !head->next || k==0) return head;
      
      int len=1;
      auto f=head;
      while(f->next)
      {
        f=f->next;
        len++;
      }
      
      k=k%len;
      f->next=head;
      
      for(int i=0;i<(len-k);i++)
      {
        f=f->next;
      }
      
      head=f->next;
      f->next=NULL;
      return head;
    }
};
////////////////////////////////////////////////////////////////////////////////////////////////////

Linked List Cycle

 Example 1:

Input: head = [3,2,0,-4], pos = 1
Output: true
Explanation: There is a cycle in the linked list, where tail connects to the second node.

Example 2:

Input: head = [1,2], pos = 0
Output: true
Explanation: There is a cycle in the linked list, where tail connects to the first node.

Example 3:

Input: head = [1], pos = -1
Output: false
Explanation: There is no cycle in the linked list.
-----------------------------------------------------------------

class Solution {
public:
    bool hasCycle(ListNode *head) {
      
      if(!head || !head->next) return 0;
      
      auto s=head, f=head;
      
  
        while(f && f->next)
      {    
        s=s->next;
        f=f->next->next;
         if(f==s)return 1;
      }
      return 0;
    }
};

O(N) AND O(1)
///////////////////////////////////////////////////////////////////////////////////////////////////////

  Linked List Cycle II
         OR
  Find the starting point of the loop. 


  Example 1:
Input: head = [3,2,0,-4], pos = 1
Output: tail connects to node index 1
Explanation: There is a cycle in the linked list, where tail connects to the second node.


Example 2:
Input: head = [1,2], pos = 0
Output: tail connects to node index 0
Explanation: There is a cycle in the linked list, where tail connects to the first node.


Example 3:
Input: head = [1], pos = -1
Output: no cycle
Explanation: There is no cycle in the linked list.
--------------------------------------------------------------

  class Solution {
public:
    ListNode *detectCycle(ListNode *head) {

      auto s=head,f=head;
       while(f && f->next)
       {
         s=s->next; f=f->next->next; if(s==f) break;
       }
      
       if(!f || !f->next) return NULL;
      
       s=head;
      
       while(s!=f)
       {
         s=s->next;
         f=f->next;
       }
      return s;
    }
};

TIME: O(N)
SPACE: O(1)
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

   Remove Linked List Elements

  Input:  1->2->6->3->4->5->6, val = 6
Output: 1->2->3->4->5
------------------------------------------------------------------

class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        if (head == NULL) return NULL;
        head->next = removeElements(head->next, val);
      
       if(head->val==val)
         return head->next;
      else
        return head;
    }
};
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Remove Element

Example 1:
Given nums = [3,2,2,3], val = 3,
Your function should return length = 2, with the first two elements of nums being 2.
It doesn't matter what you leave beyond the returned length.

Example 2:
Given nums = [0,1,2,2,3,0,4,2], val = 2,
Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.
----------------------------------------------------------------------------------------------------------------

class Solution {
public:
    int removeElement(vector<int>& a, int x) {
        int j=0;
      for(int i=0;i<a.size();i++)
      {
           if(a[i]==x)continue;
           a[j++]=a[i];
      }
      return j;
    }
};

TIME: O(N)
SPACE: O(1)
........................................

ANOTHER APPROACH: (YE ZADA BHADIYA HAI)

class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
         int i = 0;
    int n = nums.size();
    while (i < n) 
    {
        if (nums[i] == val)
        {
            nums[i] = nums[n - 1];
            n--;
        } 
        else
        {
            i++;
        }
    }
    return n;
    }
};

TIME: O(N)
SPACE: O(1)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Detect and Remove Loop in a Linked List (gfg)

----------------------------------------------

#include <bits/stdc++.h> 
using namespace std; 

struct Node { 
	int key; 
	struct Node* next; 
}; 

Node* newNode(int key) 
{ 
	Node* temp = new Node; 
	temp->key = key; 
	temp->next = NULL; 
	return temp; 
} 

void printList(Node* head) 
{ 
	while (head != NULL) { 
		cout << head->key << " "; 
		head = head->next; 
	} 
	cout << endl; 
} 

void detectAndRemoveLoop(Node* head) 
{ 
	if (head == NULL || head->next == NULL) 
		return; 

	Node *slow = head, *fast = head; 

	slow = slow->next; 
	fast = fast->next->next; 

	while (fast && fast->next) 
	{ 
		if (slow == fast) 
			break; 
		slow = slow->next; 
		fast = fast->next->next; 
	} 

	if (slow == fast) { 
		slow = head; 
		while (slow->next != fast->next) { 
			slow = slow->next; 
			fast = fast->next; 
		} 

		fast->next = NULL; 
	} 
} 

int main() 
{ 
	Node* head = newNode(50); 
	head->next = head; 
	head->next = newNode(20); 
	head->next->next = newNode(15); 
	head->next->next->next = newNode(4); 
	head->next->next->next->next = newNode(10); 
	
	head->next->next->next->next->next = head->next->next; 

	detectAndRemoveLoop(head); 

	printf("Linked List after removing loop \n"); 
	printList(head); 

	return 0; 
} 
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Flattening a Linked List
      OR
 Flatten a Multilevel Doubly Linked List


Example 1:
Input: head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]
Output: [1,2,3,7,8,11,12,9,10,4,5,6]
Explanation:
After flattening the multilevel linked list it becomes:


Example 2:

Input: head = [1,2,null,3]
Output: [1,3,2]
Explanation:

The input multilevel linked list is as follows:

  1---2---NULL
  |
  3---NULL
Example 3:

Input: head = []
Output: []

---------------------------------------
class Solution 
{
public:

Node* flatten(Node* root)
{
    for (Node* h = head; h; h = h->next)
	{
		if (h->child)
		{
			Node* next = h->next;
			h->next = h->child;
			h->next->prev = h;
			h->child = NULL;
			Node* p = h->next;
			while (p->next) p = p->next;
			p->next = next;
			if (next) next->prev = p;
		}
	}
	return head;
    }
};
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Clone a linked list with next and random pointer in O(1) space

Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]
--------------------------------------------------------

class Solution {
public:
    Node* copyRandomList(Node* head) {
        if (!head)return nullptr;
        Node* curr = head, *temp;

        while (curr)
        {
            temp = curr->next;
            curr->next = new Node(curr->val);
            curr->next->next = temp;
            curr = temp;
        }
        curr = head;
        while (curr)
        {
            if (curr->next)
                curr->next->random = curr->random ? curr->random->next : curr->random;
            curr = curr->next ? curr->next->next : curr->next;
        }
        Node* original = head, *copy = head->next;
        temp = copy;
        while (original && copy)
        {
            original->next =
                original->next ? original->next->next : original->next;
            copy->next = copy->next ? copy->next->next : copy->next;
            original = original->next;
            copy = copy->next;
        }
        return temp;
    }
};


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  3Sum
  
Given array nums = [-1, 0, 1, 2, -1, -4],
A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]
---------------------------------------------

class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
      vector<vector<int>> result;
        sort(begin(nums),end(nums));
        for (int i = 0; i < nums.size(); i++) {
            if (i == 0 || nums[i] != nums[i-1]) {
                int start = i + 1, end = nums.size() - 1;
                while (start < end) {
                    int sum = nums[i] + nums[start] + nums[end];
                    if (sum == 0){
                        vector<int> tmp;
                        tmp.push_back(nums[i]);
                        tmp.push_back(nums[start]);
                        tmp.push_back(nums[end]);
                        result.push_back(tmp);
                        int startVal = nums[start];
                        int endVal = nums[end];
                        while (start < end && startVal == nums[start]) {
                            start ++;
                        }
                        while (end > start && endVal == nums[end]) {
                            end --;
                        }
                    }
                    else if (sum < 0) {
                        start ++;
                    }
                    else {
                        end --;
                    }
                }
            }
        }
        return result;
    }
};

TIME: O(n^2)

/////////////////////////////////////////////////////////////////////////////////////

Remove Duplicates from Sorted Array

Given nums = [1,1,2],
Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.

Given nums = [0,0,1,1,1,2,2,3,3,4],
Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.
-----------------------------------------------------------

class Solution {
public:
    int removeDuplicates(vector<int>& a) {
  
       if(!a.size()) return 0;
      int j=0;
      
      for(int i=1;i<a.size();i++)
      {
        if(a[j]!=a[i])
          j++;
        a[j]=a[i];
      }
      return j+1;
      
    }
};

TIME: O(N)
SPACE: O(1)
///////////////////////////////////////////////////////////////////////////////////////////////////

Max Consecutive Ones
    OR
Max continuous number of 1’s  

Example 1:
Input: [1,1,0,1,1,1]
Output: 3
Explanation: The first two digits or the last three digits are consecutive 1s.
    The maximum number of consecutive 1s is 3.
-------------------------------------------------------------------------------

class Solution {
public:
    int findMaxConsecutiveOnes(vector<int>& v) {
        int mx=0;
  
        int c=0;
        for(int i=0;i<v.size();i++)
        {
          if(v[i]==1)
          {
            c++;
            mx=max(mx,c);
          }
          else
          {
            c=0;
          }
        }
      return mx;
    }
};
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  Max Consecutive Ones II

  Example 1:

Input: [1,0,1,1,0]
Output: 4
Explanation: Flip the first zero will get the the maximum number of consecutive 1s.
    After flipping, the maximum number of consecutive 1s is 4.
--------------------------------------------------------------------
public class Solution 
{
    public int findMaxConsecutiveOnes(int[] nums)
    {
        int k = 1, low = 0, zeroCount = 0, ret = 0;
        for (int i=0; i<nums.length; i++) {
            if (nums[i] == 0)
            {
                zeroCount++;
            }
            while (zeroCount > k) 
            {
                if (nums[low] == 0)
                {
                    zeroCount--;
                }
                low++;
            }
            ret = Math.max(ret, i - low + 1);
    }
        
        return ret;
    }
}        

 Time: O(n), Space: O(n)
/////////////////////////////////////////////////////////////////////////////////////////////////////

  Max Consecutive Ones III

  Example 1:
Input: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2
Output: 6
Explanation: 
[1,1,1,0,0,1,1,1,1,1,1]
Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.

Example 2:
Input: A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3
Output: 10
Explanation: 
[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.
-----------------------------------------------------------------------

   Max Consecutive Ones III


Given an array A of 0s and 1s, we may change up to K values from 0 to 1.
Return the length of the longest (contiguous) subarray that contains only 1s. 

Example 1:

Input: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2
Output: 6
Explanation: 
[1,1,1,0,0,1,1,1,1,1,1]
Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.
Example 2:

Input: A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3
Output: 10
Explanation: 
[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.
------------------------------------------------------------------------

  class Solution {
public:
    int longestOnes(vector<int>& A, int K) {
         int i = 0, j = 0;
      while (i < A.size()) {
      K = K - ( 1 - A[i++] );
      if (K < 0) K += 1 - A[j++];
     }
      return i - j;
    }
};
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Max Continuous Series of 1s (INTERVIEWBIT)

   Input : 
Array = {1 1 0 1 1 0 0 1 1 1 } 
M = 1

Output : 
[0, 1, 2, 3, 4] 
--------------------------------------------

  vector<int> Solution::maxone(vector<int> &A, int B) {
    int idx = 0, c=0, l=0, maxi = 0;
    int p=0, q=0;
    for(int i=0; i<A.size(); i++)
    {
        if(A[i] == 0)
            c++;
        while(c>B)
        {
            if(A[l] == 0)
                c--;
            l++;
        }
        if(i-l+1>maxi)
        {
            maxi = i-l+1;
            p = l;
            q = i;
        }
    }
    vector<int> res;
    for(int i=p; i<=q; i++)
        res.push_back(i);
    return res;
}
/////////////////////////////////////////////////////////////////////////////////////////////////

 Longest Consecutive Sequence (INTERVIEWBIT)

  Example:
Given [100, 4, 200, 1, 3, 2],
The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.
Your algorithm should run in O(n) complexity.
----------------------------------------------------------

int Solution::longestConsecutive(const vector<int> &A)
 {    
     unordered_set<int> hash;
    for(int i=0;i<A.size();i++)
    {
        hash.insert(A[i]);
    }
    int l=1;
    int maxl=1;
    for(int i=0;i<A.size();i++)
    {
        int j=1;
        l=1;
        if(hash.find(A[i]-1)==hash.end())
        {
            while(hash.find(A[i]+j)!=hash.end())
            {
                j++;
                l++;
            }
            if(l>maxl){
                maxl=l;
            }
        }
    }
    return maxl;
}
/////////////////////////////////////////////////////////////////////////////////////////

  Nth root of a number using log (GFG)
-----------------------------------
#include <bits/stdc++.h> 
using namespace std;
double kthRoot(double n, int k) 
{ 
    return pow(k, 
               (1.0 / k) 
                   * (log(n) 
                      / log(k))); 
} 

int main(void) 
{ 
    double n = 81; 
    int k = 4; 
    printf("%lf ", kthRoot(n, k)); 
    return 0; 
} 

Output:
3.000000

/////////////////////////////////////////////////////////////////////////////////////////////

  Matrix Median 

  Input 1:
    A = [   [1, 3, 5],
            [2, 6, 9],
            [3, 6, 9]   ]
Output 1:  5
Explanation 1:
    A = [1, 2, 3, 3, 5, 6, 6, 9, 9]
    Median is 5. So, we return 5.

Input 2:
    A = [   [5, 17, 100]    ]
Output 2: 17
--------------------------------------------------
  
 int Solution::findMedian(vector<vector<int> > &A) {
      int n = A.size(), m = A[0].size();
    int lo = INT_MAX, hi = INT_MIN;
    for(int i=0; i<n; i++) {
        lo = min(lo, A[i][0]);
        hi = max(hi, A[i][m-1]);
    }
    int mid, res = -1;
    int desiredIndex = (n*m+1)/2;
    int currentIndex;
    while(lo <= hi) {
        mid = lo + (hi-lo)/2;
        
        currentIndex = 0;
        for(int i=0; i<n; i++) {
            currentIndex += upper_bound(A[i].begin(), A[i].end(), mid) - A[i].begin();
        }
        if(currentIndex < desiredIndex) {
            lo = mid+1;
        } else {
            res = mid;
            hi = mid-1;
        }
    }
    return res;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Find Nth positive number whose digital root is X   (GFG)   (samjh nahi aaya)


PROBLEM STATEMENT :  Given a number X ( 1<= X <= 9) and a positive number N, find the Nth positive number whose digital root is X. For example, the digital root of 65 is 2, because 6 + 5 = 11 and 1 + 1 = 2.
.......
Efficient Approach:
digitalRoot(k) = (k - 1)mod 9 +1
From this we can find the N-th number whose digital root is K as,
Nth number = (N - 1)*9 + K
--------------------------------------------------------------------------
#include <bits/stdc++.h> 
using namespace std;   
int findAnswer(int X, int N) 
{ 
    return (N - 1) * 9 + X; 
} 

int main() 
{ 
    int X = 7, N = 43; 
  
    cout << findAnswer(X, N); 
  
    return 0; 
} 

Output:
385
///////////////////////////////////////////////////////////////////////////////////////////////

  Digital Root (repeated digital sum) of the given large integer   (GFG)

 Input : num = "1234"
Output : 1
Explanation : The sum of 1+2+3+4 = 10, 
              digSum(x) == 10
              Hence ans will be 1+0 = 1

Input : num = "5674"
Output : 4 
------------------------------------------------------------

#include <iostream> 
using namespace std; 

string convertToString(int sum) 
{ 
	string str = ""; 
	while (sum) { 
		str = str + (char)((sum % 10) + '0'); 
		sum = sum / 10; 
	}  
	return str; 
} 


string GetIndividulaDigitSum(string str,int len) 
{ 
	int sum = 0; 
	for (int i = 0; i < len; i++)
    { 
		sum = sum + str[i] - '0'; 
	} 
	return convertToString(sum); 
} 

int GetDigitalRoot(string str) 
{  
	if (str.length() == 1) 
    { 
		return str[0] - '0'; 
	} 
	str = GetIndividulaDigitSum(str,str.length()); 
	return GetDigitalRoot(str); 
} 
int main() 
{ 
	string str 
		= "675987890789756545689070986776987"; 

	// Function to print final digit 
	cout << GetDigitalRoot(str); 
} 

output: 5
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

Happy Number (LEETCODE)

Example: 

Input: 19
Output: true
Explanation: 
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
----------------------------------------------------------------

  class Solution {
public:
    bool isHappy(int n) 
    {
     unordered_set<int>mset;
        int sum=0;
        while(sum!=1)
        {
              sum=0;
            while(n)
            {
                sum+=pow(n%10,2);
                n/=10;
            }
            if(mset.count(sum))
                return false;
            else
                mset.insert(sum);
                
            n=sum;
        }
        return true;
    }
};
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 Search a 2D Matrix

 Integers in each row are sorted from left to right.
The first integer of each row is greater than the last integer of the previous row.
..............
Example 1:
Input:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 3
Output: true

Example 2:
Input:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 13
Output: false
--------------------------------------------------------------

class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
   
    if (matrix.size() == 0 || matrix[0].size() == 0)
    {
        return false;
    }

    int low;
    int high;
    for (low = 0, high = matrix.size() - 1; low <= high;)
    {
        int middle = (low + high) / 2;
        if (matrix[middle][0] < target)
        {
            low = middle + 1;
        }
        else if (matrix[middle][0] > target)
        {
            high = middle - 1;
        }
        else
        {
            return true;
        }
    }

    int row = high;
    if (row >= 0)
    {
        for (low = 0, high = matrix[row].size() - 1; low <= high;)
        {
            int middle = (low + high) / 2;
            if (matrix[row][middle] < target)
            {
                low = middle + 1;
            }
            else if (matrix[row][middle] > target)
            {
                high = middle - 1;
            }
            else
            {
                return true;
            }
        }
    }

    return false;
    }
};
//////////////////////////////////////////////////////////////////////////////////////////////

 Single Element in a Sorted Array(LEETCODE)
      OR
  Find the element that appears once in sorted array, and rest element appears twice (binary search)

Example 1:
Input: nums = [1,1,2,3,3,4,4,8,8]
Output: 2

Example 2:
Input: nums = [3,3,7,7,10,11,11]
Output: 10

Follow up: Your solution should run in O(log n) time and O(1) space.
----------------------------------------------------------------------

  class Solution {
public:
    int singleNonDuplicate(vector<int>& nums) {
       
        ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
        
        int start=0, end = nums.size()-1, mid;
        
        if(end==0)                                      //  boundary conditions
          return nums[0];
        else if(nums[0]!=nums[1])
            return nums[0];
        else if(nums[end]!=nums[end-1])
            return nums[end];
                


	while( start < end ) {
		mid = start + (end-start)/2;
		if( nums[mid] == nums[mid ^ 1] )                //if((mid % 2 == 0 && nums[mid] == nums[mid + 1]) || (mid % 2 == 1 && nums[mid] == nums[mid - 1]))
	
            start = mid + 1;
		else
			end = mid;
	}
	return nums[start];
    }
};
/////////////////////////////////////////////////////////////////////////////////////////////////////

 Search in Rotated Sorted Array  (LEETCODE)


Example 1:

Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
Example 2:

Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1

//there are no duplicates in the array
----------------------------------------------------------


class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n=nums.size();
        if(n==0)
            return -1;
        int i=0;
        int j=n-1;
        int m;
        while(i<=j)
        {
            m=(i+j)/2;
            if(nums[m]==target)
                return m;
            else if(nums[0]<=nums[m])
            {
                if(target>=nums[0]&&target<=nums[m])
                    j=m-1;
                else
                    i=m+1;
            }
            else
            {
                if(target>=nums[m]&&target<=nums[n-1])
                    i=m+1;
                else
                    j=m-1;
            }
        }
        return -1;
    }
};
/////////////////////////////////////////////////////////////////////////////////////////////////

Search in Rotated Sorted Array II

Example 1:

Input: nums = [2,5,6,0,0,1,2], target = 0
Output: true
Example 2:

Input: nums = [2,5,6,0,0,1,2], target = 3
Output: false

//duplicates are there
-------------------------------------------------------------

 class Solution {
public:
    bool search(vector<int>& nums, int target) {
         int l = 0, r = nums.size() - 1;        
        while(l <= r){  
            int mid = l + (r - l) / 2;            
            if(nums[mid] == target) return true;
            if(nums[mid] > nums[r]){
                if(target > nums[mid] || target <= nums[r]) l = mid + 1;    
                else r = mid - 1;                                                               
            }else if(nums[mid] == nums[r]){
                r --;  
            }
            else{
                if(target <= nums[r] && target > nums[mid]) l = mid + 1; 
                else r = mid - 1;                                                               
            }
        }
        return false;      
    }
};
///////////////////////////////////////////////////////////////////////////////////////////////

Kth Largest Element of Two Sorted Arrays

Example 1:

Input: nums1 = [-2, -1, 3, 5, 6, 8], nums2 = [0, 1, 2, 5, 9], k = 4
Output: 5
Explanation: Union of above arrays will be [-2, -1, 0, 1, 2, 3, 5, 5, 6, 8, 9] and the 4th largest element is 5.
Example 2:

Input: nums1 = [2, 4], nums2 = [6], k = 1
Output: 6
Explanation: union of above arrays will be [2, 4, 6] and the 1st largest element is 6.

Follow-up
Can you do it in O(logk) time?
----------------------------------------------------------------------











///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

K-th Element of Two Sorted Arrays

Examples:

Input : Array 1 - 2 3 6 7 9
        Array 2 - 1 4 8 10
        k = 5
Output : 6
Explanation: The final sorted array would be -
1, 2, 3, 4, 6, 7, 8, 9, 10
The 5th element of this array is 6.
Input : Array 1 - 100 112 256 349 770
        Array 2 - 72 86 113 119 265 445 892
        k = 7
Output : 256
Explanation: Final sorted array is -
72, 86, 100, 112, 113, 119, 256, 265, 349, 445, 770, 892
7th element of this array is 256.
----------------------------------------------------------------------

Basic Approach

#include <iostream> 
using namespace std; 

int kth(int arr1[], int arr2[], int m, int n, int k) 
{ 
	int sorted1[m + n]; 
	int i = 0, j = 0, d = 0; 
	while (i < m && j < n) 
	{ 
		if (arr1[i] < arr2[j]) 
			sorted1[d++] = arr1[i++]; 
		else
			sorted1[d++] = arr2[j++]; 
	} 
	while (i < m) 
		sorted1[d++] = arr1[i++]; 
	while (j < n) 
		sorted1[d++] = arr2[j++]; 
	return sorted1[k - 1]; 
} 

int main() 
{ 
	int arr1[5] = {2, 3, 6, 7, 9}; 
	int arr2[4] = {1, 4, 8, 10}; 
	int k = 5; 
	cout << kth(arr1, arr2, 5, 4, k); 
	return 0; 
} 

OUTPUT:6

TIME: O(n)
SPACE:O(m+n).
...................................

SOLUTION 2: (SPACE OPTIMISED)

#include <bits/stdc++.h>
using namespace std;

int find(int A[], int B[], int m,
         int n, int k_req)
{
	int k = 0, i = 0, j = 0;

	// Keep taking smaller of the current
	// elements of two sorted arrays and
	// keep incrementing k
	while (i < m && j < n)
	{
		if (A[i] < B[j])
		{
			k++;
			if (k == k_req)
				return A[i];
			i++;
		}
		else
		{
			k++;
			if (k == k_req)
				return B[j];
			j++;
		}
	}

	// If array B[] is completely traversed
	while (i < m)
	{
		k++;
		if (k == k_req)
			return A[i];
		i++;
	}

	// If array A[] is completely traversed
	while (j < n)
	{
		k++;
		if (k == k_req)
			return B[j];
		j++;
	}
}
int main()
{
	int A[5] = { 2, 3, 6, 7, 9 };
	int B[4] = { 1, 4, 8, 10 };
	int k = 5;

	cout << find(A, B, 5, 4, k);

	return 0;
}
Output:
6
Time Complexity : O(k)
Auxiliary Space : O(1)
.....................................

SOLUTION 3: (more optimised (using D & C))

#include <iostream> 
using namespace std; 

int kth(int arr1[], int arr2[], int m, int n, int k, 
						int st1 = 0, int st2 = 0) 
{ 
	if (st1 == m) 
		return arr2[st2 + k - 1]; 

	if (st2 == n) 
		return arr1[st1 + k - 1]; 

	if (k == 0 || k > (m - st1) + (n - st2)) 
		return -1; 

	if (k == 1) 
		return (arr1[st1] < arr2[st2]) ? 
			arr1[st1] : arr2[st2]; 
	int curr = k / 2; 

	if (curr - 1 >= m - st1) 
	{ 
		if (arr1[m - 1] < arr2[st2 + curr - 1]) 
			return arr2[st2 + (k - (m - st1) - 1)]; 
		else
			return kth(arr1, arr2, m, n, k - curr, 
				st1, st2 + curr); 
	} 

    if (curr-1 >= n-st2) 
	{ 
		if (arr2[n - 1] < arr1[st1 + curr - 1]) 
			return arr1[st1 + (k - (n - st2) - 1)]; 
		else
			return kth(arr1, arr2, m, n, k - curr, 
				st1 + curr, st2); 
	} 
	else
	{ 
    	if (arr1[curr + st1 - 1] < arr2[curr + st2 - 1]) 
			return kth(arr1, arr2, m, n, k - curr, 
				st1 + curr, st2); 
		else
			return kth(arr1, arr2, m, n, k - curr, 
				st1, st2 + curr); 
	} 
} 

int main() 
{ 
	int arr1[5] = {2, 3, 6, 7, 9}; 
	int arr2[4] = {1, 4, 8, 10}; 

	int k = 5; 
	cout << kth(arr1, arr2, 5, 4, k); 
	return 0; 
} 

Output:
6
Time Complexity: O(log k)
Now, k can take a maximum value of m + n. This means that log k can be in the worst case, log(m + n). Logm + logn = log(mn) by properties of logarithms, and when m, n > 2, log(m + n) < log(mn).Thus this algorithm slightly outperforms the previous algorithm.

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
   Median of Two Sorted Arrays (LEETCODE)
            OR
  Media of an array     

Example 1:

nums1 = [1, 3]
nums2 = [2]

The median is 2.0
Example 2:

nums1 = [1, 2]
nums2 = [3, 4]

The median is (2 + 3)/2 = 2.5
-------------------------------------------

  class Solution {
public:
    double findMedianSortedArrays(vector<int>& A, vector<int>& B) {
 int m = nums1.size(), n = nums2.size(), l = 0, r = m;
    if (m > n) {
        return findMedianSortedArrays(nums2, nums1);
    }
    while (l <= r) {
        int i = (l + r) / 2, j = (m + n + 1) / 2 - i;
        if (i && nums1[i - 1] > nums2[j]) {
            r = i - 1;
        } else if (i < m && nums2[j - 1] > nums1[i]) {
            l = i + 1;
        } else {
            int lmax = !i ? nums2[j - 1] : (!j ? nums1[i - 1] : max(nums1[i - 1], nums2[j - 1]));
            if ((m + n) % 2) {
                return lmax;
            }
            int rmin = i == m ? nums2[j] : (j == n ? nums1[i] : min(nums1[i], nums2[j]));
            return 0.5 * (lmax + rmin);
        }
    }
    return 0.0;
    }
};

TIME : O(log(min(m,n)))
At first, the searching range is [0,m]. And the length of this searching range will be reduced by half after each loop. So, we only need log(m) loops. Since we do constant operations in each loop, so the time complexity is O(log(m)).  Since m≤n, so the time complexity is O(log(min(m,n))).

SPACE : We only need constant memory to store 9 local variables, so the space complexity is O(1).
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Day of the Week


Example 1:
Input: day = 31, month = 8, year = 2019
Output: "Saturday"

Example 2:
Input: day = 18, month = 7, year = 1999
Output: "Sunday"

Example 3:
Input: day = 15, month = 8, year = 1993
Output: "Sunday"

-------------------------------------------

  class Solution {
public:
    string dayOfTheWeek(int day, int month, int year) {
                string daysInWeek [7] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}; // 1
        int DaysByMonthMod7[12] = {0,3,2,5,0,3,5,1,4,6,2,4}; // 2
        if(month < 3) year -= 1; // 3
        return daysInWeek[(year + (year/4 - year/100 + year/400) + DaysByMonthMod7[month-1] + day) % 7]; // 4
 
    }
};
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 Kth Smallest Element in a Sorted Matrix

Example:

matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

return 13.
---------------------------------------------------

class Solution {
public:
    int kthSmallest(vector<vector<int>>& A, int B) {
         int n = A.size(), l=A[0][0], r=A[n-1][n-1];
        while(l<r)
        {
            int mn = 0, m = l+((r-l)/2);
            for(int i = 0; i < n; i++) 
                mn+=upper_bound(A[i].begin(), A[i].end(), m)-A[i].begin();
              if(mn<B)
              {
                l=m+1;
              }
              else
              {
                  r=m;
              }
        }
        return r;
    }
};


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


  Matrix Median


  Input 1:
    A = [   [1, 3, 5],
            [2, 6, 9],
            [3, 6, 9]   ]
Output 1:  5
Explanation 1:
    A = [1, 2, 3, 3, 5, 6, 6, 9, 9]
    Median is 5. So, we return 5.

Input 2:
    A = [   [5, 17, 100]    ]
Output 2: 17
--------------------------------------------------
  
 int Solution::findMedian(vector<vector<int> > &A) {
      int n = A.size(), m = A[0].size();
    int lo = INT_MAX, hi = INT_MIN;
    for(int i=0; i<n; i++) {
        lo = min(lo, A[i][0]);
        hi = max(hi, A[i][m-1]);
    }
    int mid, res = -1;
    int desiredIndex = (n*m+1)/2;
    int currentIndex;
    while(lo <= hi) {
        mid = lo + (hi-lo)/2;
        
        currentIndex = 0;
        for(int i=0; i<n; i++) {
            currentIndex += upper_bound(A[i].begin(), A[i].end(), mid) - A[i].begin();
        }
        if(currentIndex < desiredIndex) {
            lo = mid+1;
        } else {
            res = mid;
            hi = mid-1;
        }
    }
    return res;
}

We can use binary search on answer. In O(N log M), we can count how many elements are smaller than X in the matrix.
So, we use binary search on interval [1, INT_MAX]. So, total complexity is O(30 * N log M).
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  Check if a number if a power of 2 or not in O(1)    
----------------------------------------------  

 class Solution {
public:
    bool isPowerOfTwo(int n) {
    if(n<=0)return 0;
      return !(n&(n-1));
    }
};


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Given a HUGE number check if it’s a power of two.
          OR
 Check if a number if a power of 2 (FOR LARGE NUMBERS)     


EXAMPLE:

Input : 3 
Output : 0
2^0 = 1 where as k >= 1

Input : 128
Output : 1 
--------------------------------------------------------------
#include<bits/stdc++.h>
#define int long long 
using namespace std;


int real(string A)
{
    int N=10*(A[0]-'0')+A[1]-'0';
    return N/2;
}
int carry(string A)
{
    int N=10*(A[0]-'0')+A[1]-'0';
    return N%2;
}

int power(string A)
{
    int N=A.size();
    if(N==1)
    {
        if(A[0]=='2'||A[0]=='4'||A[0]=='8') return 1;
        else return 0;
    }
    if((A[N-1]-'0')%2==1) return 0;
    string ans="";
    A="0"+A;
    for(int i=1;i<N+1;i++){
        if(i==1&&A[i-1]=='0'&&(A[i]=='0'||A[i]=='1')) continue;
        string xx="";
        xx+=A[i-1];
        xx+=A[i];
        ans+=real(xx)+'0';
        A[i]=carry(xx)+'0';
    }
    return power(ans);
}

signed main() 
{ 
    string str;
    cin>>str;
    cout<<power(str);
    return 0; 
} 
///////////////////////////////////////////////////////////////////////////////////////////

Counting Bits

Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array.
Example 1:
Input: 2
Output: [0,1,1]
Example 2:

Input: 5
Output: [0,1,1,2,1,2]
----------------------------------------------------

class Solution {
public:
    vector<int> countBits(int num) {
        vector<int> ret(num+1, 0);
        for (int i = 1; i <= num; ++i)
            ret[i] = ret[i&(i-1)] + 1;
        return ret;
    }
};

TIME : O(N) and SPACE : O(N).
////////////////////////////////////////////////////////////////////////////////////////////////////////

Number of 1 Bits
    OR
Count total set bits


Example 1:
Input: 00000000000000000000000000001011
Output: 3
Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.

Example 2:
Input: 00000000000000000000000010000000
Output: 1
Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit.

Example 3:
Input: 11111111111111111111111111111101
Output: 31
Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits.

----------------------------------------------------------
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int x=__builtin_popcount(n);
        return x;
    }
};

The run time depends on the number of bits in n. Because n in this piece of code is a 32-bit integer, the time complexity is O(1).
The space complexity is O(1), since no additional space is allocated.


ALTERNATE SOLUTION

class Solution {
public:
    int hammingWeight(uint32_t n) {
        int x=0;
      
        while(n)
        {
          n=n&(n-1);
          x++;
        }
        return x;
    }
};

The run time depends on the number of 1-bits in n. In the worst case, all bits in n are 11-bits. In case of a 32-bit integer, the run time is O(1).
The space complexity is O(1), since no additional space is allocated.
//////////////////////////////////////////////////////////////////////////////////////////////////////////

Divide Two Integers
    OR
Divide Integers without / operator



Example 1:
Input: dividend = 10, divisor = 3
Output: 3
Explanation: 10/3 = truncate(3.33333..) = 3.

Example 2:
Input: dividend = 7, divisor = -3
Output: -2
Explanation: 7/-3 = truncate(-2.33333..) = -2.
--------------------------------------------------------

class Solution {
public:
    int divide(int dividend, int divisor) {
      long long sign;
      
      if((dividend<0)^(divisor<0))
         sign =-1;
       else
         sign=1;
      
       long long dvd=dividend;
       long long dvs=divisor;
      
       if(dvd==INT_MIN && dvs==-1)
         return INT_MAX;
      
       dvd=abs(dvd);
       dvs=abs(dvs);
       
      long long res=0;
      
      for(int i=31;i>=0;i--)
      {
        if(dvd>=(dvs<<i))
        {
          dvd-=(dvs<<i);
          res+=(1<<i);    
        }
      }
       return sign*res;
    }
};

//////////////////////////////////////////////////////////////////////////////////

  Subsets  (LEETCODE)
     OR
Power Set (this is very important)

PROBLEM STATEMENT: Given a set of distinct integers, nums, return all possible subsets (the power set).
Note: The solution set must not contain duplicate subsets.

Example:
Input: nums = [1,2,3]
Output:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
-----------------------------------------

class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
       int n = nums.size(), p = 1 << n;
        vector<vector<int>> subs(p);
        for (int i = 0; i < p; i++) {
            for (int j = 0; j < n; j++) {
                if ((i >> j) & 1) {
                    subs[i].push_back(nums[j]);
                }
            }
        }
        return subs;
    }
};

Time complexity: O(N * 2^N) to generate all subsets and then copy them into output list.
Space complexity: O(N* 2^N) to keep all the subsets of length N, since each of N elements could be present or absent.
//////////////////////////////////////////////////////////////////////////////////////////////

   Subsets II  (LEETCODE)

PROBLEM STATEMENT: Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).
Note: The solution set must not contain duplicate subsets.

Example:

Input: [1,2,2]
Output:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
---------------------------------------------------------------

  class Solution {
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        vector<vector<int>> dp;
        
        sort(nums.begin(), nums.end());

        dp.push_back({});

        for (auto i = 0; i < nums.size(); i++) {
            auto size = dp.size();

            for (auto j = 0; j < size; j++) {
                auto v = dp[j];
                bool found = false;

                v.push_back(nums[i]);
                for (auto k = 0; k < dp.size(); k++)
                    if (v == dp[k]) {
                        found = true;
                        break;
                    }

                if (!found)
                    dp.push_back(v);
            }
        }
        return dp;
    }
};
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Find most significant set bit of a number

Examples:

Input : 10
Output : 8
Binary representation of 10 is 1010
The most significant bit corresponds
to decimal number 8.

Input : 18
Output : 16

----------------------------------------------------------------
#include <iostream> 
using namespace std; 

int setBitNumber(int n) 
{ 
   
    n |= n >> 1; 
    n |= n >> 2; 
    n |= n >> 4; 
    n |= n >> 8; 
    n |= n >> 16; 
    n = n + 1; 
    return (n >> 1); 
} 

int main() 
{ 
    int n = 273; 
    cout << setBitNumber(n); 
    return 0; 
} 

OUTPUT: 256
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

 Find square of a number without using multiplication or division operators.

---------------------------------------------------------------------------------

SOLUTION 1 : (ADD ODD (INTUITIVE))

#include <iostream>
using namespace std;

int findSquare(int num)
{
	int odd = 1;
	int sq = 0;

	// convert number to positive if it is negative
	num = abs(num);

	// add odd numbers num times to result
	while (num--)
	{
		sq = sq + odd;
		odd = odd + 2;
	}

	return sq;
}

int main()
{
	cout << findSquare(8) << " " << findSquare(-4);

	return 0;
}
..................................................
ALTERNATE SOLUTION : (USING BITMASKING)

  #include <iostream>
using namespace std;

int findSquare(int num)
{
	// base case
	if (num < 2)
		return num;

	// convert number to positive if it is negative
	num = abs(num);

	// drop last bit from num (divide it by 2)
	int i = num >> 1;

	// if num is odd
	if (num & 1)
		return ((findSquare(i) << 2) + (i << 2) + 1);

	// if num is even
	else
		return (findSquare(i) << 2);
}

int main()
{
	cout << findSquare(8);

	return 0;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

Implement Stack using array

---------------------------------

#include <iostream>
using namespace std;
#define MAX_SIZE 101 

class Stack
{
private:
  int A[MAX_SIZE];  // array to store the stack
    int top;   // variable to mark the top index of stack. 
public:
    // constructor
    Stack()
    {
        top = -1; // for empty array, set top = -1
    }

    // Push operation to insert an element on top of stack. 
    void Push(int x) 
    {
      if(top == MAX_SIZE -1) { // overflow case. 
            printf("Error: stack overflow\n");
            return;
        }
        A[++top] = x;
    }
 
    // Pop operation to remove an element from top of stack.
    void Pop() 
    {
        if(top == -1) { // If stack is empty, pop should throw error. 
            printf("Error: No element to pop\n");
            return;
        }
        top--;
    }
 
    // Top operation to return element at top of stack. 
    int Top() 
    {
        return A[top];
    }
 
    // This function will return 1 (true) if stack is empty, 0 (false) otherwise
    int IsEmpty()
    {
        if(top == -1) return 1;
        return 0;
    }

    // ONLY FOR TESTING - NOT A VALID OPERATION WITH STACK 
    // This function is just to test the implementation of stack. 
    // This will print all the elements in the stack at any stage. 
    void Print() {
        int i;
        printf("Stack: ");
        for(i = 0;i<=top;i++)
            printf("%d ",A[i]);
        printf("\n");
    }
};

int main()
{
    // Code to test the implementation. 
    // calling Print() after each push or pop to see the state of stack. 
    Stack S;
    S.Push(2);S.Print();
    S.Push(5);S.Print();
    S.Push(10);S.Print();
    S.Pop();S.Print();
    S.Push(12);S.Print();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Implement Stack using linked list

..........................................

#include <iostream>
using namespace std;
#define MAX_SIZE 101 

struct node
{
    int data;
    struct node *next;
};
typedef struct node node;

node *top;

void initialize()
{
    top = NULL;
}

void push(int value)
{
    node *tmp;
    tmp = malloc(sizeof(node));
    tmp -> data = value;
    tmp -> next = top;
    top = tmp;
}

int pop()
{
    node *tmp;
    int n;
    tmp = top;
    n = tmp->data;
    top = top->next;
    free(tmp);
    return n;
}

int Top()
{
    return top->data;
}

int isempty()
{
    return top==NULL;
}

void display(node *head)
{
    if(head == NULL)
    {
        printf("NULL\n");
    }
    else
    {
        printf("%d\n", head -> data);
        display(head->next);
    }
}

int main()
{
    initialize();
    push(10);
    push(20);
    push(30);
    printf("The top is %d\n",Top());
    pop();
    printf("The top after pop is %d\n",Top());
    display(top);
    return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Implement Stack using Queues

--------------------------------------------------

/* Program to implement a stack 
using two queue */
#include <bits/stdc++.h> 
using namespace std; 

class Stack { 
	queue<int> q1, q2; 
	int curr_size; 

public: 
	Stack() 
	{ 
		curr_size = 0; 
	} 

	void pop() 
	{ 
		if (q1.empty()) 
			return; 

		// Leave one element in q1 and 
		// push others in q2. 
		while (q1.size() != 1) { 
			q2.push(q1.front()); 
			q1.pop(); 
		} 

		// Pop the only left element 
		// from q1 
		q1.pop(); 
		curr_size--; 

		// swap the names of two queues 
		queue<int> q = q1; 
		q1 = q2; 
		q2 = q; 
	} 

	void push(int x) 
	{ 
		q1.push(x); 
		curr_size++; 
	} 

	int top() 
	{ 
		if (q1.empty()) 
			return -1; 

		while (q1.size() != 1) { 
			q2.push(q1.front()); 
			q1.pop(); 
		} 

		// last pushed element 
		int temp = q1.front(); 

		// to empty the auxiliary queue after 
		// last operation 
		q1.pop(); 

		// push last element to q2 
		q2.push(temp); 

		// swap the two queues names 
		queue<int> q = q1; 
		q1 = q2; 
		q2 = q; 
		return temp; 
	} 

	int size() 
	{ 
		return curr_size; 
	} 
}; 

int main() 
{ 
	Stack s; 
	s.push(1); 
	s.push(2); 
	s.push(3); 
	s.push(4); 

	cout << "current size: " << s.size() 
		<< endl; 
	cout << s.top() << endl; 
	s.pop(); 
	cout << s.top() << endl; 
	s.pop(); 
	cout << s.top() << endl; 
	cout << "current size: " << s.size() 
		<< endl; 
	return 0; 
} 

current size: 4
4
3
2
current size: 2


Version A (efficient push):
push:
enqueue in queue1
pop:
while size of queue1 is bigger than 1, pipe dequeued items from queue1 into queue2
dequeue and return the last item of queue1, then switch the names of queue1 and queue2
..................................................
ALTERNATE SOLUTION:

/* Program to implement a stack using 
two queue */
#include <bits/stdc++.h> 

using namespace std; 

class Stack { 
	// Two inbuilt queues 
	queue<int> q1, q2; 

	// To maintain current number of 
	// elements 
	int curr_size; 

public: 
	Stack() 
	{ 
		curr_size = 0; 
	} 

	void push(int x) 
	{ 
		curr_size++; 

		// Push x first in empty q2 
		q2.push(x); 

		// Push all the remaining 
		// elements in q1 to q2. 
		while (!q1.empty()) { 
			q2.push(q1.front()); 
			q1.pop(); 
		} 

		// swap the names of two queues 
		queue<int> q = q1; 
		q1 = q2; 
		q2 = q; 
	} 

	void pop() 
	{ 

		// if no elements are there in q1 
		if (q1.empty()) 
			return; 
		q1.pop(); 
		curr_size--; 
	} 

	int top() 
	{ 
		if (q1.empty()) 
			return -1; 
		return q1.front(); 
	} 

	int size() 
	{ 
		return curr_size; 
	} 
}; 

int main() 
{ 
	Stack s; 
	s.push(1); 
	s.push(2); 
	s.push(3); 

	cout << "current size: " << s.size() 
		<< endl; 
	cout << s.top() << endl; 
	s.pop(); 
	cout << s.top() << endl; 
	s.pop(); 
	cout << s.top() << endl; 

	cout << "current size: " << s.size() 
		<< endl; 
	return 0; 
} 

current size: 3
3
2
1
current size: 1


Version B (efficient pop):
push:
enqueue in queue2
enqueue all items of queue1 in queue2, then switch the names of queue1 and queue2
pop:
deqeue from queue1
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Implement queue using array
---------------------------------------

/* Queue - Circular Array implementation in C++*/
#include<iostream>
using namespace std; 
#define MAX_SIZE 101  //maximum size of the array that will store Queue. 

// Creating a class named Queue.
class Queue
{
private:
	int A[MAX_SIZE];
	int front, rear; 
public:
	// Constructor - set front and rear as -1. 
	// We are assuming that for an empty Queue, both front and rear will be -1.
	Queue()
	{
		front = -1; 
		rear = -1;
	}

	// To check wheter Queue is empty or not
	bool IsEmpty()
	{
		return (front == -1 && rear == -1); 
	}

	// To check whether Queue is full or not
	bool IsFull()
	{
		return (rear+1)%MAX_SIZE == front ? true : false;
	}

	// Inserts an element in queue at rear end
	void Enqueue(int x)
	{
		cout<<"Enqueuing "<<x<<" \n";
		if(IsFull())
		{
			cout<<"Error: Queue is Full\n";
			return;
		}
		if (IsEmpty())
		{ 
			front = rear = 0; 
		}
		else
		{
		    rear = (rear+1)%MAX_SIZE;
		}
		A[rear] = x;
	}

	// Removes an element in Queue from front end. 
	void Dequeue()
	{
		cout<<"Dequeuing \n";
		if(IsEmpty())
		{
			cout<<"Error: Queue is Empty\n";
			return;
		}
		else if(front == rear ) 
		{
			rear = front = -1;
		}
		else
		{
			front = (front+1)%MAX_SIZE;
		}
	}
	// Returns element at front of queue. 
	int Front()
	{
		if(front == -1)
		{
			cout<<"Error: cannot return front from empty queue\n";
			return -1; 
		}
		return A[front];
	}
	/* 
	   Printing the elements in queue from front to rear. 
	   This function is only to test the code. 
	   This is not a standard function for Queue implementation. 
	*/
	void Print()
	{
		// Finding number of elements in queue  
		int count = (rear+MAX_SIZE-front)%MAX_SIZE + 1;
		cout<<"Queue       : ";
		for(int i = 0; i <count; i++)
		{
			int index = (front+i) % MAX_SIZE; // Index of element while travesing circularly from front
			cout<<A[index]<<" ";
		}
		cout<<"\n\n";
	}
};

int main()
{
	/*Driver Code to test the implementation
	  Printing the elements in Queue after each Enqueue or Dequeue 
	*/
   Queue Q; // creating an instance of Queue. 
   Q.Enqueue(2);  Q.Print();  
   Q.Enqueue(4);  Q.Print();  
   Q.Enqueue(6);  Q.Print();
   Q.Dequeue();	  Q.Print();
   Q.Enqueue(8);  Q.Print();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////

Implement queue using Linked list

--------------------------------------------------------

#include<stdio.h>
#include<stdlib.h>

struct Node {
	int data;
	struct Node* next;
};

// Two glboal variables to store address of front and rear nodes. 
struct Node* front = NULL;
struct Node* rear = NULL;

// To Enqueue an integer
void Enqueue(int x) {
	struct Node* temp = 
		(struct Node*)malloc(sizeof(struct Node));
	temp->data =x; 
	temp->next = NULL;
	if(front == NULL && rear == NULL){
		front = rear = temp;
		return;
	}
	rear->next = temp;
	rear = temp;
}

// To Dequeue an integer.
void Dequeue() {
	struct Node* temp = front;
	if(front == NULL) {
		printf("Queue is Empty\n");
		return;
	}
	if(front == rear) {
		front = rear = NULL;
	}
	else {
		front = front->next;
	}
	free(temp);
}

int Front() {
	if(front == NULL) {
		printf("Queue is empty\n");
		return;
	}
	return front->data;
}

void Print() {
	struct Node* temp = front;
	while(temp != NULL) {
		printf("%d ",temp->data);
		temp = temp->next;
	}
	printf("\n");
}

int main(){
	/* Drive code to test the implementation. */
	// Printing elements in Queue after each Enqueue or Dequeue 
	Enqueue(2); Print(); 
	Enqueue(4); Print();
	Enqueue(6); Print();
	Dequeue();  Print();
	Enqueue(8); Print();
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

Implement Queue using Stack

--------------------------------------------------------

USING TWO STACKS

#include <iostream>
#include <stack>
#include <algorithm>
#include <cstdlib>
using namespace std;

// Implement Queue using two stacks
class Queue {
	stack<int> s1, s2;

public:
	// Enqueue an item to the queue
	void enqueue(int data)
	{
		// Push item into the first stack
		s1.push(data);
	}

	// Dequeue an item from the queue
	int dequeue()
	{
		// if both stacks are empty
		if (s1.empty() && s2.empty()) {
			cout << "Underflow!!";
			exit(0);
		}

		// if second stack is empty, move elements from first stack to it
		if (s2.empty()) {
			while (!s1.empty()) {
				s2.push(s1.top());
				s1.pop();
			}
			// or make call to swap(s1, s2)
		}

		// return the top item from the second stack
		int top = s2.top();
		s2.pop();
		return top;
	}
};

int main()
{
	int keys[] = { 1, 2, 3, 4, 5 };
	Queue q;

	// insert above keys
	for (int key : keys) {
		q.enqueue(key);
	}

	cout << q.dequeue() << '\n';	// print 1
	cout << q.dequeue() << '\n';	// print 2

	return 0;
}

.....................................................................
ALTERNATIVE SOLUTION: (IMPLEMENT ONE STACK WITH RECURSIVE CALL STACK)


#include <iostream>
#include <stack>
#include <cstdlib>
using namespace std;

// Implement Queue using single stack
class Queue {
	stack<int> s;

public:
	// Enqueue an item to the queue
	void enqueue(int data)
	{
		// Push item into the first stack
		s.push(data);
	}

	// Dequeue an item from the queue
	int dequeue()
	{
		// if stack is empty
		if (s.empty()) {
			cout << "Underflow!!";
			exit(0);
		}

		// pop an item from the stack
		int top = s.top();
		s.pop();

		// if stack becomes empty, return the popped item
		if (s.empty()) {
			return top;
		}

		// recur
		int item = dequeue();

		// push popped item back to the stack
		s.push(top);

		// return the result of dequeue() call
		return item;
	}
};

int main()
{
	int keys[] = { 1, 2, 3, 4, 5 };
	Queue q;

	// insert above keys into the queue
	for (int key : keys) {
		q.enqueue(key);
	}

	cout << q.dequeue() << '\n';	// print 1
	cout << q.dequeue() << '\n';	// print 2

	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Check for balanced parentheses

---------------------------------------------------------------------

#include<iostream>
#include<stack>
#include<string>
using namespace std;
// Function to check whether two characters are opening 
// and closing of same type. 
bool ArePair(char opening,char closing)
{
	if(opening == '(' && closing == ')') return true;
	else if(opening == '{' && closing == '}') return true;
	else if(opening == '[' && closing == ']') return true;
	return false;
}
bool AreParanthesesBalanced(string exp)
{
	stack<char>  S;
	for(int i =0;i<exp.length();i++)
	{
		if(exp[i] == '(' || exp[i] == '{' || exp[i] == '[')
			S.push(exp[i]);
		else if(exp[i] == ')' || exp[i] == '}' || exp[i] == ']')
		{
			if(S.empty() || !ArePair(S.top(),exp[i]))
				return false;
			else
				S.pop();
		}
	}
	return S.empty() ? true:false;
}

int main()
{
	/*Code to test the function AreParanthesesBalanced*/
	string expression;
	cout<<"Enter an expression:  "; // input expression from STDIN/Console
	cin>>expression;
	if(AreParanthesesBalanced(expression))
		cout<<"Balanced\n";
	else
		cout<<"Not Balanced\n";
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Next Greater Element
--------------------------------------------------------------------------------

#include <bits/stdc++.h> 
using namespace std; 

void printNGE(int arr[], int n) 
{ 
 stack < int > s; 

s.push(arr[0]); 

for (int i = 1; i < n; i++)
 { 

    if (s.empty()) { 
    s.push(arr[i]); 
    continue; 
    } 

    
    while (s.empty() == false && s.top() < arr[i]) 
    {        
        cout << s.top() << " --> " << arr[i] << endl; 
        s.pop(); 
    } 

   
    s.push(arr[i]); 
} 

while (s.empty() == false) 
  { 
    cout << s.top() << " --> " << -1 << endl; 
    s.pop(); 
  } 
} 


int main() { 
int arr[] = {11, 13, 21, 3}; 
int n = sizeof(arr) / sizeof(arr[0]); 
printNGE(arr, n); 
return 0; 
}

TIME : O(N)
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Next Smaller Element
----------------------------------------------------------

#include <bits/stdc++.h> 
using namespace std; 

void printNSE(int arr[], int n) 
{ 
    stack<int> s; 

        s.push(arr[0]); 

    for (int i = 1; i < n; i++)
     { 
        if (s.empty())
        { 
            s.push(arr[i]); 
            continue; 
        } 

       while (s.empty() == false && s.top() > arr[i]) 
        { 
            cout << s.top() << " --> " << arr[i] << endl; 
            s.pop(); 
        } 

        s.push(arr[i]); 
    } 

    while (s.empty() == false) 
    { 
        cout << s.top() << " --> " << -1 << endl; 
        s.pop(); 
    } 
} 

int main() 
{ 
    int arr[] = { 11, 13, 21, 3 }; 
    int n = sizeof(arr) / sizeof(arr[0]); 
    printNSE(arr, n); 
    return 0; 
}

TIME : O(N)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Largest Rectangle in Histogram

Example:
Input: [2,1,5,6,2,3]
Output: 10
------------------------------------------------------------------------------

 SOLUTION 1: (BRUTE FORCE)
  TIME:O(n)
.......................


SOLUTION 2: (using STACK)

class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        if(heights.size()==0) return 0;
        if(heights.size()==1) return heights[0];
        
        int mx=0;
        stack<int>s;
        s.push(0);
        for(int i=1;i<heights.size();i++)
        {
            int curr=heights[i];
            if(curr>=heights[s.top()])
            {
                s.push(i);
            }
            else
            {
              while(!s.empty() && curr<heights[s.top()])
              {
                  int temp=heights[s.top()];
                  s.pop();
                  if(s.empty())
                  {
                      mx=max(mx,temp*i);
                  }
                  else
                  {
                      mx=max(mx,temp*(i-s.top()-1));
                  }
              }
                s.push(i);
            }
        }
        if(!s.empty())
        {
            int i=heights.size();
            while(!s.empty())
            {
                int temp=heights[s.top()];
                s.pop();
                if(s.empty())
                  mx=max(mx,temp*i);
                else
                  mx=max(mx,temp*(i-s.top()-1));
            }
        }
        return mx;
    }
};

TIME:O(n)
SPACE: O(n)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Maximal Rectangle

 Example:

Input:
[
  ["1","0","1","0","0"],
  ["1","0","1","1","1"],
  ["1","1","1","1","1"],
  ["1","0","0","1","0"]
]
Output: 6
--------------------------------------------------------------------------------------
  class Solution {
    
    int largestRectangleArea(vector<int>& heights) {
        if(heights.size()==0) return 0;
        if(heights.size()==1) return heights[0];
        
        int mx=0;
        stack<int>s;
        s.push(0);
        for(int i=1;i<heights.size();i++)
        {
            int curr=heights[i];
            if(curr>=heights[s.top()])
            {
                s.push(i);
            }
            else
            {
              while(!s.empty() && curr<heights[s.top()])
              {
                  int temp=heights[s.top()];
                  s.pop();
                  if(s.empty())
                  {
                      mx=max(mx,temp*i);
                  }
                  else
                  {
                      mx=max(mx,temp*(i-s.top()-1));
                  }
              }
                s.push(i);
            }
        }
        if(!s.empty())
        {
            int i=heights.size();
            while(!s.empty())
            {
                int temp=heights[s.top()];
                s.pop();
                if(s.empty())
                  mx=max(mx,temp*i);
                else
                  mx=max(mx,temp*(i-s.top()-1));
            }
        }
        return mx;
    }
    
    
public:
    int maximalRectangle(vector<vector<char>>& matrix) {
     
        if(matrix.size()==0)return 0;
        
        int mx=0;
        vector<int>v(matrix[0].size());
        for(int i=0;i<matrix.size();i++)
        {
            for(int j=0;j<matrix[0].size();j++)
            {
                if(matrix[i][j]=='0')
                    v[j]=0;
                else
                    v[j]+=1;
            }
            mx=max(mx,largestRectangleArea(v));
        }
        return mx;
    }
    
};

TIME:O(n*m), where n and m are rows and coloumns respectively.
SPACE: O(m), where m is number of coloumns.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 Maximal Square (LEETCODE)

 Example:
Input: 
1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0
Output: 4
-----------------------------------------------------------

  SOLUTION 1: (USING BRUTE FORCE)

  class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        int rows=matrix.size();
        int cols=0;
        
        if(rows>0)
        {
            cols=matrix[0].size();
        }        
        int mx = 0;
        for (int i = 0; i < rows; i++)
        {
            for (int j = 0; j < cols; j++)
            {
                if (matrix[i][j] == '1') 
                {
                    int sqlen = 1;
                    bool flag = true;
                    while (sqlen + i < rows && sqlen + j < cols && flag)
                    {
                        for (int k = j; k <= sqlen + j; k++)
                        {
                            if (matrix[i + sqlen][k] == '0') 
                            {
                                flag = false;
                                break;
                            }
                        }
                        for (int k = i; k <= sqlen + i; k++) 
                        {
                            if (matrix[k][j + sqlen] == '0') 
                            {
                                flag = false;
                                break;
                            }
                        }
                        if (flag)
                            sqlen++;
                    }
                    if (mx < sqlen) 
                    {
                        mx = sqlen;
                    }
                }
            }
        }
        return mx * mx;
    }
};

Time complexity : O((mn)^2).In worst case, we need to traverse the complete matrix for every 1.
Space complexity : O(1). No extra space is used.

......................................................

  SOLUTION 2: (USING DYNAMMIC PROGRAMMING)

   class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        int row=matrix.size();
        int col=0;
        
        if(row>0)
        {
            col=matrix[0].size();
        }
        
        vector<vector<int>>dp(row+1, vector<int>(col+1));
        
        int mx=0;
        
        for(int i=1;i<=row;i++)
        {
            for(int j=1;j<=col;j++)
            {
              if(matrix[i-1][j-1]=='1')    
              {
                 dp[i][j]=min({ dp[i][j-1], dp[i-1][j], dp[i-1][j-1] }) + 1;
                 mx=max(mx,dp[i][j]);
              }
          }
        }
      return mx*mx;
    }
};

Time complexity : O(mn). Single pass.
Space complexity : O(mn). Another matrix of same size is used for dp.
...................................................................

 SOLUTION 3: (MORE OPTIMISED DYNAMMIC PROGRAMMING)

  class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        int row=matrix.size();
        int col=0;
        
        if(row>0)
        {
            col=matrix[0].size();
        }
        
        vector<int>dp(col+1);
        
        int mx=0,prev=0;
        
        for(int i=1;i<=row;i++)
        {
            for(int j=1;j<=col;j++)
            {
                int temp=dp[j];
              if(matrix[i-1][j-1]=='1')    
              {
                    dp[j]=min({ dp[j-1], prev, dp[j] }) + 1;
                 mx=max(mx,dp[j]);
              }
            else
              {
                dp[j]=0;
              }
            prev=temp;
          }
        }
      return mx*mx;
    }
};

Complexity Analysis
Time complexity : O(mn). Single pass.
Space complexity : O(n). Another array which stores elements in a row is used for dp.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Sliding Window Maximum (Maximum of all subarrays of size k)

 Examples :

Input: arr[] = {1, 2, 3, 1, 4, 5, 2, 3, 6}, K = 3 
Output: 3 3 4 5 5 5 6
Explanation: 
Maximum of 1, 2, 3 is 3
Maximum of 2, 3, 1 is 3
Maximum of 3, 1, 4 is 4
Maximum of 1, 4, 5 is 5
Maximum of 4, 5, 2 is 5 
Maximum of 5, 2, 3 is 5
Maximum of 2, 3, 6 is 6

Input: arr[] = {8, 5, 10, 7, 9, 4, 15, 12, 90, 13}, K = 4 
Output: 10 10 10 15 15 90 90
Explanation:
Maximum of first 4 elements is 10, similarly for next 4 
elements (i.e from index 1 to 4) is 10, So the sequence 
generated is 10 10 10 15 15 90 90
-----------------------------------------------------------

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 Min Stack

 Example 1:
Input
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

Output
[null,null,null,null,-3,null,0,-2]

Explanation
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin(); // return -3
minStack.pop();
minStack.top();    // return 0
minStack.getMin(); // return -2
------------------------------------------------------
 
SOLUTION 1: (LEETCODE WAALA SOLUTION CLASS WAALE TAREEKE SE)

class MinStack {
public:
    
    stack<int> s1, s2;

    MinStack() {
         stack<int> t1, t2;
    s1 = t1;
    s2 = t2;
    }
    
    void push(int x) {
         s1.push(x);
    if (s2.empty()) s2.push(x);
    else {
        if (s2.top() >= x) s2.push(x);
        else s2.push(s2.top());
    }
    }
    
    void pop() {
         if (!s1.empty()){
        int val = s1.top();
        s1.pop();
        s2.pop();
    }
    }
    
    int top() {
         if (!s1.empty()) return s1.top();
         else return -1;
    }
    
    int getMin() {
          if (!s2.empty()) return s2.top();
    else return -1;
    }
};

pop() becomes a little trickier in such a case.
You only pop() from the min stack if the top() of min stack is same as the current minimum.
Space complexity : O(N + X) where X = number of places where minimum changes or the element is same as the minimum.
.........................................................................

SOLUTION 2: (GFG SE POORA CODE STARTING SE)

#include <bits/stdc++.h> 
using namespace std; 

struct MyStack 
{ 
	stack<int> s; 
	int minEle; 

	void getMin() 
	{ 
		if (s.empty()) 
			cout << "Stack is empty\n"; 

		else
			cout <<"Minimum Element in the stack is: "
				<< minEle << "\n"; 
	} 

	void peek() 
	{ 
		if (s.empty()) 
		{ 
			cout << "Stack is empty "; 
			return; 
		} 

		int t = s.top(); // Top element. 

		cout << "Top Most Element is: "; 

		(t < minEle)? cout << minEle: cout << t; 
	} 

	void pop() 
	{ 
		if (s.empty()) 
		{ 
			cout << "Stack is empty\n"; 
			return; 
		} 

		cout << "Top Most Element Removed: "; 
		int t = s.top(); 
		s.pop(); 

		if (t < minEle) 
		{ 
			cout << minEle << "\n"; 
			minEle = 2*minEle - t; 
		} 

		else
			cout << t << "\n"; 
	} 

	void push(int x) 
	{ 
		if (s.empty()) 
		{ 
			minEle = x; 
			s.push(x); 
			cout << "Number Inserted: " << x << "\n"; 
			return; 
		} 

		// If new number is less than minEle 
		if (x < minEle) 
		{ 
			s.push(2*x - minEle); 
			minEle = x; 
		} 

		else
		s.push(x); 

		cout << "Number Inserted: " << x << "\n"; 
	} 
}; 

int main() 
{ 
	MyStack s; 
	s.push(3); 
	s.push(5); 
	s.getMin(); 
	s.push(2); 
	s.push(1); 
	s.getMin(); 
	s.pop(); 
	s.getMin(); 
	s.pop(); 
	s.peek(); 

	return 0; 
} 


Output:
Number Inserted: 3
Number Inserted: 5
Minimum Element in the stack is: 3
Number Inserted: 2
Number Inserted: 1
Minimum Element in the stack is: 1
Top Most Element Removed: 1
Minimum Element in the stack is: 2
Top Most Element Removed: 2
Top Most Element is: 5
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Max Stack    (JAVA mai hai)

 Example 1:
MaxStack stack = new MaxStack();
stack.push(5); 
stack.push(1);
stack.push(5);
stack.top(); -> 5
stack.popMax(); -> 5
stack.top(); -> 1
stack.peekMax(); -> 5
stack.pop(); -> 1
stack.top(); -> 5
----------------------------------------------

Approach #1: Two Stacks 

class MaxStack {
    Stack<Integer> stack;
    Stack<Integer> maxStack;

    public MaxStack() {
        stack = new Stack();
        maxStack = new Stack();
    }

    public void push(int x) {
        int max = maxStack.isEmpty() ? x : maxStack.peek();
        maxStack.push(max > x ? max : x);
        stack.push(x);
    }

    public int pop() {
        maxStack.pop();
        return stack.pop();
    }

    public int top() {
        return stack.peek();
    }

    public int peekMax() {
        return maxStack.peek();
    }

    public int popMax() {
        int max = peekMax();
        Stack<Integer> buffer = new Stack();
        while (top() != max) buffer.push(pop());
        pop();
        while (!buffer.isEmpty()) push(buffer.pop());
        return max;
    }
}

  Complexity Analysis
Time Complexity: O(N) for the popMax operation, and O(1) for the other operations, where N is the number of operations performed.
Space Complexity: O(N), the maximum size of the stack.
........................................................................

Approach #2: Double Linked List + TreeMap 

class MaxStack {
    TreeMap<Integer, List<Node>> map;
    DoubleLinkedList dll;

    public MaxStack() {
        map = new TreeMap();
        dll = new DoubleLinkedList();
    }

    public void push(int x) {
        Node node = dll.add(x);
        if(!map.containsKey(x))
            map.put(x, new ArrayList<Node>());
        map.get(x).add(node);
    }

    public int pop() {
        int val = dll.pop();
        List<Node> L = map.get(val);
        L.remove(L.size() - 1);
        if (L.isEmpty()) map.remove(val);
        return val;
    }

    public int top() {
        return dll.peek();
    }

    public int peekMax() {
        return map.lastKey();
    }

    public int popMax() {
        int max = peekMax();
        List<Node> L = map.get(max);
        Node node = L.remove(L.size() - 1);
        dll.unlink(node);
        if (L.isEmpty()) map.remove(max);
        return max;
    }
}

class DoubleLinkedList {
    Node head, tail;

    public DoubleLinkedList() {
        head = new Node(0);
        tail = new Node(0);
        head.next = tail;
        tail.prev = head;
    }

    public Node add(int val) {
        Node x = new Node(val);
        x.next = tail;
        x.prev = tail.prev;
        tail.prev = tail.prev.next = x;
        return x;
    }

    public int pop() {
        return unlink(tail.prev).val;
    }

    public int peek() {
        return tail.prev.val;
    }

    public Node unlink(Node node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
        return node;
    }
}

class Node {
    int val;
    Node prev, next;
    public Node(int v) {val = v;}
}

Complexity Analysis
Time Complexity: O(logN) for all operations except peek which is O(1), where N is the number of operations performed. Most operations involving TreeMap are O(logN).
Space Complexity: O(N), the size of the data structures used.

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Find maximum in a stack in O(1) time and O(1) extra space  (GFG)

Examples:
Given Stack :
2
5
1
64   --> Maximum
So Output must be 64 when getMax() is called.
----------------------------------------------------

// C++ program to implement a stack that supports 
// getMaximum() in O(1) time and O(1) extra space. 
#include <bits/stdc++.h> 
using namespace std; 

// A user defined stack that supports getMax() in 
// addition to push() and pop() 
struct MyStack { 
	stack<int> s; 
	int maxEle; 

	// Prints maximum element of MyStack 
	void getMax() 
	{ 
		if (s.empty()) 
			cout << "Stack is empty\n"; 

		// variable maxEle stores the maximum element 
		// in the stack. 
		else
			cout << "Maximum Element in the stack is: "
				<< maxEle << "\n"; 
	} 

	// Prints top element of MyStack 
	void peek() 
	{ 
		if (s.empty()) { 
			cout << "Stack is empty "; 
			return; 
		} 

		int t = s.top(); // Top element. 

		cout << "Top Most Element is: "; 

		// If t < maxEle means maxEle stores 
		// value of t. 
		(t > maxEle) ? cout << maxEle : cout << t; 
	} 

	// Remove the top element from MyStack 
	void pop() 
	{ 
		if (s.empty()) { 
			cout << "Stack is empty\n"; 
			return; 
		} 

		cout << "Top Most Element Removed: "; 
		int t = s.top(); 
		s.pop(); 

		// Maximum will change as the maximum element 
		// of the stack is being removed. 
		if (t > maxEle) { 
			cout << maxEle << "\n"; 
			maxEle = 2 * maxEle - t; 
		} 

		else
			cout << t << "\n"; 
	} 

	// Removes top element from MyStack 
	void push(int x) 
	{ 
		// Insert new number into the stack 
		if (s.empty()) { 
			maxEle = x; 
			s.push(x); 
			cout << "Number Inserted: " << x << "\n"; 
			return; 
		} 

		// If new number is less than maxEle 
		if (x > maxEle) { 
			s.push(2 * x - maxEle); 
			maxEle = x; 
		} 

		else
			s.push(x); 

		cout << "Number Inserted: " << x << "\n"; 
	} 
}; 

// Driver Code 
int main() 
{ 
	MyStack s; 
	s.push(3); 
	s.push(5); 
	s.getMax(); 
	s.push(7); 
	s.push(19); 
	s.getMax(); 
	s.pop(); 
	s.getMax(); 
	s.pop(); 
	s.peek(); 

	return 0; 
} 

Output:
Number Inserted: 3
Number Inserted: 5
Maximum Element in the stack is: 5
Number Inserted: 7
Number Inserted: 19
Maximum Element in the stack is: 19
Top Most Element Removed: 19
Maximum Element in the stack is: 7
Top Most Element Removed: 7
Top Most Element is: 5

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Reverse Words in a String

Example 1:

Input: "the sky is blue"
Output: "blue is sky the"
Example 2:

Input: "  hello world!  "
Output: "world! hello"
Explanation: Your reversed string should not contain leading or trailing spaces.
Example 3:

Input: "a good   example"
Output: "example good a"
Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.
---------------------------------------------------------------

class Solution {
public:
    string reverseWords(string s) {
          
       int i,start,end,len=0;      
       for(i=0;i<s.size();i++)
      {
        if(s[i]!=' ')
        {
          start=i;
          break;
        }
      }
      
      for(i=s.size()-1;i>=0;i--)
      {
          if(s[i]!=' ')
        {
           end=i;
           break;
        }
      }
      
      
      for(i=start; i<=end; i++)
      {
        if(s[i]==' ' && s[i-1]==' ')
          continue;
        s[len++]=s[i];
      }
      
      
      s.erase(s.begin()+len, s.end());
      
      reverse(s.begin(),s.end());
      
      start=0;
      for(i=0;i<s.size();i++)
      {
        if(s[i]==' ')
        {
          reverse(s.begin()+start, s.begin()+i);
          start=(i+1);
        }
      }
      
      reverse(s.begin()+start, s.end());
      return s;
    }
};
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 Longest Palindrome in a string
       OR
 Longest Palindromic Substring

Example 1:

Input: "babad"
Output: "bab"
Note: "aba" is also a valid answer.
Example 2:

Input: "cbbd"
Output: "bb"
------------------------------------------------------------

APPROACH 1 : ( Brute Force)

The obvious brute force solution is to pick all possible starting and ending positions for a substring, and verify if it is a palindrome.

Complexity Analysis
Time complexity : O(n^3). Assume that nn is the length of the input string, there are a total of (binomial)(n 2) = n(n−1)/2 such substrings (excluding the trivial solution where a character itself is a palindrome). Since verifying each substring takes O(n) time, the run time complexity is O(n^3)
Space complexity : O(1).


..............................................................................

APPROACH 2 : (EXPAND AROUND CENTER)

int expandFromMiddle(string s, int left, int right)
     {
       while(left>=0 && right<s.size() && s[left]==s[right])
       {
         left--;
         right++;
       }
      return right-left-1;
 }

class Solution {
public:
  
    string longestPalindrome(string s) {
      
      if(s.size()<2)return s;
      
      int start=0,end=0;
      for(int i=0;i<s.size();i++)
      {
        int l1=expandFromMiddle(s, i, i);
        int l2=expandFromMiddle(s, i, i+1);
        int l=max(l1,l2);
        if(l>end-start)klbjabbbdjndn n  c jvbvbvj  b cb fc n jzakav bxknkc jhbx  z j cn lwjewhjujsbc,frebhj bvl;akjsfdd,.ss cnvmkm /,.nznk 
        {
          start=i-(l-1)/2;
          end=i+(l/2);
        }
      }
      
      return s.substr(start,end-start+1);
    }
};

Time complexity : O(n^2).Since expanding a palindrome around its center could take O(n) time, the overall complexity is O(n^2).
Space complexity : O(1)
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

REVERSE INTEGER


Given a 32-bit signed integer, reverse digits of an integer.

Example 1:
Input: 123
Output: 321
Example 2:

Input: -123
Output: -321
Example 3:

Input: 120
Output: 21

Note:
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.
---------------------------------------------------------------------------

  class Solution {
public:
    int reverse(int x) {
        int rev = 0;
        while (x != 0) {
            int pop = x % 10;
            x /= 10;
            if (rev > INT_MAX/10 || (rev == INT_MAX / 10 && pop > 7)) return 0;
            if (rev < INT_MIN/10 || (rev == INT_MIN / 10 && pop < -8)) return 0;
            rev = rev * 10 + pop;
        }
        return rev;
    }
};

Time Complexity: O(log(x)). There are roughly log(base10)(x) digits in x.
Space Complexity: O(1).
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Inorder Traversal

Example:

Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,3,2]

----------------------------------------------------------
 ITERATIVE SOLUTION:   

 void printIn(TreeNode* root, vector<int>&v)
{
  if(root==NULL)return ;

  stack<TreeNode*>mystack;

  TreeNode* ptr=root;
  while(ptr!=NULL || !mystack.empty())
  {
    while(ptr!=NULL)
    {
      mystack.push(ptr);
      ptr=ptr->left;
    }
     
    ptr=mystack.top();
    mystack.pop();
    v.push_back(ptr->val);

    ptr=ptr->right;

  }
}

class Solution { 
public:
    vector<int> inorderTraversal(TreeNode* root) {
      vector<int>v;
      printIn(root,v);
      return v;
    }
};

Time complexity : O(n)
Space complexity :O(n)
.................................................................

RECURSIVE SOLUTION:

void printIn(TreeNode* root, vector<int>&v)
{
    if(root==NULL)
        return ;

    printIn(root->left,v);
    v.push_back(root->val);
    printIn(root->right,v);
}
  

class Solution { 
public:
    vector<int> inorderTraversal(TreeNode* root) {
      vector<int>v;
      printIn(root,v);
      return v;
    }
};

Time complexity : O(n)
Space complexity :O(n)
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

   Binary Tree Preorder Traversal

  Example:

Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,2,3]
------------------------------------------------

  RECURSIVE SOLUTION: 

void printPre(TreeNode* root, vector<int>&v)
{
  if(!root)return ;
  
  v.push_back(root->val);
  printPre(root->left,v);
  printPre(root->right,v);
}



class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int>v;
        printPre(root,v);
      return v;
    }
};

Time complexity : O(n)
Space complexity :O(n)
.........................................................................

 ITERATIVE SOLUTION:

void printPre(TreeNode* root, vector<int>&v)
{
  if(root==NULL)return ;

  stack<TreeNode*>mystack;
mystack.push(root);
     
    while(!mystack.empty())
    {
        TreeNode* ptr = mystack.top();
        mystack.pop();
        v.push_back(ptr->val);

        if(ptr->right)
            mystack.push(ptr->right);

        if(ptr->left)
            mystack.push(ptr->left);
  }
}


class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int>v;
        printPre(root,v);
      return v;
    }
};

Time complexity : O(n)
Space complexity :O(n)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Binary Tree Postorder Traversal

Example:

Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [3,2,1]
------------------------------------------------

ITERATIVE SOLUTION:

void printPost(TreeNode* root, vector<int>&v)
{
  if(root==NULL)return ;

  stack<TreeNode*>s1,s2;

 s1.push(root);
  while(!s1.empty())
  {
    root=s1.top();
    s1.pop();
    s2.push(root);
    if(root->left)
      s1.push(root->left);
    if(root->right)
      s1.push(root->right);
  }
  while(!s2.empty())
  {
    root=s2.top();
    s2.pop();
    v.push_back(root->val);
  }
}

class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int>v;
        printPost(root,v);
      return v;
    }
};

Time complexity : O(n)
Space complexity :O(n)
............................................................................

 RESURSIVE SOLUTION: 

 void printPost(TreeNode* root, vector<int>&v)
{
    if(root==NULL)
        return ;
 printPost(root->left,v);
    printPost(root->right,v);
    v.push_back(root->val);
}

class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int>v;
        printPost(root,v);
      return v;
    }
};

Time complexity : O(n)
Space complexity :O(n)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 Find Bottom Left Tree Value

  Example 1:
Input:

    2
   / \
  1   3

Output:
1
Example 2:
Input:

        1
       / \
      2   3
     /   / \
    4   5   6
       /
      7

Output:
7
--------------------------------------------------------

 class Solution {
public:
    int findBottomLeftValue(TreeNode* root)
{
  queue<TreeNode*>q;
  q.push(root);
   int x=0;
  while(!q.empty())
  {
    int n=q.size();
    for(auto i=1;i<=n;i++)
    {
      TreeNode* f=q.front();
      q.pop();

      if(i==1)
      {
        x=f->val;
      }
      if(f->left!=NULL)
        q.push(f->left);

      if(f->right!=NULL)
        q.push(f->right);
    }
  }
       return x;
    }
};


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 LeftView Of Binary Tree

Examples:
Input : 
                 1
               /   \
              2     3
             / \     \
            4   5     6             
Output : 1 2 4
Input :
        1
      /   \
    2       3
      \   
        4  
          \
            5
             \
               6
Output :1 2 4 5 6
----------------------------------------

#include <bits/stdc++.h> 
using namespace std; 

class node { 
public: 
	int data; 
	node *left, *right; 
}; 

node* newNode(int item) 
{ 
	node* temp = new node(); 
	temp->data = item; 
	temp->left = temp->right = NULL; 
	return temp; 
} 

void leftViewUtil(node* root, int level, int* max_level) 
{ 
	if (root == NULL) 
		return; 

	if (*max_level < level) { 
		cout << root->data << "\t"; 
		*max_level = level; 
	} 

	leftViewUtil(root->left, level + 1, max_level); 
	leftViewUtil(root->right, level + 1, max_level); 
} 

void leftView(node* root) 
{ 
	int max_level = 0; 
	leftViewUtil(root, 1, &max_level); 
} 

int main() 
{ 
	node* root = newNode(12); 
	root->left = newNode(10); 
	root->right = newNode(30); 
	root->right->left = newNode(25); 
	root->right->right = newNode(40); 

	leftView(root); 

	return 0; 
} 

Time Complexity: The function does a simple traversal of the tree, so the complexity is O(n).
Auxiliary Space: O(n), due to the stack space during recursive call.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Bottom View of a Binary Tree

 
                      20
                    /    \
                  8       22
                /   \    /   \
              5      3 4     25
                    / \      
                  10    14 
For the above tree the output should be 5, 10, 4, 14, 25.
---------------------------------------------------------------------

Method 1 – Using Queue

#include<bits/stdc++.h> 
using namespace std; 

struct Node 
{ 
	int data; //data of the node 
	int hd; //horizontal distance of the node 
	Node *left, *right; //left and right references 

	Node(int key) 
	{ 
		data = key; 
		hd = INT_MAX; 
		left = right = NULL; 
	} 
}; 

void bottomView(Node *root) 
{ 
	if (root == NULL) 
		return; 

	// Initialize a variable 'hd' with 0 
	// for the root element. 
	int hd = 0; 

	// TreeMap which stores key value pair 
	// sorted on key value 
	map<int, int> m; 

	// Queue to store tree nodes in level 
	// order traversal 
	queue<Node *> q; 

	// Assign initialized horizontal distance 
	// value to root node and add it to the queue. 
	root->hd = hd; 
	q.push(root); // In STL, push() is used enqueue an item 

	// Loop until the queue is empty (standard 
	// level order loop) 
	while (!q.empty()) 
	{ 
		Node *temp = q.front(); 
		q.pop(); // In STL, pop() is used dequeue an item 

		// Extract the horizontal distance value 
		// from the dequeued tree node. 
		hd = temp->hd; 

		// Put the dequeued tree node to TreeMap 
		// having key as horizontal distance. Every 
		// time we find a node having same horizontal 
		// distance we need to replace the data in 
		// the map. 
		m[hd] = temp->data; 

		// If the dequeued node has a left child, add 
		// it to the queue with a horizontal distance hd-1. 
		if (temp->left != NULL) 
		{ 
			temp->left->hd = hd-1; 
			q.push(temp->left); 
		} 

		// If the dequeued node has a right child, add 
		// it to the queue with a horizontal distance 
		// hd+1. 
		if (temp->right != NULL) 
		{ 
			temp->right->hd = hd+1; 
			q.push(temp->right); 
		} 
	} 

	// Traverse the map elements using the iterator. 
	for (auto i = m.begin(); i != m.end(); ++i) 
		cout << i->second << " "; 
} 

int main() 
{ 
	Node *root = new Node(20); 
	root->left = new Node(8); 
	root->right = new Node(22); 
	root->left->left = new Node(5); 
	root->left->right = new Node(3); 
	root->right->left = new Node(4); 
	root->right->right = new Node(25); 
	root->left->right->left = new Node(10); 
	root->left->right->right = new Node(14); 
	cout << "Bottom view of the given binary tree :\n"
	bottomView(root); 
	return 0; 
} 

Bottom view of the given binary tree:
5 10 4 14 25
...................................................

 Method 2- Using HashMap()

// C++ Program to print Bottom View of Binary Tree 
#include < bits / stdc++.h > 
#include < map > 
using namespace std; 

// Tree node class 
struct Node 
{ 
	// data of the node 
	int data; 
	
	// horizontal distance of the node 
	int hd; 
	
	//left and right references 
	Node * left, * right; 
	
	// Constructor of tree node 
	Node(int key) 
	{ 
		data = key; 
		hd = INT_MAX; 
		left = right = NULL; 
	} 
}; 

void printBottomViewUtil(Node * root, int curr, int hd, map <int, pair <int, int>> & m) 
{ 
	// Base case 
	if (root == NULL) 
		return; 
	
	// If node for a particular 
	// horizontal distance is not 
	// present, add to the map. 
	if (m.find(hd) == m.end()) 
	{ 
		m[hd] = make_pair(root -> data, curr); 
	} 
	// Compare height for already 
	// present node at similar horizontal 
	// distance 
	else
	{ 
		pair < int, int > p = m[hd]; 
		if (p.second <= curr) 
		{ 
			m[hd].second = curr; 
			m[hd].first = root -> data; 
		} 
	} 
	
	// Recur for left subtree 
	printBottomViewUtil(root -> left, curr + 1, hd - 1, m); 
	
	// Recur for right subtree 
	printBottomViewUtil(root -> right, curr + 1, hd + 1, m); 
} 

void printBottomView(Node * root) 
{ 
	
	// Map to store Horizontal Distance, 
	// Height and Data. 
	map < int, pair < int, int > > m; 
	
	printBottomViewUtil(root, 0, 0, m); 
	
	// Prints the values stored by printBottomViewUtil() 
	map < int, pair < int, int > > ::iterator it; 
	for (it = m.begin(); it != m.end(); ++it) 
	{ 
		pair < int, int > p = it -> second; 
		cout << p.first << " "; 
	} 
} 

int main() 
{ 
	Node * root = new Node(20); 
	root -> left = new Node(8); 
	root -> right = new Node(22); 
	root -> left -> left = new Node(5); 
	root -> left -> right = new Node(3); 
	root -> right -> left = new Node(4); 
	root -> right -> right = new Node(25); 
	root -> left -> right -> left = new Node(10); 
	root -> left -> right -> right = new Node(14); 
	cout << "Bottom view of the given binary tree :\n"; 
	printBottomView(root); 
	return 0; 
} 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Top View of Binary Tree

Input:
       1
     /   \
   2       3
  /  \    / \
 4    5  6   7
Top view of the above binary tree is
4 2 1 3 7

Input:
        1
      /   \
    2       3
      \   
        4  
          \
            5
             \
               6
Top view of the above binary tree is
2 1 3 6
-------------------------------------------------------

 SOLUTION 1: (using QUEUE) (idea similar to level order traversal)

#include <bits/stdc++.h> 
using namespace std; 

struct Node 
{ 
	Node * left; 
	Node* right; 
	int hd; 
	int data; 
}; 

Node* newNode(int key) 
{ 
	Node* node=new Node(); 
	node->left = node->right = NULL; 
	node->data=key; 
	return node; 
} 

void topview(Node* root) 
{ 
	if(root==NULL) 
	return; 
	queue<Node*>q; 
	map<int,int> m; 
	int hd=0; 
	root->hd=hd; 
	
	q.push(root); 
	
	cout<< "The top view of the tree is : \n"; 
	
	while(q.size()) 
	{ 
		hd=root->hd; 
		if(m.count(hd)==0) 
		m[hd]=root->data; 
		if(root->left) 
		{ 
			root->left->hd=hd-1; 
			q.push(root->left); 
		} 
		if(root->right) 
		{ 
			root->right->hd=hd+1; 
			q.push(root->right); 
		} 
		q.pop(); 
		root=q.front(); 
		
	} 
	
	
	for(auto i=m.begin();i!=m.end();i++) 
	{ 
		cout<<i->second<<" "; 
	} 
} 

int main() 
{ 
    Node* root = newNode(1); 
	root->left = newNode(2); 
	root->right = newNode(3); 
	root->left->right = newNode(4); 
	root->left->right->right = newNode(5); 
	root->left->right->right->right = newNode(6); 
	cout<<"Following are nodes in top view of Binary Tree\n"; 
	topview(root); 
	return 0; 
} 

Time Complexity of the above implementation is O(nlogn) where n is the number of nodes in the given binary tree with each insertion operation in Map requiring O(log2n) complexity.
.....................................................................

  Solution 2:  (RECURSION)

#include<bits/stdc++.h> 
using namespace std; 

struct Node{ 
	Node * left; 
	Node* right; 
	int data; 
}; 

Node* newNode(int key){ 
	Node* node=new Node(); 
	node->left = node->right = NULL; 
	node->data=key; 
	return node; 
} 

void fillMap(Node* root,int d,int l,map<int,pair<int,int>> &m)
{ 
	if(root==NULL) return; 

	if(m.count(d)==0){ 
		m[d] = make_pair(root->data,l); 
	}else if(m[d].second>l){ 
		m[d] = make_pair(root->data,l); 
	} 

	fillMap(root->left,d-1,l+1,m); 
	fillMap(root->right,d+1,l+1,m); 
} 

void topView(struct Node *root){ 

	map<int,pair<int,int>> m; 
	fillMap(root,0,0,m); 
	for(auto it=m.begin();it!=m.end();it++){ 
		cout << it->second.first << " "; 
	} 
} 

int main(){ 
	Node* root = newNode(1); 
	root->left = newNode(2); 
	root->right = newNode(3); 
	root->left->right = newNode(4); 
	root->left->right->right = newNode(5); 
	root->left->right->right->right = newNode(6); 
	cout<<"Following are nodes in top view of Binary Tree\n"; 
	topView(root); 
	return 0; 
} 

Output:
Following are nodes in top view of Binary Tree
2 1 3 6

..........................................................................

SOLUTION 3:

#include <bits/stdc++.h> 
using namespace std; 

struct Node { 
	Node* left; 
	Node* right; 
	int data; 
}; 

Node* newNode(int key) 
{ 
	Node* node = new Node(); 
	node->left = node->right = NULL; 
	node->data = key; 
	return node; 
} 

void topView(struct Node* root) 
{ 
	if (root == NULL) { 
		return; 
	} 

	Node* temp = NULL; 
	queue<pair<Node*, int> > q; 
	map<int, int> mp; 
	q.push({ root, 0 }); 

	while (!q.empty()) 
   { 
		temp = q.front().first; 
		int d = q.front().second; 
		q.pop(); 

		// If any node is not at that vertical distance 
		// just insert that node in map and print it 
		if (mp.find(d) == mp.end()) { 
			cout << temp->data << " "; 
			mp[d] = temp->data; 
		} 

		// Continue for left node 
		if (temp->left) { 
			q.push({ temp->left, d - 1 }); 
		} 

		// Continue for right node 
		if (temp->right) { 
			q.push({ temp->right, d + 1 }); 
		} 
	} 
} 

int main() 
{ 
	Node* root = newNode(1); 
	root->left = newNode(2); 
	root->right = newNode(3); 
	root->left->right = newNode(4); 
	root->left->right->right = newNode(5); 
	root->left->right->right->right = newNode(6); 
	cout << "Following are nodes in top view of Binary Tree\n"; 
	topView(root); 
	return 0; 
} 

Output:
Following are nodes in top view of Binary Tree
2 1 3 6

TIME: O(n).
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Print Right View of a Binary Tree

Right view of following tree is 1 3 7 8

          1
       /     \
     2        3
   /   \     /  \
  4     5   6    7
                  \
                   8
------------------------------------------------------------------------

#include <bits/stdc++.h> 
using namespace std; 

struct Node 
{ 
	int data; 
	struct Node *left, *right; 
}; 

struct Node *newNode(int item) 
{ 
	struct Node *temp = (struct Node *)malloc( 
						sizeof(struct Node)); 
	temp->data = item; 
	temp->left = temp->right = NULL; 
	return temp; 
} 

void rightViewUtil(struct Node *root, int level, int *max_level) 
{ 
	if (root == NULL) return; 

	if (*max_level < level) 
	{ 
		cout << root->data << "\t"; 
		*max_level = level; 
	} 

	rightViewUtil(root->right, level + 1, max_level); 
	rightViewUtil(root->left, level + 1, max_level); 
} 

void rightView(struct Node *root) 
{ 
	int max_level = 0; 
	rightViewUtil(root, 1, &max_level); 
} 

int main() 
{ 
	struct Node *root = newNode(1); 
	root->left = newNode(2); 
	root->right = newNode(3); 
	root->left->left = newNode(4); 
	root->left->right = newNode(5); 
	root->right->left = newNode(6); 
	root->right->right = newNode(7); 
	root->right->left->right = newNode(8); 

	rightView(root); 
	return 0; 
} 

Time Complexity: The function does a simple traversal of the tree, so the complexity is O(n).
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Level order Traversal 
      OR
Binary Tree Level Order Traversal

For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its level order traversal as:
[
  [3],
  [9,20],
  [15,7]
]
-------------------------------------------------------------------

SOLUTION 1: (USING QUEUE)

class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
         vector<vector<int>>res;
    if(root==nullptr)return res;
    queue<TreeNode*>q;
    q.push(root);

    while(!q.empty())
    {
        int size=q.size();
        vector<int>v;

      for(int i=0;i<size;i++)
      {
        TreeNode* f=q.front();
        q.pop();
        v.push_back(f->val);
        if(f->left)
        {
            q.push(f->left);
        }

        if(f->right)
        {
            q.push(f->right);
        }
       }
       res.push_back(v);
   }
    return res;
    }
};

..................................................................

SOLUTION 2: (USING RECURSION)

class Solution {
public:
    
    int h;
    
    vector<vector<int>> levelOrder(TreeNode* root) {
        h=height(root);
    vector<vector<int> > v(h);
    helper(root,v,0);
    return v;
    }
    int height(TreeNode* root){
    if(root){
        return 1+max(height(root->left),height(root->right));
    }
    return 0;
    }
    
    void helper(TreeNode* root,vector<vector<int> >&v,int c_level){
      if(root){
        v[c_level].push_back(root->val);
        helper(root->left,v,c_level+1);
        helper(root->right,v,c_level+1);
    }
    return;
    }
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Binary Tree Level Order Traversal II

For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its bottom-up level order traversal as:
[
  [15,7],
  [9,20],
  [3]
]
----------------------------------------------------------------------

SOLUTION 1:(QUEUE)

class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
   
   vector<vector<int>>res;
      stack<vector<int>>st;
    if(root==nullptr)return {};
    queue<TreeNode*>q;
    q.push(root);

    while(!q.empty())
    {
        int size=q.size();
        vector<int>v;

      for(int i=0;i<size;i++)
      {
        TreeNode* f=q.front();
        q.pop();
        v.push_back(f->val);
        if(f->left)
            q.push(f->left);
        if(f->right)
            q.push(f->right);
       }
      
       st.push(v);
    }
        while(!st.empty())
        {
          res.push_back(st.top());
          st.pop();
        }
      
    return res;
   }
    
};
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Level order traversal in spiral form
     OR
Binary Tree Zigzag Level Order Traversal

 
For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its zigzag level order traversal as:
[
  [3],
  [20,9],
  [15,7]
]
-----------------------------------------------------------------

class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) 
  {
    vector<vector<int>>res;
    if(root==nullptr)return res;
    queue<TreeNode*>q;
    q.push(root);
    
      bool zigzag=true;
    while(!q.empty())
    {
        int size=q.size();
        vector<int>v(size);

      for(int i=0;i<size;i++)
      {
        TreeNode* f=q.front();
        q.pop();
                
        int index=0;
        
        if(zigzag) 
          index=i;
        else 
          index=(size-1-i);
        
         v[index]=f->val;

        if(f->left)  q.push(f->left);
        if(f->right) q.push(f->right);
       }
       //toggle to boolean flag
       zigzag=!zigzag;
       res.push_back(v);
   }
    return res;
  }
};
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Height of a Binary Tree
        OR
 Maximum Depth of Binary Tree


Example:
Given binary tree [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
return its depth = 3.
----------------------------------------------------------------------------
class Solution {
public:
    int maxDepth(TreeNode* root) {
            if(root==nullptr)
        return 0;

    int h1=maxDepth(root->left);
    int h2=maxDepth(root->right);

    return 1+max(h1,h2);

    }
};
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 Diameter of Binary Tree

 Example:
Given a binary tree
          1
         / \
        2   3
       / \     
      4   5    
Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].
---------------------------------------------------------------------------------

SOLUTION 1: (RECURSION)

int ans;

int height(TreeNode* root)
{
    if(root==nullptr)
        return 0;

    int h1=height(root->left);
    int h2=height(root->right);
    ans=max(ans,h1+h2+1);
    return 1+max(h1,h2);
}


class Solution {
public:
    int diameterOfBinaryTree(TreeNode* root) {
     ans=1;
    height(root);
    return ans-1;
    }
};

Time Complexity: O(N). We visit every node once.
Space Complexity: O(N), the size of our implicit call stack during our depth-first search.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Check if Binary tree is height balanced or not
          OR
Balanced Binary Tree

Example 1:
Given the following tree [3,9,20,null,null,15,7]:
    3
   / \
  9  20
    /  \
   15   7
Return true.

Example 2:
Given the following tree [1,2,2,3,3,null,null,4,4]:

       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
Return false.
--------------------------------------------------------------------------------
int depth (TreeNode *root) {
        if (root == NULL) return 0;
        return max (depth(root -> left), depth (root -> right)) + 1;
    }

class Solution {
public:
  
    bool isBalanced(TreeNode* root) {
       if (root == NULL) return true;
        
        int left=depth(root->left);
        int right=depth(root->right);
        
        return abs(left - right) <= 1 && isBalanced(root->left) && isBalanced(root->right);
    }
};
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

LCA in Binary Tree
    OR
Lowest Common Ancestor of a Binary Tree

Example 1:
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
Explanation: The LCA of nodes 5 and 1 is 3.

Example 2:
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
Output: 5
Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.
 
Note:
All of the nodes' values will be unique.
p and q are different and both values will exist in the binary tree.
------------------------------------------------------------------------------------------------

    SOLUTION 1(a): (USING RECURSION)

class Solution {
public:

	TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* n1, TreeNode* n2) 
	{
		if (!root) return NULL;
            if (root == n1 || root == n2) return root;
            TreeNode *L = lowestCommonAncestor(root->left, n1, n2);
            TreeNode *R = lowestCommonAncestor(root->right, n1, n2);
            if (L && R) return root;  
            return L ? L : R; 
    }
};

           OR (if return type is integer (interviewbit wala jaisa))

       TreeNode *LCA(TreeNode *root, int n1, int n2) 
        {
            if (!root) return NULL;
            if (root->val == n1 || root->val == n2) return root;
            TreeNode *L = LCA(root->left, n1, n2);
            TreeNode *R = LCA(root->right, n1, n2);
            if (L && R) return root; 
            return L ? L : R; 
        }

        bool find(TreeNode *root, int n1)
        {
            if (!root) return false;
            if (root->val == n1) return true;
            return (find(root->left, n1) || find(root->right, n1));
        }
        
       int Solution::lowestCommonAncestor(TreeNode* root, int n1, int n2) 
       {
         if (!find(root, n1) || !find(root, n2)) return -1;
            TreeNode *ans = LCA(root, n1, n2);
            if (!ans) return -1;
            return ans->val;
       }

       
 NOTE:  Time Complexity: Time complexity of the above solution is O(n) as the method does a simple tree traversal in bottom up fashion.
Note that the above method assumes that keys are present in Binary Tree. If one key is present and other is absent, then it returns the present key as LCA (Ideally should have returned NULL).
We can extend this method to handle all cases by passing two boolean variables v1 and v2. v1 is set as true when n1 is present in tree and v2 is set as true if n2 is present in tree. It is just below i.e.(SOLUTION 1(b))
.......................................
SOLUTION 1(b):

class Solution {
public:
	TreeNode *findLCAUtil(struct TreeNode* root, TreeNode* n1, TreeNode* n2, bool &v1, bool &v2)
	{
		if (root == NULL) return NULL;

		if (root == n1)
		{
			v1 = true;
			return root;
		}
		if (root == n2)
		{
			v2 = true;
			return root;
		}
		TreeNode *left_lca = findLCAUtil(root->left, n1, n2, v1, v2);
		TreeNode *right_lca = findLCAUtil(root->right, n1, n2, v1, v2);
		if (left_lca && right_lca) return root;

		return (left_lca != NULL) ? left_lca : right_lca;
	}

	bool find(TreeNode *root, TreeNode* k)
	{
		if (root == NULL)
			return false;

		if (root == k || find(root->left, k) || find(root->right, k))
			return true;

		return false;
	}


	TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* n1, TreeNode* n2)
	{
		bool v1 = false, v2 = false;
		TreeNode *lca = findLCAUtil(root, n1, n2, v1, v2);

		if (v1 && v2 || v1 && find(lca, n2) || v2 && find(lca, n1))
			return lca;

		return NULL;
	}
};  

..............................................................

   SOLUTION 2: (USING ITERATIVE METHOD)

 class Solution {
public:
	TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
	{
		stack<TreeNode *> s;
        TreeNode *prev = NULL; 
        TreeNode *curr = NULL; 
        TreeNode *parent = NULL; 
        
        int pf = 0;
        int qf = 0;

        if (!root) return NULL;
        if (p == q) return p;
        for (TreeNode* tmp = root; tmp; tmp = tmp->left) 
            s.push(tmp);
        while (!s.empty()) 
        {
            curr = s.top();
            if (parent && prev == parent) parent = curr;
            if (curr->right && prev != curr->right) 
            {
                   for (TreeNode *tmp = curr->right; tmp; tmp = tmp->left)
                    s.push(tmp);
                    continue;
            }   
            s.pop();
            if (curr == p)
            {
                if (qf) return parent;
                pf = 1;
                parent = curr;
            }    
            if (curr == q) 
            {
                if (pf) return parent;
                qf = 1;
                parent = curr;
            }   
            prev = curr;
        }
        return NULL;
      }
    }
};

TIME AND SPACE BOTH O(n).
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 Same Tree
   OR
 Check if two trees are identical or not

Example 1:

Input:     1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

Output: true
Example 2:

Input:     1         1
          /           \
         2             2

        [1,2],     [1,null,2]

Output: false
Example 3:

Input:     1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

Output: false
--------------------------------------------------------
SOLUTION 1: (RECURSION)

class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
         if (p == NULL && q == NULL) return true;
           if (q == NULL || p == NULL) return false;
         if (p->val != q->val) return false;
              return isSameTree(p->right, q->right) && isSameTree(p->left, q->left);
    }
};

Time complexity : O(N), where N is a number of nodes in the tree, since one visits each node exactly once.
Space complexity :O(log(N)) in the best case of completely balanced tree and O(N) in the worst case of completely unbalanced tree, to keep a recursion stack.
.......................................................

 SOLUTION 2: (ITERATION)
  
 class Solution {
public:
     bool isSameTree(TreeNode* p, TreeNode* q) {
  
    if (p==NULL  && q==NULL) return true;   
    if (p == NULL) return false; 
    if (q == NULL) return false; 
      
    queue<TreeNode *> q1, q2; 
  
    q1.push(p); 
    q2.push(q); 
  
    while (!q1.empty() && !q2.empty()) 
    { 
        TreeNode *n1 = q1.front(); 
        TreeNode *n2 = q2.front(); 
  
        if (n1->val != n2->val) 
           return false; 
  
          q1.pop(), q2.pop(); 
  
       if (n1->left && n2->left) 
        { 
            q1.push(n1->left); 
            q2.push(n2->left); 
        } 
  
        else if (n1->left || n2->left) 
            return false; 
  
        if (n1->right && n2->right) 
        { 
            q1.push(n1->right); 
            q2.push(n2->right); 
        } 
        else if (n1->right || n2->right) 
            return false; 
    } 
  
    return true; 
    }
};

Time complexity : O(N) since each node is visited exactly once.
Space complexity : O(log(N)) in the best case of completely balanced tree and O(N) in the worst case of completely unbalanced tree, to keep a deque.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 Maximum path sum
    OR
 Binary Tree Maximum Path Sum

Example 1:
Input: [1,2,3]

       1
      / \
     2   3

Output: 6

Example 2:
Input: [-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

Output: 42
-------------------------------------------------------

 class Solution {
public:
    
int findMaxUtil(TreeNode* root, int &res) 
{ 
   if (root == NULL) 
        return 0; 

    int l = findMaxUtil(root->left,res); 
    int r = findMaxUtil(root->right,res); 
    int max_single = max(max(l, r) + root->val, root->val); 
    int max_top = max(max_single, l + r + root->val); 
    res = max(res, max_top); 
    return max_single; 
} 
    
 int maxPathSum(TreeNode* root) 
 {
    int res = INT_MIN; 
    findMaxUtil(root, res); 
    return res; 
  }
};

Time Complexity: O(n) where n is number of nodes in Binary Tree.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Path Sum

Example:
Given the below binary tree and sum = 22,
      5
     / \
    4   8
   /   / \
  11  13  4
 /  \      \
7    2      1
return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.
---------------------------------------------------------

SOLUTION 1: (ITERATIVE METHOD USING STACK)

class Solution {
public:
    bool hasPathSum(TreeNode* root, int sum)
    {
     if( !root ) return false;
        
        stack<pair<TreeNode*,int> > s;
        s.push(make_pair(root, sum));
        int val;
        TreeNode* p;
        
        while( !s.empty() ) {
            p = s.top().first;
            val = s.top().second;
            s.pop();
            if( p->left == NULL && p->right == NULL && p->val == val ) 
                return true;
            if( p->right ) 
                s.push(make_pair(p->right, val - p->val));
            if( p->left ) 
                s.push(make_pair(p->left, val - p->val));
        }
        return false;
  }
};
.............................................................

 SOLUTION 2: (RECURSION)

class Solution {
public:
    bool hasPathSum(TreeNode* root, int sum)
    {
      if(!root)
          return 0;
     if(root->val==sum && !root->left && !root->right)
         return 1;
        
     return hasPathSum(root->left,sum-root->val)|| hasPathSum(root->right,sum-root->val);
    }
};

Time Complexity: O(n)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Path Sum II

 Example:

Given the below binary tree and sum = 22,

      5
     / \
    4   8
   /   / \
  11  13  4
 /  \    / \
7    2  5   1
Return:

[
   [5,4,11,2],
   [5,8,4,5]
]
-----------------------------------------------------

 class Solution {
public:
    void findPaths(TreeNode* node, int sum, vector<int>& path, vector<vector<int> >& paths) {
        if (!node) return;
        path.push_back(node -> val);
        if (!(node -> left) && !(node -> right) && sum == node -> val)
            paths.push_back(path);
        findPaths(node -> left, sum - node -> val, path, paths);
        findPaths(node -> right, sum - node -> val, path, paths);
        path.pop_back();
    }
    
    vector<vector<int>> pathSum(TreeNode* root, int sum) {
         vector<vector<int> > paths;
        vector<int> path;
        findPaths(root, sum, path, paths);
        return paths;  
    }
};
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  Path Sum III   (LEETCODE)

 Example:

root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

Return 3. The paths that sum to 8 are:

1.  5 -> 3
2.  5 -> 2 -> 1
3. -3 -> 11
----------------------------------------------------------------

     int sumUp(TreeNode* root, int pre, int& sum)
    {
        if(!root) return 0;
        int current = pre + root->val;
        return (current == sum) + sumUp(root->left, current, sum) + sumUp(root->right, current, sum);
    }

class Solution
{
  public:
    int pathSum(TreeNode* root, int sum) 
    {
        if(!root) return 0;
        return sumUp(root, 0, sum) + pathSum(root->left, sum) + pathSum(root->right, sum);
    }
};

time: O(n)
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 
 Path Sum IV

 

























///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  Sum Root to Leaf Numbers

 Example:
Input: [1,2,3]
    1
   / \
  2   3
Output: 25
Explanation:
The root-to-leaf path 1->2 represents the number 12.
The root-to-leaf path 1->3 represents the number 13.
Therefore, sum = 12 + 13 = 25.

Example 2:
Input: [4,9,0,5,1]
    4
   / \
  9   0
 / \
5   1
Output: 1026
Explanation:
The root-to-leaf path 4->9->5 represents the number 495.
The root-to-leaf path 4->9->1 represents the number 491.
The root-to-leaf path 4->0 represents the number 40.
Therefore, sum = 495 + 491 + 40 = 1026.
--------------------------------------------------------------

void sumHelper(TreeNode* root,int val,int &sum)
    {
        if(!root)
            return;
        val=val*10+root->val;
        if(!root->left and !root->right)
        {
            sum+=val;
            val-=root->val;
        }
        sumHelper(root->left,val,sum);
        sumHelper(root->right,val,sum);
    }
 

class Solution {
public:
    
    int sumNumbers(TreeNode* root) 
    {
        int sum=0;
        sumHelper(root,0,sum);
        return sum;
    }
};
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 Construct Binary Tree from inorder and preorder

Note:
You may assume that duplicates do not exist in the tree.

For example, given
preorder = [3,9,20,15,7]
inorder = [9,3,15,20,7]
Return the following binary tree:

    3
   / \
  9  20
    /  \
   15   7
--------------------------------------------------------------------------

class Solution {
public:
    unordered_map<int, int>memo;
TreeNode* buildTreeUtil(vector<int>&inorder, int is, int ie, vector<int>&preorder, int ps, int pe){
    if(is > ie || ps > pe)return NULL;
    int data = preorder[ps];
    TreeNode* root = new TreeNode(data);
    
    int inIdx = memo[data];
    int nodesOnLeft = inIdx-is;
    root->left = buildTreeUtil(inorder, is, inIdx-1, preorder, ps+1, ps+nodesOnLeft);
    root->right = buildTreeUtil(inorder, inIdx+1, ie, preorder, ps+nodesOnLeft+1, pe);
    return root;
}
    
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if(preorder.size() == 0 || inorder.size() == 0 || preorder.size() != inorder.size())return         NULL;
    for(int i = 0; i < inorder.size(); ++i){
        memo[inorder[i]] = i;
    }
    return buildTreeUtil(inorder, 0, inorder.size()-1, preorder, 0, preorder.size()-1);
    }
};

TIME: O(N)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Construct Binary Tree from Inorder and Postorder

You may assume that duplicates do not exist in the tree.

For example, given

inorder = [9,3,15,20,7]
postorder = [9,15,7,20,3]
Return the following binary tree:

    3
   / \
  9  20
    /  \
   15   7
----------------------------------------------------------------------------

class Solution {
public:
    
     TreeNode* helper(vector<int> &inorder,vector<int> &postorder,int inStart, int inEnd, int postIndex,unordered_map<int,int> &u)
    {
        if(inStart>inEnd || postIndex<0)
            return NULL;
        TreeNode* root=new TreeNode(postorder[postIndex]);
        int index=-1;
        if(u.find(postorder[postIndex])!=u.end())
            index=u[postorder[postIndex]];
        
        root->right=helper(inorder,postorder,index+1,inEnd,postIndex-1,u);
        root->left=helper(inorder,postorder,inStart,index-1,postIndex-(inEnd-index+1),u);
        return root;
        
    }
   
    
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder)
    {
           unordered_map<int,int> u;
            for(int i=0;i<inorder.size();i++)
            {
                u[inorder[i]]=i;
            }
            return helper(inorder,postorder,0,inorder.size()-1,postorder.size()-1,u);
    }
};

TIME: O(n).
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  Flatten Binary Tree to Linked List

For example, given the following tree:

    1
   / \
  2   5
 / \   \
3   4   6
The flattened tree should look like:

1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
-------------------------------------------------------

class Solution {
public:
    void flatten(TreeNode* root) {
           if (!root) return;

        TreeNode* node = root;
        while (node) {

            if (node->left) 
            {
                TreeNode *rightMost = node->left;
                while (rightMost->right) 
                {
                    rightMost = rightMost->right;
                }
                rightMost->right = node->right;
                node->right = node->left;
                node->left = NULL;
            }
            node = node->right;
        }
    }
};

TIME: O(N)
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Check if Binary Tree is mirror of itself or not
    OR
Symmetric Tree

For example, this binary tree [1,2,2,3,4,4,3] is symmetric:

    1
   / \
  2   2
 / \ / \
3  4 4  3
 

But the following [1,2,2,null,3,null,3] is not:

    1
   / \
  2   2
   \   \
   3    3
--------------------------------------

SOLUTION 1: (RECURSIVE)

class Solution {
public:
     bool isMirror(TreeNode* t1, TreeNode* t2) {
     if (t1 == NULL && t2 == NULL) return true;
    if (t1 == NULL || t2 == NULL) return false;
    return (t1->val == t2->val)
        && isMirror(t1->right, t2->left)
        && isMirror(t1->left, t2->right);
     }
    bool isSymmetric(TreeNode* root) {
      return isMirror(root, root);
    }
};

TIME AND SPACE: O(N).
...................................................

SOLUTION 2: (ITERATION)

class Solution {
public:
   
    bool isSymmetric(TreeNode* root) {
      stack<pair<TreeNode*, TreeNode*>> st;
    st.emplace(root, root);
    while (!st.empty()) 
    {
      pair<TreeNode*, TreeNode*> cur = st.top(); st.pop();
      if (cur.first == nullptr && cur.second == nullptr) continue;
      if (cur.first != nullptr && cur.second == nullptr) return false;
      if (cur.first == nullptr && cur.second != nullptr) return false;
      if (cur.first->val != cur.second->val) return false;
      st.emplace(cur.first->left, cur.second->right);
      st.emplace(cur.first->right, cur.second->left);
    }
    return true;
    }
};

TIME AND SPACE: O(N)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 create bst
   OR
  Function to create a new Node in heap
  ---------------------------------------------------
  
  BstNode* GetNewNode(int data) {
    BstNode* newNode = new BstNode();
    newNode->data = data;
    newNode->left = newNode->right = NULL;
    return newNode;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Insert into a Binary Search Tree


For example, 

Given the tree:
        4
       / \
      2   7
     / \
    1   3
And the value to insert: 5
You can return this binary search tree:

         4
       /   \
      2     7
     / \   /
    1   3 5
This tree is also valid:

         5
       /   \
      2     7
     / \   
    1   3
         \
          4
------------------------------------------------------------------

class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
    if (root == NULL) {
        return false;
    }
    else if (root->val == val) {
        return true;
    }
    else if (val <= root->val) {
        return searchBST(root->left, val);
    }
    else {
        return searchBST(root->right, val);
    }
    }
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 To search an element in BST, returns true if element is found

 ---------------------------------
 bool Search(BstNode* root, int data) {
    if (root == NULL) {
        return false;
    }
    else if (root->data == data) {
        return true;
    }
    else if (data <= root->data) {
        return Search(root->left, data);
    }
    else {
        return Search(root->right, data);
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Populating Next Right Pointers in Each Node
.................................................

PROBLEM STATEMENT : You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.
Initially, all next pointers are set to NULL.

Follow up:
You may only use constant extra space.
Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.
 
Example 1:
Input: root = [1,2,3,4,5,6,7]
Output: [1,#,2,3,#,4,5,6,7,#]
Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.

--------------------------------------------------------------------------------------------------


class Solution {
public:
    Node* connect(Node* root) {
        if(root == nullptr) return root;
        int count = 0;
        queue<Node*> q;
        q.push(root);
        
        while(!q.empty())
        {
            int count = q.size();
            while(count--)
            {
                Node* curr = q.front();
                q.pop();
                  if(count == 0) curr->next = nullptr;
                else
                    curr->next = q.front();
                if(curr->left) q.push(curr->left);
                if(curr->right) q.push(curr->right);
            }
        }
        return root;
    }
};
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Construct balanced BST from given keys.
         OR
Construct BST from given keys
----------------------------------------

#include<bits/stdc++.h>
using namespace std;

class node {

  int data;
  node* left, *right;
};

node* newnode(int key)
{
  node* root = new node;
  root->data = key;
  root->left = root->right = NULL;
  return root;
}

void inorder(node* root)
{
  if (!root) return;
  inorder(root->left);
  cout << root->data << " ";
  inorder(root->right);
}

node* insert(node* root, int key)
{
  if (!root) return newnode(key);
  if (key < root->data)
    root->left = insert(root->left, key);
  if (key > root->data)
    root->right = insert(root->right, key);
  return root;
}


void conv(int a[], int l, int r, node* &root)
{
  if (l > r)return ;

  int mid = l + ((r - l) >> 1);
  root = newnode(a[mid]);
  conv(a, l, mid - 1, root->left);
  conv(a, mid + 1, r, root->right);
}

node* convert(int a[], int n)
{
  sort(a, a + n);
  node* root = NULL;
  conv(a, 0, n - 1, root);
  return root;
}


signed main()
{
#ifndef ONLINE_JUDGE
  freopen ("input.txt", "r", stdin);
  freopen ("output.txt", "w", stdout);
#endif

  int n;
  cin >> n;

  int a[n];
  for (int i = 0; i < n; i++)
    cin >> a[i];

  node* root = convert(a, n);
  inorder(root);
  return 0;

}

TIME COMPLEXITY: O(nlogn).
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 Validate Binary Search Tree
     OR
   check is a bt is bst or not leetcode


Example 1:

    2
   / \
  1   3
Input: [2,1,3]
Output: true
Example 2:

    5
   / \
  1   4
     / \
    3   6
Input: [5,1,4,null,null,3,6]
Output: false
Explanation: The root node's value is 5 but its right child's value is 4.
--------------------

APPROACH 1: (RECURSION)

class Solution {
  public :
  bool helper(TreeNode* root, long lower, long upper) {
    if (!root) return true;

    return (lower<root->val && root->val<upper && helper(root->left, lower, root->val) && helper(root->right, root->val, upper));
  }

    bool isValidBST(TreeNode* root) {
    return helper(root,LONG_MIN, LONG_MAX);
  }
};

Time complexity : O(N) since we visit each node exactly once.
Space complexity : O(N) since we keep up to the entire tree.
........................................................

APPROACH 2: (ITERATIVE SOLUTION)

class Solution {
public :
  bool isValidBST(TreeNode* root) {
    if (root == NULL) return true;
    stack<TreeNode*> st;
    TreeNode *curr = root;
    TreeNode *prev = NULL;

    while (curr != NULL || !st.empty()) {

      while (curr != NULL) {
        st.push(curr);
        curr = curr->left;
      }
      curr = st.top(); st.pop();
      if (prev != NULL && prev->val >= curr->val) return false;
      prev = curr;
      curr = curr->right;
    }
    return true;
  }
};

Time complexity : O(N) since we visit each node exactly once.
Space complexity : O(N) since we keep up to the entire tree.

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Search in a Binary Search Tree
  OR
Search given Key in BST



INPUT: Given the tree:
        4
       / \
      2   7
     / \
    1   3
And the value to search: 2

 OUTPUT: You should return this subtree:

      2     
     / \   
    1   3
---------------------------------

class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
    while (root != nullptr && root->val != val) 
    {
      if(root->val > val) 
          root=root->left ;
        else
            root=root->right;
    }
    return root;
    }
};

TIME: O(N).
SPACE: O(1).
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Find the closest element in Binary Search Tree  (gfg)

Input  :  k = 4
Output :  4

Input  :  k = 18
Output :  17

Input  :  k = 12
Output :  9
-----------

SOLUTION 1: (TIME EFFICIENT)

#include<bits/stdc++.h> 
using namespace std; 

/* A binary tree node has key, pointer to left child 
and a pointer to right child */
struct Node 
{ 
	int key; 
	struct Node* left, *right; 
}; 

/* Utility that allocates a new node with the 
given key and NULL left and right pointers. */
struct Node* newnode(int key) 
{ 
	struct Node* node = new (struct Node); 
	node->key = key; 
	node->left = node->right = NULL; 
	return (node); 
} 

// Function to find node with minimum absolute 
// difference with given K 
// min_diff --> minimum difference till now 
// min_diff_key --> node having minimum absolute 
//				 difference with K 
void maxDiffUtil(struct Node *ptr, int k, int &min_diff, 
									int &min_diff_key) 
{ 
	if (ptr == NULL) 
		return ; 

	// If k itself is present 
	if (ptr->key == k) 
	{ 
		min_diff_key = k; 
		return; 
	} 

	// update min_diff and min_diff_key by checking 
	// current node value 
	if (min_diff > abs(ptr->key - k)) 
	{ 
		min_diff = abs(ptr->key - k); 
		min_diff_key = ptr->key; 
	} 

	// if k is less than ptr->key then move in 
	// left subtree else in right subtree 
	if (k < ptr->key) 
		maxDiffUtil(ptr->left, k, min_diff, min_diff_key); 
	else
		maxDiffUtil(ptr->right, k, min_diff, min_diff_key); 
} 

// Wrapper over maxDiffUtil() 
int maxDiff(Node *root, int k) 
{ 
	// Initialize minimum difference 
	int min_diff = INT_MAX, min_diff_key = -1; 

	// Find value of min_diff_key (Closest key 
	// in tree with k) 
	maxDiffUtil(root, k, min_diff, min_diff_key); 

	return min_diff_key; 
} 

// Driver program to run the case 
int main() 
{ 
	struct Node *root = newnode(9); 
	root->left = newnode(4); 
	root->right = newnode(17); 
	root->left->left = newnode(3); 
	root->left->right = newnode(6); 
	root->left->right->left = newnode(5); 
	root->left->right->right = newnode(7); 
	root->right->right = newnode(22); 
	root->right->right->left = newnode(20); 
	int k = 18; 
	cout << maxDiff(root, k); 
	return 0; 
} 

Time complexity : O(h) where h is height of given Binary Search Tree

............................................

ALTERNATE METHOD : (SPACE EFFICIENT)

// CPP program to find closest value in 
// a Binary Search Tree. 
#include <iostream> 
#include <limits.h> 
using namespace std; 

// Tree Node 
struct Node { 
	int data; 
	Node *left, *right; 
}; 

// Utility function to create a new Node 
Node* newNode(int data) 
{ 
	Node* temp = new Node(); 
	temp->data = data; 
	temp->left = temp->right = NULL; 
	return temp; 
} 

// Function to find the Node closest to the 
// given key in BST using Morris Traversal 
Node* closestNodeUsingMorrisTraversal(Node* root, 
										int key) 
{ 
	int diff = INT_MAX; 
	Node* curr = root; 
	Node* closest; 

	while (curr) { 
		if (curr->left == NULL) { 

			// updating diff if the current diff is 
			// smaller than prev difference 
			if (diff > abs(curr->data - key)) { 
				diff = abs(curr->data - key); 
				closest = curr; 
			} 

			curr = curr->right; 
		} 

		else { 

			// finding the inorder predecessor 
			Node* pre = curr->left; 
			while (pre->right != NULL && 
				pre->right != curr) 
				pre = pre->right; 

			if (pre->right == NULL) { 
				pre->right = curr; 
				curr = curr->left; 
			} 

			// threaded link between curr and 
			// its predecessor already exists 
			else { 
				pre->right = NULL; 

				// if a closer Node found, then update 
				// the diff and set closest to current 
				if (diff > abs(curr->data - key)) { 
					diff = abs(curr->data - key); 
					closest = curr; 
				} 

				// moving to the right child 
				curr = curr->right; 
			} 
		} 
	} 

	return closest; 
} 

// Driver Code 
int main() 
{ 
	/* Constructed binary tree is 
		5 
		/ \ 
	3	 9 
	/ \ / \ 
	1 2 8 12 */
	Node* root = newNode(5); 
	root->left = newNode(3); 
	root->right = newNode(9); 
	root->left->left = newNode(1); 
	root->left->right = newNode(2); 
	root->right->left = newNode(8); 
	root->right->right = newNode(12); 

	cout << closestNodeUsingMorrisTraversal(root, 10)->data; 

	return 0; 
} 

Time Complexity: O(n)
Auxillary Space : O(1)
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


Lowest Common Ancestor of a Binary Search Tree
           OR
Find LCA of two nodes in BST

Example 1:

Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
Output: 6
Explanation: The LCA of nodes 2 and 8 is 6.
Example 2:

Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
Output: 2
Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.
 

Constraints:

All of the nodes' values will be unique.
p and q are different and both values will exist in the BST.
----------------------

SOLUTION 1: (Recursive Approach)

class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
          // Value of current node or parent node.
        int parentVal = root->val;

        // Value of p
        int pVal = p->val;

        // Value of q;
        int qVal = q->val;

        if (pVal > parentVal && qVal > parentVal) {
            // If both p and q are greater than parent
            return lowestCommonAncestor(root->right, p, q);
        } else if (pVal < parentVal && qVal < parentVal) {
            // If both p and q are lesser than parent
            return lowestCommonAncestor(root->left, p, q);
        } else {
            // We have found the split point, i.e. the LCA node.
            return root;
    }
    }
};

Complexity Analysis
Time Complexity: O(N), where N is the number of nodes in the BST. In the worst case we might be visiting all the nodes of the BST.
Space Complexity: O(N). This is because the maximum amount of space utilized by the recursion stack would be N since the height of a skewed BST could be N.
...........

SOLUTION 2: (Iterative Approach)

class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        // Value of p
        int pVal = p->val;

        // Value of q;
        int qVal = q->val;
        
       // Start from the root node of the tree
        TreeNode* node = root;

        // Traverse the tree
        while (node != NULL) {

            // Value of ancestor/parent node.
            int parentVal = node->val;

            if (pVal > parentVal && qVal > parentVal) {
                // If both p and q are greater than parent
                node = node->right;
            } else if (pVal < parentVal && qVal < parentVal) {
                // If both p and q are lesser than parent
                node = node->left;
            } else {
                // We have found the split point, i.e. the LCA node.
                return node;
            }
        }
        return NULL;
    }
};

Time Complexity : O(N), where N is the number of nodes in the BST. In the worst case we might be visiting all the nodes of the BST.
Space Complexity : O(1)
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Find the inorder predecessor/successor of a given Key in BST.
-----------------------------------------

  #include <iostream>
using namespace std;

// BST Node
struct Node
{
  int key;
  struct Node *left, *right;
};

// This function finds predecessor and successor of key in BST.
// It sets pre and suc as predecessor and successor respectively
void findPreSuc(Node* root, Node*& pre, Node*& suc, int key)
{
  // Base case
  if (root == NULL)  return ;

  // If key is present at root
  if (root->key == key)
  {
    // the maximum value in left subtree is predecessor
    if (root->left != NULL)
    {
      Node* tmp = root->left;
      while (tmp->right)
        tmp = tmp->right;
      pre = tmp ;
    }

    // the minimum value in right subtree is successor
    if (root->right != NULL)
    {
      Node* tmp = root->right ;
      while (tmp->left)
        tmp = tmp->left ;
      suc = tmp ;
    }
    return ;
  }

  // If key is smaller than root's key, go to left subtree
  if (root->key > key)
  {
    suc = root ;
    findPreSuc(root->left, pre, suc, key) ;
  }
  else // go to right subtree
  {
    pre = root ;
    findPreSuc(root->right, pre, suc, key) ;
  }
}

// A utility function to create a new BST node
Node *newNode(int item)
{
  Node *temp =  new Node;
  temp->key = item;
  temp->left = temp->right = NULL;
  return temp;
}

/* A utility function to insert a new node with given key in BST */
Node* insert(Node* node, int key)
{
  if (node == NULL) return newNode(key);
  if (key < node->key)
    node->left  = insert(node->left, key);
  else
    node->right = insert(node->right, key);
  return node;
}

// Driver program to test above function
int main()
{
  int key = 65;    //Key to be searched in BST

  /* Let us create following BST
             50
          /     \
         30      70
        /  \    /  \
      20   40  60   80 */
  Node *root = NULL;
  root = insert(root, 50);
  insert(root, 30);
  insert(root, 20);
  insert(root, 40);
  insert(root, 70);
  insert(root, 60);
  insert(root, 80);


  Node* pre = NULL, *suc = NULL;

  findPreSuc(root, pre, suc, key);
  if (pre != NULL)
    cout << "Predecessor is " << pre->key << endl;
  else
    cout << "No Predecessor";

  if (suc != NULL)
    cout << "Successor is " << suc->key;
  else
    cout << "No Successor";
  return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  Find the inorder predecessor of a given Key in BST.
--------------------------------------------------

#include <iostream>
using namespace std;

// Data structure to store a Binary Search Tree node
struct Node {
	int data;
	Node *left, *right;
};

// Function to create a new binary tree node having given key
Node* newNode(int key)
{
	Node* node = new Node;
	node->data = key;
	node->left = node->right = nullptr;

	return node;
}

// Recursive function to insert a key into BST
Node* insert(Node* root, int key)
{
	// if the root is null, create a new node and return it
	if (root == nullptr)
		return newNode(key);

	// if given key is less than the root node, recur for left subtree
	if (key < root->data)
		root->left = insert(root->left, key);

	// if given key is more than the root node, recur for right subtree
	else
		root->right = insert(root->right, key);

	return root;
}

// Helper function to find maximum value node in given BST
Node* findMaximum(Node* root)
{
	while (root->right)
		root = root->right;

	return root;
}

// Iterative function to find in-order predecessor for given key in a BST
Node* findPredecessor(Node* root, int key)
{
	Node* prec = nullptr;

	while (1)
	{
		// if given key is less than the root node, visit left subtree
		if (key < root->data)
		{
			root = root->left;
		}

		// if given key is more than the root node, visit right subtree
		else if (key > root->data)
		{
			// update predecessor to current node before visiting
			// right subtree
			prec = root;
			root = root->right;
		}

		// if node with key's value is found, predecessor is maximum value
		// node in its left subtree (if any)
		else
		{
			if (root->left)
				prec = findMaximum(root->left);
			break;
		}

		// if key doesn't exist in binary tree
		if (!root)
			return nullptr;
	}

	// return predecessor if any
	return prec;
}

int main()
{
	/* Construct below tree
               15
             /    \
            /      \
           10       20
          / \      /  \
         /   \    /    \
        8    12  16    25
	*/

	int keys[] = { 15, 10, 20, 8, 12, 16, 25 };

	Node* root = nullptr;
	for (int key : keys)
		root = insert(root, key);

	// find in-order predecessor for each key
	for (int key : keys)
	{
		Node* prec = findPredecessor(root, key);

		if (prec != nullptr)
			cout << "Predecessor of node " << key << " is " << prec->data << '\n';
		else
			cout << "Predecessor doesn't exists for " << key << '\n';
	}

	return 0;
}

OUTPUT: 
        Predecessor of node 15 is 12.
        Predecessor of node 10 is 8
        Predecessor of node 20 is 16
        Predecessor does not exist for node 8.
        Predecessor of node 12 is 10
        Predecessor of node 16 is 15
        Predecessor of node 25 is 20

TIME : O(N).
SPACE: O(1).
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

   Find the inorder successor of a given Key in BST.
-------------------------------------------------

#include <iostream>
using namespace std;

struct Node {
	int data;
	Node *left, *right;
};

// Function to create a new binary tree node having given key
Node* newNode(int key)
{
	Node* node = new Node;
	node->data = key;
	node->left = node->right = nullptr;

	return node;
}

// Recursive function to insert a key into BST
Node* insert(Node* root, int key)
{
	// if the root is null, create a new node and return it
	if (root == nullptr)
		return newNode(key);

	// if given key is less than the root node, recur for left subtree
	if (key < root->data)
		root->left = insert(root->left, key);

	// if given key is more than the root node, recur for right subtree
	else
		root->right = insert(root->right, key);

	return root;
}

// Helper function to find minimum value node in given BST
Node* findMinimum(Node* root)
{
	while (root->left)
		root = root->left;

	return root;
}

// Iterative function to find inorder successor for given key in a BST
Node* findSuccessor(Node* root, int key)
{
	Node* succ = nullptr;

	while (1)
	{
		// if given key is less than the root node, visit left subtree
		if (key < root->data)
		{
			// update successor to current node before visiting left subtree
			succ = root;
			root = root->left;
		}

		// if given key is more than the root node, visit right subtree
		else if (key > root->data)
		{
			root = root->right;
		}

		// if node with key's value is found, the successor is minimum value
		// node in its right subtree (if any)
		else
		{
			if (root->right)
				succ = findMinimum(root->right);
			break;
		}

		// if key doesn't exist in binary tree
		if (!root)
			return nullptr;
	}

	// return Successor if any
	return succ;
}

int main()
{
	/* Construct below tree
               15
             /    \
            /      \
           10       20
          / \      /  \
         /   \    /    \
        8    12  16    25
	*/

	int keys[] = { 15, 10, 20, 8, 12, 16, 25 };

	Node* root = nullptr;
	for (int key : keys)
		root = insert(root, key);

	// find in-order successor for each key
	for (int key : keys)
	{
		Node* prec = findSuccessor(root, key);

		if (prec != nullptr)
			cout << "Successor of node " << key << " is " << prec->data;
		else
			cout << "Successor doesn't exists for " << key;

		cout << '\n';
	}

	return 0;
}

OUTPUT: 
         Successor of node 15 is 16.
         Successor of node 10 is 12
         Successor of node 20 is 25
         Successor of node 8  is 10
         Successor of node 12 is 15
         Successor of node 16 is 20
         Successor of node 25 is 25

TIME : O(N).
SPACE: O(1).
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  Ceil in a BST

-----------------------------------


#include <bits/stdc++.h> 
using namespace std; 

class node { 
public: 
	int key; 
	node* left; 
	node* right; 
}; 

node* newNode(int key) 
{ 
	node* Node = new node(); 
	Node->key = key; 
	Node->left = NULL; 
	Node->right = NULL; 
	return (Node); 
} 

int Ceil(node* root, int input) 
{ 
	if (root == NULL) 
		return -1; 

	if (root->key == input) 
		return root->key; 

	if (root->key < input) 
		return Ceil(root->right, input); 

	int ceil = Ceil(root->left, input); 
	return (ceil >= input) ? ceil : root->key; 
} 


int main() 
{ 
	node* root = newNode(8); 

	root->left = newNode(4); 
	root->right = newNode(12); 

	root->left->left = newNode(2); 
	root->left->right = newNode(6); 

	root->right->left = newNode(10); 
	root->right->right = newNode(14); 

	for (int i = 0; i < 16; i++) 
		cout << i << " " << Ceil(root, i) << endl; 

	return 0; 
} 

Output:
0  2
1  2
2  2
3  4
4  4
5  6
6  6
7  8
8  8
9  10
10  10
11  12
12  12
13  14
14  14
15  -1
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  Floor in Binary Search Tree (BST)

Input : x = 14 and root of below tree
            10
           /  \
          5    15
              /  \
            12    30
Output : 12

Input : x = 15 and root of below tree
            10
           /  \
          5    15
              /  \
            12    30
Output : 15    
-----------------------------------
#include <bits/stdc++.h>
using namespace std;

struct Node {
  int data;
  Node *left, *right;
};

Node* newNode(int key)
{
  Node* temp = new Node;
  temp->left = temp->right = NULL;
  temp->data = key;
  return temp;
}

Node* insert(Node* root, int key)
{
  if (!root)
    return newNode(key);
  if (key < root->data)
    root->left = insert(root->left, key);
  else
    root->right = insert(root->right, key);
  return root;
}

int floor(Node* root, int key)
{
  if (!root)
    return INT_MAX;

  if (root->data == key)
    return root->data;

  if (root->data > key)
    return floor(root->left, key);

  int floorValue = floor(root->right, key);
  return (floorValue <= key) ? floorValue : root->data;
}

int main()
{
  Node* root = NULL;
  root = insert(root, 7);
  insert(root, 10);
  insert(root, 5);
  insert(root, 3);
  insert(root, 6);
  insert(root, 8);
  insert(root, 12);
  cout << floor(root, 9) << endl;
  return 0;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Floor value Kth root of a number using Recursive Binary Search

Examples:

Input: N = 27, K = 3
Output: 3
Explanation:
Kth root of 27 = 3. Therefore 3 is the greatest whole number less than equal to Kth root of 25.

Input: N = 36, K = 3
Output: 3
Explanation:
Kth root of 36 = 3.30
Therefore 3 is the greatest whole number less than equal to Kth root of 36 (3.30)
-------------------------------------------------------------

#include <bits/stdc++.h>
using namespace std;

int power(int x, unsigned int y)
{
  int temp;
  if (y == 0)
    return 1;
  temp = power(x, y / 2);
  if (y % 2 == 0)
    return temp * temp;
  else
    return x * temp * temp;
}

int nthRootSearch(int low, int high,
                  int N, int K)
{
  if (low <= high)
  {
    int mid = (low + high) / 2;

    if ((power(mid, K) <= N)
        && (power(mid + 1, K) > N)) {
      return mid;
    }

    else if (power(mid, K) < N) {
      return nthRootSearch(mid + 1,
                           high, N, K);
    }
    else {
      return nthRootSearch(low,
                           mid - 1,
                           N, K);
    }
  }
  return low;
}

int main()
{
  int N = 16, K = 4;
  cout << nthRootSearch(0, N, N, K)
       << endl;
  return 0;
}

OUTPUT: 2
Time Complexity: O(log N)
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Product of all Subarrays of an Array
--------------------------------

#include <bits/stdc++.h> 
using namespace std; 

void product_subarrays(long long int arr[], int n) 
{ 
  long long int res = 1; 

  for (int i = 0; i < n; i++) { 
    long long int product = 1; 
    for (int j = i; j < n; j++) { 
      product = product * arr[j]; 
      res *= product; 
    } 
  } 
    cout << res << "\n"; 
} 

int main() 
{ 
  long long int arr[] = { 10, 3, 7 }; 
  int n = sizeof(arr) / sizeof(arr[0]); 
  product_subarrays(arr, n); 
  return 0; 
} 

Output:
30870
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Floor and ceil in BST
------------------------------------------

#include <iostream>
#include <iomanip>
using namespace std;

struct Node {
	int data;
	Node *left, *right;
};

Node* newNode(int key)
{
	Node* node = new Node;
	node->data = key;
	node->left = node->right = nullptr;

	return node;
}

Node* insert(Node* root, int key)
{
	if (root == nullptr)
		return newNode(key);

	if (key < root->data)
		root->left = insert(root->left, key);
	else
		root->right = insert(root->right, key);

	return root;
}

void findFloorCeil(Node* root, Node* &floor, Node* &ceil, int key)
{
	while (root)
	{
		if (root->data == key)
		{
			floor = root;
			ceil = root;
			break;
		}

		else if (key < root->data)
		{
			ceil = root;
			root = root->left;
		}

		else
		{
			floor = root;
			root = root->right;
		}
	}
}

int main()
{
	int keys[] = { 2, 4, 6, 8, 9, 10, 12 };
	Node* root = nullptr;
	
   for (int key : keys)
    root = insert(root, key);

   for (int i = 0; i < 15; i++)
	{
		Node *floor = nullptr, *ceil = nullptr;
		findFloorCeil(root, floor, ceil, i);

		cout << setw(2) << i << " --> ";
		cout << setw(4) << (floor? floor->data: -1);
		cout << setw(4) << (ceil? ceil->data: -1) << endl;
	}
	return 0;
}

OUTPUT:
 0 -->   -1   2
 1 -->   -1   2
 2 -->    2   2
 3 -->    2   4
 4 -->    4   4
 5 -->    4   6
 6 -->    6   6
 7 -->    6   8
 8 -->    8   8
 9 -->    9   9
10 -->   10  10
11 -->   10  12
12 -->   12  12
13 -->   12  -1
14 -->   12  -1

 
TIME: O(N).
SPACE: O(1).
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Second Minimum Node In a Binary Tree

Example 1:

Input: 
    2
   / \
  2   5
     / \
    5   7

Output: 5
Explanation: The smallest value is 2, the second smallest value is 5.
 

Example 2:

Input: 
    2
   / \
  2   2

Output: -1
Explanation: The smallest value is 2, but there isn't any second smallest value.
--------------------------------------

class Solution {
public:

     void inorder(TreeNode* root, set<int>&res)
    {
        if(!root) return;
        inorder(root->left,res);
        res.insert(root->val);
        inorder(root->right,res);
    }
    
    
    int findSecondMinimumValue(TreeNode* root) {
        set<int>v;
        inorder(root, v);
        
        int n=v.size();
        if(n>=2)
        {
            auto it=v.begin();
            advance(it,1);
            return *it;
        }
        return -1;
    }
};
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    Kth Smallest Element in a BST

Example 1:

Input: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
Output: 1
Example 2:

Input: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
Output: 3
--------------------------------------
  
SOLUTION 1: (RECURSIVE METHOD)

class Solution {
public:
    
    void inorder(TreeNode* root, set<int>&res)
    {
        if(!root) return;
        inorder(root->left,res);
        res.insert(root->val);
        inorder(root->right,res);
    }
    
    int kthSmallest(TreeNode* root, int k) 
    {
        set<int>v;
        inorder(root, v);
        
        int n=v.size();
        if(n>=k)
        {
            auto it=v.begin();
            advance(it,k-1);
            return *it;
        }
        return -1;
    }
};
............................

SOLUTION2 : (ITERATIVE METHOD)
















////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Find a pair with a given sum in BST
       
Input : sum = 28
        Root of below tree
Output : Pair is found (16, 12)
-----------------------------------------------------

#include <bits/stdc++.h>
using namespace std;

struct Node
{
	int data;
	struct Node *left, *right;
};

Node* NewNode(int data)
{
	Node* temp = (Node*)malloc(sizeof(Node));
	temp->data = data;
	temp->left = NULL;
	temp->right = NULL;
	return temp;
}

Node* insert(Node* root, int key)
{
	if (root == NULL)
		return NewNode(key);
	if (key < root->data)
		root->left = insert(root->left, key);
	else
		root->right = insert(root->right, key);
	return root;
}

bool findpairUtil(Node* root, int sum, unordered_set<int> &set)
{
	if (root == NULL)
		return false;

	if (findpairUtil(root->left, sum, set))
		return true;

	if (set.find(sum - root->data) != set.end()) {
		cout << "Pair is found ("
		     << sum - root->data << ", "
		     << root->data << ")" << endl;
		return true;
	}
	else
		set.insert(root->data);

	return findpairUtil(root->right, sum, set);
}

void findPair(Node* root, int sum)
{
	unordered_set<int> set;
	if (!findpairUtil(root, sum, set))
		cout << "Pairs do not exit" << endl;
}

int main()
{

#ifndef ONLINE_JUDGE
	// for getting input from input.txt
	freopen("input.txt", "r", stdin);
	// for writing output to output.txt
	freopen("output.txt", "w", stdout);
#endif

	Node* root = NULL;
	root = insert(root, 15);
	root = insert(root, 10);
	root = insert(root, 20);
	root = insert(root, 8);
	root = insert(root, 12);
	root = insert(root, 16);
	root = insert(root, 25);
	root = insert(root, 10);

	int sum = 33;
	findPair(root, sum);

	return 0;
}

TIME : O(N)

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  BST iterator

 Example:
BSTIterator iterator = new BSTIterator(root);
iterator.next();    // return 3
iterator.next();    // return 7
iterator.hasNext(); // return true
iterator.next();    // return 9
iterator.hasNext(); // return true
iterator.next();    // return 15
iterator.hasNext(); // return true
iterator.next();    // return 20
iterator.hasNext(); // return false
 
Note:
next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.
You may assume that next() call will always be valid, that is, there will be at least a next smallest number in the BST when next() is called.
-----------------------------------


class BSTIterator {

    stack<TreeNode*> st;
    
    void find_left(TreeNode* root)
    {
        TreeNode* p = root;
        while (p != NULL)
        {
            st.push(p);
            p = p->left;
        }
    }

public:
    
    BSTIterator(TreeNode *root) 
    {
        find_left(root);
    }

    
    bool hasNext() 
    {
        if (st.empty())
            return false;
        return true;
    }

    int next()
    {
        TreeNode* top = st.top();
        st.pop();
        if (top->right != NULL)
            find_left(top->right);
            
        return top->val;
    }
};

O(1) time and uses O(h) memory

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Size of the largest BST in a Binary Tree
            OR
Maximum Sum BST in Binary Tree

Example 1:
Input: root = [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6]
Output: 20
Explanation: Maximum sum in a valid Binary search tree is obtained in root node with key equal to 3.

Example 2:
Input: root = [4,3,null,1,2]
Output: 2
Explanation: Maximum sum in a valid Binary search tree is obtained in a single root node with key equal to 2.

Example 3:
Input: root = [-4,-2,-5]
Output: 0
Explanation: All values are negatives. Return an empty BST.

Example 4:
Input: root = [2,1,3]
Output: 6

Example 5:
Input: root = [5,4,8,3,null,6,3]
Output: 7
---------------------------------------------------------------------------------------------------------

class Solution 
{
 public:
    int max_sum=0;
    
    vector<int>dfs(TreeNode* n)
    {
    auto l = n->left ? dfs(n->left) : vector<int>{0, n->val, n->val - 1};
    auto r = n->right ? dfs(n->right) : vector<int>{0, n->val + 1, n->val};
    if (l[2] < n->val && n->val < r[1]) {
        max_sum = max(max_sum, n->val + l[0] + r[0]);
        return {n->val + l[0] + r[0], l[1], r[2]};        
    }
    return {0, INT_MIN, INT_MAX};
}
    
    int maxSumBST(TreeNode* root)
   {
        dfs(root);
        return max_sum;
    }
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




















///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 Depth first search 

EXAMPLE: 

6 5
1 2
1 3
1 4
2 5
2 6

OUTPUT:

1-->2-->5-->6-->3-->4-->

-----------------------------

 #include<bits/stdc++.h>
using namespace std;

vector<int>adj[100005];
vector<int>vis(100005);

void dfs(int s)
{
	vis[s] = 1;
	cout << s << "-->";
	for (auto x : adj[s])
	{
		if (!vis[x])
			dfs(x);
	}
}

signed main()
{
	int n, e;
	cin >> n >> e;

	while (e--)
	{
		int a, b;
		cin >> a >> b;
		adj[a].push_back(b);
		adj[b].push_back(a);
	}
	dfs(1);

}

TIME: O(V+E)
SPACE: O(E)
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

BIPARTITE CHECK 

EXAMPLE 1:
5 5
1 2
2 3
2 4
3 4
4 5
OUTPUT: NO

EXAMPLE 2:
5 4
1 2
2 3
3 4
4 5

OUTPUT: YES
-----------------------------------------------------------

#include<bits/stdc++.h>
using namespace std;

vector<int>adj[100005];
vector<int>vis(100005);
vector<int>col(100005);

bool dfs(int s, int c)
{
	vis[s] = 1;
	col[s] = c;

	for (auto x : adj[s])
	{
		if (!vis[x])
		{
			if (dfs(x, c ^ 1) == 0)
				return 0;
		}
		else
		{
			if (col[x] == col[s])
				return 0;
		}
	}
	return 1;
}

signed main()
{
#ifndef ONLINE_JUDGE
	// for getting input from input.txt
	freopen("input.txt", "r", stdin);
	// for writing output to output.txt
	freopen("output.txt", "w", stdout);
#endif

	int n, e;
	cin >> n >> e;

	for (int i = 0; i < n; i++)
		adj[i].clear();

	while (e--)
	{
		int a, b;
		cin >> a >> b;
		adj[a].push_back(b);
		adj[b].push_back(a);
	}

     bool flag = 1;   

	for (int i = 1; i <= n; i++)
	{
		if (vis[i] == 0)
		{
			bool res = dfs(i, 0);
			if (res == 0)
				flag = 0;
		}
	}

	if (flag)
		cout << "IT IS BIPARTITE";
	else
		cout << "NOT BIPARTITE";


}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DETECT CYCLE IN AN UNDIRECTED GRAPH
------------------------------------------------

#include<bits/stdc++.h>
using namespace std;

vector<int>adj[100005];
vector<int>vis(100005);
vector<int>col(100005);

bool dfs(int s, int par)
{
	vis[s] = 1;

	for (auto x : adj[s])
	{
		if (!vis[x])
		{
			if (dfs(x, s) == 1)
				return 1;
		}
		else
		{
			if (x != par)
				return 1;
		}
	}
	return 0;
}

signed main()
{
#ifndef ONLINE_JUDGE
	// for getting input from input.txt
	freopen("input.txt", "r", stdin);
	// for writing output to output.txt
	freopen("output.txt", "w", stdout);
#endif

	int n, e;
	cin >> n >> e;

	for (int i = 1; i <= n; i++)
		adj[i].clear() , vis[i] = 0;

	while (e--)
	{
		int a, b;
		cin >> a >> b;
		adj[a].push_back(b);
		adj[b].push_back(a);
	}

	bool flag = 1;

	for (int i = 1; i <= n; i++)
	{
		if (!vis[i])
		{
			bool res = dfs(i, 0);
			if (res)
			flag = 0;
		}
	}

	if (flag)
		cout << "Graph do not contains cycle";
	else
		cout << "Graph contain cycle";

}


Time Complexity: O(V+E).
Time Complexity of this method is same as time complexity of DFS traversal which is O(V+E).
Space Complexity: O(V).
To store the visited and recursion stack O(V) space is needed.

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DETECT CYCLE IN DIRECTED GRAPH
--------------------------------------------------------------
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define MAX 100005

vector<int>v[MAX];
int n;
vector<bool>rec(MAX);
vector<bool>vis(MAX);

bool dfs(int s, vector<bool> vis, vector<bool> rec)
{
	if (!vis[s])
	{
		vis[s] = 1;
		rec[s] = 1;
		for (auto child : v[s])
		{
			if (!vis[child] && dfs(child, vis, rec)) return 1;
			else if (rec[child] == 1) return 1;
		}
	}
	rec[s] = 0;
	return 0;
}

signed main()
{
#ifndef ONLINE_JUDGE
	freopen("input.txt", "r", stdin);
	freopen("output.txt", "w", stdout);
#endif

	int m, a, b;
	cin >> n >> m;

	while (m--)
	{
		cin >> a >> b;
		v[a].push_back(b);
	}

	bool flag = 1;


	for (int i = 1; i <= n; i++)
	{
		if (!vis[i])
		{
			bool res = dfs(i, vis, rec);
			if (res)
			flag = 0;
		}
	}

	if (flag)
		cout << "Graph do not contains cycle";
	else
		cout << "Graph contain cycle";

}

Complexity Analysis:
Time Complexity: O(V+E).
Time Complexity of this method is same as time complexity of DFS traversal which is O(V+E).
Space Complexity: O(V).
To store the visited and recursion stack O(V) space is needed.


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    
BFS IN GRAPH
(HACKEREARTH: Monk and the Islands)

input:
2
3 2
1 2
2 3
4 4
1 2
2 3
3 4
4 2

output:
 2
 2
----------------------------------------------

#include<bits/stdc++.h>
using namespace std;

vector<int>adj[100005];
vector<int>vis(100005);
vector<int>col(100005);
vector<int>dis(100005);

void bfs(int s)
{
	queue<int>q;
	q.push(s);
	dis[s]=0;
    vis[s]=1;

	while(!q.empty())
	{
		int cur=q.front();
		q.pop();

		for(auto x: adj[cur])
		{
			if(!vis[x])
			{
				q.push(x);
				dis[x]=dis[cur]+1;
				vis[x]=1;
			}
		}
	}
}

signed main()
{
#ifndef ONLINE_JUDGE
	// for getting input from input.txt
	freopen("input.txt", "r", stdin);
	// for writing output to output.txt
	freopen("output.txt", "w", stdout);
#endif

   int t;
   cin>>t;
   while(t--)
   {
	int n, e;
	cin >> n >> e;

	for (int i = 1; i <= n; i++)
		adj[i].clear() , vis[i] = 0;

	while (e--)
	{
		int a, b;
		cin >> a >> b;
		adj[a].push_back(b);
		adj[b].push_back(a);
	}

    bfs(1);

    cout<<dis[n]<<endl;
   }

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




Hello Sir!! Hope you are doing good.
This is to bring your kind notice that i am interested in India intern opportunity in your company. I am currently a final year B.Tech student.

I am proficient in C and C++. Likes to do problem solving. Also, have a basic knowledge of Web Development.

Sir, i have cleared the qualification round of Google Code Jam in both 2019 and 2020, semifinalist of Code Gladiator 2019, have worked an open source contributor for 3 months in GSSoC in 2019, have won various coding competitions at college level and recently cleared the qualification round of Facebook HackerCup 2020 as well.

If you find me suitable for this opening, kindly give me a referral so that i have a chance to work in your esteemed organization.
Warm regards,

Job id : 5397254








































































































   
  
